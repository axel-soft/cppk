//@skip-check bsl-variable-name-invalid

#Область ПрограммныйИнтерфейс

// Функция-обертка, для упрощения возврата значений с длинными названиями
// 
// Параметры:
//  Значение - Произвольный - Значение
//  ЗначениеЕслиПусто - Произвольный - Значение если пусто
// 
// Возвращаемое значение:
//  Произвольный - Заполненное значение
Функция ЗаполненноеЗначение(Значение, ЗначениеЕслиПусто = Неопределено) Экспорт
	
	Возврат ?(ЗначениеЗаполнено(Значение), Значение, ЗначениеЕслиПусто);
	
КонецФункции

// Функция-обертка - в зависимости от заполненности выводит значение в строку, с префиксом и постфиксом.
// 
// Параметры:
//  Префикс - Строка - Префикс
//  Значение - Произвольный - Значение
//  Постфикс - Строка - Постфикс
//  ЗначениеЕслиПусто - Строка - Значение если пусто
// 
// Возвращаемое значение:
//  Строка 
Функция ЗаполненноеЗначениеСтрокой(Префикс, Значение, Постфикс, ЗначениеЕслиПусто = "") Экспорт
	
	Если ЗначениеЗаполнено(Значение) Тогда
		Возврат "" + Префикс + Значение + Постфикс;
	КонецЕсли;
	Возврат ЗначениеЕслиПусто;
	
КонецФункции

// Присвоить, если значение заполнено.
// 
// Параметры:
//  ЧтоПрисвоить - Произвольный - Что присвоить.
//  ЧемуРавно - Произвольный - Чему присвоить.
//
// Возвращаемое значение:
//  Булево - Истина, если удалось присвоить, Ложь, если на вход пришло пустое значение.
Функция ПрисвоитьЗаполненное(ЧтоПрисвоить, ЧемуРавно) Экспорт
	
	Если ЗначениеЗаполнено(ЧемуРавно) И ЧтоПрисвоить <> ЧемуРавно Тогда
		ЧтоПрисвоить = ЧемуРавно;
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Присвоить, если значение отличается, чтобы не возникала модифицированность, если не нужно.
// 
// Параметры:
//  ЧтоПрисвоить - Произвольный - Что присвоить.
//  ЧемуРавно - Произвольный - Чему присвоить.
//
// Возвращаемое значение:
//  Булево - Истина, если удалось присвоить, Ложь, если на вход пришло пустое значение.
Функция ПрисвоитьОтличающееся(ЧтоПрисвоить, ЧемуРавно) Экспорт
	
	Если ЧтоПрисвоить <> ЧемуРавно Тогда
		ЧтоПрисвоить = ЧемуРавно;
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Инициализация при первом запуске. Заполнение справочников - классификаторов по требованиям приказов по МЭДО,
// заполнение констант - настроек.
Процедура ИнициализацияПриПервомЗапуске() Экспорт
	
	Константы.АвтоматическиОтправлятьКвитанцииМЭДО.Установить(Истина);
	Константы.ВариантАвтосозданияУведомленийМЭДО.Установить(
		Перечисления.ВариантыАвтосозданияУведомленийМЭДО.НеСоздавать);
	Константы.ВремяХраненияЖурналаСобытийМЭДО.Установить(365); // по умолчанию
	Константы.РазмерПорцииОбработкиМЭДО.Установить(50);
	Справочники.ВидыДокументовМЭДО.ПервоначальноеЗаполнение();
	Справочники.МестаСоставленияДокументовМЭДО.ПервоначальноеЗаполнение();
	Справочники.ПричиныОтказаВРегистрацииМЭДО.ПервоначальноеЗаполнение();
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

#Область АвтосозданиеОтветныхУведомлений

// Проверить, если надо, то создать уведомление об отказе в регистрации. При загрузке входящего документа.
// Если он есть на нашей стороне и уже зарегистрирован.
// 
// Параметры:
//  ОбщиеПоля - См. МЭДОСтруктурыДанных.НовыйОбщиеПоляУведомления
//  ДанныеОтвета - См. МЭДОСтруктурыДанных.НовыйОтвет
Процедура ПроверитьСоздатьОтказВРегистрации(ОбщиеПоля, ДанныеОтвета) Экспорт
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Состояния.Состояние,
		|	ВЫБОР
		|		КОГДА Состояния.ПредметСообщения ССЫЛКА Документ.УведомлениеМЭДО
		|			ТОГДА Состояния.ПредметСообщения.ТипУведомления
		|		ИНАЧЕ ЗНАЧЕНИЕ(Перечисление.ТипыУведомленийМЭДО.ПустаяСсылка)
		|	КОНЕЦ КАК ТипУведомления
		|ИЗ
		|	РегистрСведений.СостоянияДокументовМЭДО.СрезПоследних(, Документ = &ДокументСсылка
		|	И Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Входящее)) КАК Состояния");
	Запрос.УстановитьПараметр("ДокументСсылка", ОбщиеПоля.Документ);
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Состояние = Выборка.Состояние;
		ТипУведомления = Выборка.ТипУведомления;
		
		// Документ был загружен ранее. Требуется проверка состояния:
		//   * Если документ зарегистрирован или отправлено уведомление о регистрации - отправим уведомление об отказе
		//       в регистрации по причине ДокументЗарегистрированРанееТекстВзаменРазосланногоЗагружен
		//   * Для всех остальных состояний примем полученные изменения
		Если Состояние = Перечисления.СостоянияДокументовМЭДО.ВходящийДокументЗарегистрирован
				Или 
				(Состояние = Перечисления.СостоянияДокументовМЭДО.ОтправленоУведомление
				И ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОРегистрации) Тогда
			Если ТранзакцияАктивна() Тогда
				ОтменитьТранзакцию();
			КонецЕсли;
			
			Если МЭДОПовтИсп.НужноСоздаватьУведомления() Тогда
				// Автоматически создаем уведомление об отказе, документ уже зарегистрирован:
				ОбщиеПоля.Комментарий = НСтр("ru = 'Отказано в регистрации автоматически, документ уже зарегистрирован'");
				
				ПричинаОтказаСсылка = Неопределено;
				Если ОбщиеПоля.ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
					ПричинаОтказаСсылка
						= Справочники.ПричиныОтказаВРегистрацииМЭДО.ДокументЗарегистрированРанееНовыйТекстВзаменРазосланногоЗагружен
				Иначе
					ПричинаОтказаСсылка
						= Справочники.ПричиныОтказаВРегистрацииМЭДО.ДокументЗарегистрированРанееТекстВзаменРазосланногоЗагружен;
				КонецЕсли;
				
				ОтказВРегистрации = МЭДОСтруктурыДанных.НовыйОтказВРегистрации(
					"" + ПричинаОтказаСсылка, ПричинаОтказаСсылка);
				УведомлениеСсылка = СоздатьИсходящееУведомлениеОбОтказеВРегистрации(ОбщиеПоля, ОтказВРегистрации);
			КонецЕсли;
			
			ТекстОшибкиПодробно = СтрШаблон(
				НСтр("ru = 'Документ был уже загружен и зарегистрирован ранее. Текущее состояние документа: %1.
				|%2'"), Состояние, Текст_ПроАвтоУведомлениеОбОтказе(УведомлениеСсылка));
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Информация,
				ОбщиеПоля.Документ, 
				Текст_Автоуведомление(),
				ТекстОшибкиПодробно,
				ДанныеОтвета);
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Создать и записать уведомление о регистрации. В зависимости от настройки сразу помечается или как готовое к отправке
// 
// Параметры:
//  ОбщиеПоля - См. МЭДОСтруктурыДанных.НовыйОбщиеПоляУведомления
//  ОтказВРегистрации - См. МЭДОСтруктурыДанных.НовыйОтказВРегистрации
//
// Возвращаемое значение:
//  ДокументСсылка.УведомлениеМЭДО - Ссылка на созданное уведомление
Функция СоздатьИсходящееУведомлениеОбОтказеВРегистрации(ОбщиеПоля, ОтказВРегистрации) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не МЭДОПовтИсп.НужноСоздаватьУведомления() Тогда
		Возврат Документы.УведомлениеМЭДО.ПустаяСсылка();
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ОтказВРегистрации.ПричинаОтказаСсылка) Тогда
		ВызватьИсключение НСтр("ru = 'Не указана причина отказа, нельзя создать уведомление об отказе в регистрации!'");
	КонецЕсли;
	
	УведомлениеОбъект = Документы.УведомлениеМЭДО.СоздатьИсходящееУведомление_ЗаполнитьОбщиеПоля(
		ОбщиеПоля, Перечисления.ТипыУведомленийМЭДО.ОбОтказеВРегистрации);
	
	НоваяСтрока = УведомлениеОбъект.ОтказВРегистрации.Добавить();
	НоваяСтрока.ПричинаОтказа = ОтказВРегистрации.ПричинаОтказаСсылка;
	
	УведомлениеСсылка = Документы.УведомлениеМЭДО.ЗаписатьУведомление(УведомлениеОбъект);
	Если ЗначениеЗаполнено(УведомлениеСсылка) Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Информация,
			?(ЗначениеЗаполнено(ОбщиеПоля.Документ), ОбщиеПоля.Документ, УведомлениеСсылка), 
			Текст_Автоуведомление(),
			Текст_ПроАвтоУведомлениеОбОтказе(УведомлениеОбъект.Ссылка),
			Неопределено);
	КонецЕсли;
	
	Возврат УведомлениеСсылка;
	
КонецФункции

// Создать и записать уведомление о регистрации. В зависимости от настройки сразу помечается или как готовое к отправке
// 
// Параметры:
//  ОбщиеПоля - См. МЭДОСтруктурыДанных.НовыйОбщиеПоляУведомления
//  Регистрация - См. МЭДОСтруктурыДанных.НовыйРегистрация
//
// Возвращаемое значение:
//  ДокументСсылка.УведомлениеМЭДО - Ссылка на созданное уведомление
Функция СоздатьИсходящееУведомлениеОРегистрации(ОбщиеПоля, Регистрация) Экспорт
	
	Если Не ЗначениеЗаполнено(Регистрация.РегистрационныйНомер) Тогда
		ВызватьИсключение НСтр("ru = 'Нет регистрационного номера, нельзя создать уведомление о регистрации!'");
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	УведомлениеОбъект = Документы.УведомлениеМЭДО.СоздатьИсходящееУведомление_ЗаполнитьОбщиеПоля(
		ОбщиеПоля, Перечисления.ТипыУведомленийМЭДО.ОРегистрации);
	
	НоваяСтрока = УведомлениеОбъект.Регистрация.Добавить();
	НоваяСтрока.РегистрационныйНомер = Регистрация.РегистрационныйНомер;
	НоваяСтрока.ДатаРегистрации = Регистрация.ДатаРегистрации;
	
	Документы.УведомлениеМЭДО.ЗаписатьУведомление(УведомлениеОбъект);
	Если ЗначениеЗаполнено(УведомлениеОбъект.Ссылка) Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Информация,
			ОбщиеПоля.Документ,
			Текст_Автоуведомление(),
			НСтр("ru = 'Автоматически создано уведомление о регистрации'"),
			Неопределено);
	КонецЕсли;
	
	Возврат УведомлениеОбъект.Ссылка;
	
КонецФункции

#КонецОбласти

#Область Обмен_ТочкиВхода

#Если Не ВнешнееСоединение Тогда

// Обработчик регламентного задания, выполняет обмен МЭДО по расписанию.
Процедура ВыполнитьОбменМЭДО() Экспорт
	
	Отказ = Ложь;
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.ВыполнениеОбменаМЭДО, Отказ);
	Если Отказ = Истина Тогда
		Возврат;
	КонецЕсли;
	
	МЭДОПереопределяемый.ПроверитьОбменСВнешнимиРесурсами(Отказ);
	Если Отказ Тогда
		Возврат;
	КонецЕсли;
	
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Все организации, которые настроены:
	Запрос = Новый Запрос(
		"ВЫБРАТЬ *
		|ИЗ
		|	РегистрСведений.НастройкиОрганизацийМЭДО КАК Настройки");
	Результат = Запрос.Выполнить();
	Настройки = РегистрыСведений.НастройкиОрганизацийМЭДО.НовыйНастройки();
	
	Выборка = Результат.Выбрать();
	ДанныеОтвета = МЭДОСтруктурыДанных.НовыйЛегкийОтвет();
	Пока Выборка.Следующий() Цикл
		ЗаполнитьЗначенияСвойств(Настройки, Выборка);
		РегистрыСведений.НастройкиОрганизацийМЭДО.ПроверкаКритичноВажныхПолей(
			Выборка.Организация, Настройки, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Продолжить;
		КонецЕсли;
		
		ПолучитьВходящиеСообщения(Настройки);
		ОтправитьИсходящиеКвитанции(Настройки, ДанныеОтвета); //@skip-check query-in-loop
		ДанныеОтвета = МЭДОСтруктурыДанных.НовыйЛегкийОтвет();
		ОтправитьИсходящиеДокументы(Настройки, ДанныеОтвета, Неопределено); //@skip-check query-in-loop
		ОтправитьИсходящиеУведомления(Настройки, ДанныеОтвета, Неопределено); //@skip-check query-in-loop
	КонецЦикла;
	
	ОчиститьСтарыеЗаписиЖурнала(ДанныеОтвета);
	
КонецПроцедуры

// Прочитать сообщения из каталога получения
// 
// Параметры:
//  Настройки - См. РегистрыСведений.НастройкиОрганизацийМЭДО.НовыйНастройки
//  ТипыКонтента - Строка - Через запятую типы контента, по умолчанию все возможные типы. Если перечислить не все типы,
//							то входные файл не того типа во входном каталоге будут пропущены.
Процедура ПолучитьВходящиеСообщения(
	Настройки, ТипыКонтента = "Транспортный контейнер, Документ, Уведомление, Квитанция") Экспорт
	
	Путь = Настройки.КаталогПолучения;
	ПутьСРазделителем = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(Путь);
	
	ДанныеОтвета = МЭДОСтруктурыДанных.НовыйЛегкийОтвет();
	
	ПроверитьСуществуетЛиКаталог(Путь, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	
	ПутьПринятых = ПутьСРазделителем + ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути("processed");
	СоздатьКаталогЕслиНет(ПутьПринятых, ДанныеОтвета);
	ПутьОшибочных = ПутьСРазделителем + ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути("errors");
	СоздатьКаталогЕслиНет(ПутьОшибочных, ДанныеОтвета);
	
	// Входные сообщения могут приходить, как в папках, так и zip-архивах, где внутри те же файлы, приводим все 
	// к архивам, т.к. в случае ошибки в журнал кладется архив с сообщением:
	Счетчик = 0;
	РазмерПорции = МЭДОПовтИсп.РазмерПорцииОбработки();
	Для Каждого Папка Из НайтиФайлы(Путь, "*") Цикл
		Если Не Папка.ЭтоКаталог() Тогда
			Продолжить;
		КонецЕсли;
		Если Папка.ПолноеИмя = Путь Тогда
			Продолжить; // находит саму себя тоже.
		КонецЕсли;
		Если Папка.Имя = "processed" Или Папка.Имя = "errors" Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяАрхива = ПутьСРазделителем + Папка.Имя + ".zip";
		ЗаписьАрхива = Новый ЗаписьZipФайла(ИмяАрхива, , , , УровеньСжатияZIP.Оптимальный);
		ЗаписьАрхива.Добавить(
			ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(Папка.ПолноеИмя) + "*.*",
			РежимСохраненияПутейZIP.СохранятьОтносительныеПути,
			РежимОбработкиПодкаталоговZIP.ОбрабатыватьРекурсивно);
		ЗаписьАрхива.Записать();
		УдалитьФайлы(Папка.ПолноеИмя);
		
		Счетчик = Счетчик + 1;
		Если Счетчик > РазмерПорции Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;

	Счетчик = 0;
	Для Каждого ФайлСообщения Из НайтиФайлы(Путь, ПреобразованнаяМаскаФайловLinux("*.zip")) Цикл
		// Передаем исходный zip-архив, в случае ошибок будет сохраняться в журнале.
		ДанныеОтвета = МЭДОСтруктурыДанных.НовыйОтвет(ФайлСообщения.Имя, Новый ДвоичныеДанные(ФайлСообщения.ПолноеИмя));
		
		ОбработатьВходящееЭСД(ФайлСообщения, Настройки, ТипыКонтента, ДанныеОтвета); //@skip-check query-in-loop
		
		Если ДанныеОтвета.СообщениеОбОшибке = "ДругойВерныйТипСообщения" Тогда
			Продолжить;
		ИначеЕсли ДанныеОтвета.Успех Тогда
			ПереместитьФайл(ФайлСообщения.ПолноеИмя, ПутьПринятых + ФайлСообщения.Имя);
		Иначе
			ПереместитьФайл(ФайлСообщения.ПолноеИмя, ПутьОшибочных + ФайлСообщения.Имя);
		Конецесли;
		
		Счетчик = Счетчик + 1;
		Если Счетчик > РазмерПорции Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Записать сообщения по исходящим документам в каталог отправки
// 
// Параметры:
//  Настройки - См. РегистрыСведений.НастройкиОрганизацийМЭДО.НовыйНастройки
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
//  МассивДокументов - Массив из ОпределяемыйТип.ПредметМЭДО, Неопределено - Если Неопределено, то все, подлежащие 
//  																		отправке по этой организации, 
//																			либо отбор по выбранным документам.
Процедура ОтправитьИсходящиеДокументы(Настройки, ДанныеОтвета, МассивДокументов = Неопределено) Экспорт
	
	ПроверитьСуществуетЛиКаталог(Настройки.КаталогОтправки, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаДокументов = ИсходящиеДокументыКОтправке(Настройки.Организация, МассивДокументов);
	Если ТаблицаДокументов.Количество() > 0 Тогда
		Для Каждого СтрокаТЗ Из ТаблицаДокументов Цикл
			ДанныеОтвета = МЭДОСтруктурыДанных.НовыйЛегкийОтвет();
			ОтправитьИсходящийДокумент(Настройки, СтрокаТЗ.Документ, ДанныеОтвета);
		КонецЦикла;
	Иначе
		// Ошибки нет, но если вызвано с клиента, нужно сообщить:
		ДанныеОтвета.Успех = Истина;
		ДанныеОтвета.СообщениеОбОшибке = НСтр("ru = 'Не найдено документа/ов, готовых к отправке'");
	КонецЕсли;
	
КонецПроцедуры

#КонецЕсли

// Записать сообщения по квитанциям в папку отправки.
// 
// Параметры:
//  Настройки - См. РегистрыСведений.НастройкиОрганизацийМЭДО.НовыйНастройки
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
//  МассивКвитанций - Массив из ДокументСсылка.КвитанцияМЭДО - Отбор по выбранным квитанциям
//  				- Неопределено - Если Неопределено, то все, подлежащие отправке по этой организации 
Процедура ОтправитьИсходящиеКвитанции(Настройки, ДанныеОтвета, МассивКвитанций = Неопределено) Экспорт
	
	ДанныеОтвета = МЭДОСтруктурыДанных.НовыйЛегкийОтвет();
	ПроверитьСуществуетЛиКаталог(Настройки.КаталогОтправки, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	
	ДанныеКвитанций = ДанныеИсходящихКвитанцийДляОтправки(Настройки, МассивКвитанций);
	
	Счетчик = 0;
	РазмерПорции = МЭДОПовтИсп.РазмерПорцииОбработки();
	Для Каждого КлючИЗначение Из ДанныеКвитанций Цикл
		Квитанция = КлючИЗначение.Ключ;
		ДанныеКвитанции = КлючИЗначение.Значение;
		
		Счетчик = Счетчик + 1;
		Если Счетчик > РазмерПорции Тогда
			Прервать;
		КонецЕсли;
		
		ДанныеОтвета = МЭДОСтруктурыДанных.НовыйОтвет();
		ЗаписатьСообщениеПоИсходящейКвитанции(Настройки.КаталогОтправки, Квитанция, ДанныеКвитанции, ДанныеОтвета);
		
		Если Не ДанныеОтвета.Успех Тогда
			Если ЗначениеЗаполнено(ДанныеКвитанции.ПодкаталогСообщения) Тогда
				УдалитьФайлы(ДанныеКвитанции.ПодкаталогСообщения);
			КонецЕсли;
			Если ЗначениеЗаполнено(ДанныеКвитанции.ВременныйКаталог) Тогда
				УдалитьФайлы(ДанныеКвитанции.ВременныйКаталог);
			КонецЕсли;
			
			Документы.КвитанцияМЭДО.СнятьПризнакГотоваКОтправке(
				Квитанция, МЭДОСтруктурыДанных.НовыйЛегкийОтвет());
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Записать сообщения по исходящим уведомлениям в каталог отправки
// 
// Параметры:
//  Настройки - См. РегистрыСведений.НастройкиОрганизацийМЭДО.НовыйНастройки
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет
//  МассивУведомлений - Массив из ДокументСсылка.УведомлениеМЭДО - Если Неопределено, то все, подлежащие 
//  																отправке по этой организации, 
//																	либо отбор по выбранным уведомлениям.
Процедура ОтправитьИсходящиеУведомления(Настройки, ДанныеОтвета, МассивУведомлений = Неопределено) Экспорт

	ПроверитьСуществуетЛиКаталог(Настройки.КаталогОтправки, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаУведомлений = ИсходящиеУведомленияКОтправке(Настройки.Организация, МассивУведомлений);
	Для Каждого СтрокаТЗ Из ТаблицаУведомлений Цикл
		ДанныеОтвета = МЭДОСтруктурыДанных.НовыйОтвет();
		ОтправитьИсходящееУведомление(Настройки, СтрокаТЗ.ПредметСообщения, ДанныеОтвета);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

// Определяет список входящих документов, полученных через МЭДО, которые требуется обработать.
// 
// Параметры:
//  МассивДокументов - Массив из ОпределяемыйТип.ПредметМЭДО,Неопределено - Массив документов
// 
// Возвращаемое значение:
//  ТаблицаЗначений -- таблица с колонками::
// * ИдентификаторСообщения - Строка - УИд сообщения обмена.
// * Состояние - ПеречислениеСсылка.СостоянияДокументовМЭДО - состояние входящего документа.
// * Документ - ОпределяемыйТип.ПредметМЭДО - ссылка на входящий документ.
Функция ВходящиеДокументыКОбработке(МассивДокументов = Неопределено) Экспорт
	
	Возврат РегистрыСведений.СостоянияДокументовМЭДО.СрезСостоянияДокументов(
		Перечисления.НаправленияСообщенийМЭДО.Входящее,
		"ИдентификаторСообщения, Состояние, Документ",
		,
		Перечисления.СостоянияДокументовМЭДО.СостоянияВходящиеДокументыКОбработке(),
		МассивДокументов);
	
КонецФункции

// Определяет список уведомлений, полученных через МЭДО, которые требуется обработать.
//
// Параметры:
//  МассивДокументов - Массив из ОпределяемыйТип.ПредметМЭДО,Неопределено - Массив документов
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица с колонками:
//     * Документ - ОпределяемыйТип.ПредметМЭДО - ссылка на исходящий документ к отправке.
//     * Уведомление - Строка - содержание уведомления.
//     * Состояние - ПеречислениеСсылка.СостоянияДокументовМЭДО - состояние
//               исходящего документа.
//
Функция ВходящиеУведомленияКОбработке(МассивДокументов = Неопределено) Экспорт
	
	Возврат РегистрыСведений.СостоянияДокументовМЭДО.СрезСостоянияДокументов(
		Перечисления.НаправленияСообщенийМЭДО.Исходящее,
		"ПредметСообщения, ПредметСообщения.ТипУведомления КАК ТипУведомления, Документ, ИдентификаторСообщения, Состояние",
		,
		Перечисления.СостоянияДокументовМЭДО.СостоянияВходящиеУведомленияКОбработке(),
		МассивДокументов);
	
КонецФункции

// Изменить признак отправки документа.
// 
// Параметры:
//  Документ - ОпределяемыйТип.ПредметМЭДО
//  НазваниеДействия - Строка - "ОтменитьОтправку" или "ПовторитьОтправку"
Процедура ИзменитьПризнакОтправки(Документ, НазваниеДействия) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ДанныеОтвета = МЭДОСтруктурыДанных.НовыйЛегкийОтвет();
	ДанныеМЭДО = Документы.ДанныеДокументаМЭДО.ДанныеДокументаМЭДО(
		Документ, "Ссылка, ГотовКОтправке, Отправлен", ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ДанныеМЭДО.Ссылка) Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			Документ,
			НСтр("ru = 'Ошибка записи ""Данных документа МЭДО""'"),
			СтрШаблон(НСтр("ru = 'К документу ""%1"" не найдено ""Данных документа МЭДО""'"), Документ),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	Если НазваниеДействия = "ОтменитьОтправку" И ДанныеМЭДО.ГотовКОтправке Тогда
		ДанныеМЭДООбъект = ДанныеМЭДО.Ссылка.ПолучитьОбъект();
		ДанныеМЭДООбъект.ГотовКОтправке = Ложь;
		ДанныеМЭДООбъект.Записать();
	ИначеЕсли НазваниеДействия = "ПовторитьОтправку" И ДанныеМЭДО.Отправлен Тогда 
		ДанныеМЭДООбъект = ДанныеМЭДО.Ссылка.ПолучитьОбъект();
		ДанныеМЭДООбъект.Отправлен = Ложь;
		ДанныеМЭДООбъект.ГотовКОтправке = Истина;
		ДанныеМЭДООбъект.Записать();
	КонецЕсли;
	
КонецПроцедуры

// Определяет список исходящих документов, которые требуется отправить через МЭДО.
//
// Параметры:
//  Организация - ОпределяемыйТип.Организация -
//  МассивДокументов - Массив из ОпределяемыйТип.ПредметМЭДО, Неопределено - Если задано, то отбор по документам, если
//  																		 не задано, то все, готовые к отправке.
// 
// Возвращаемое значение:
//   ТаблицаЗначений - таблица с колонками:
//     * Документ - ОпределяемыйТип.ПредметМЭДО - ссылка на исходящий документ к отправке.
//     * Состояние - ПеречислениеСсылка.СостоянияДокументовМЭДО - состояние исходящего документа.
Функция ИсходящиеДокументыКОтправке(Организация, МассивДокументов = Неопределено) Экспорт
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 9999
		|	ДанныеМЭДО.Документ,
		|	Состояния.Состояние
		|ИЗ
		|	Документ.ДанныеДокументаМЭДО КАК ДанныеМЭДО
		|	ЛЕВОЕ СОЕДИНЕНИЕ
		|	РегистрСведений.СостоянияДокументовМЭДО.СрезПоследних(
		|		, Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Исходящее)
		|		) КАК Состояния
		|		ПО ДанныеМЭДО.Документ = Состояния.Документ
		|ГДЕ
		|	ДанныеМЭДО.ГотовКОтправке
		|	И НЕ ДанныеМЭДО.ПометкаУдаления
		|	И НЕ ДанныеМЭДО.Документ.ПометкаУдаления
		|	И ДанныеМЭДО.Организация = &Организация
		|	И ДанныеМЭДО.Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Исходящее)
		|	И НЕ ДанныеМЭДО.ПредыдущаяОтправка
		|	И &ОтборДокументов
		|
		|УПОРЯДОЧИТЬ ПО
		|	ДанныеМЭДО.Дата");
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "9999", Формат(МЭДОПовтИсп.РазмерПорцииОбработки(), "ЧГ=0;"));
	Запрос.УстановитьПараметр("Организация", Организация);
	Если МассивДокументов <> Неопределено Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ОтборДокументов", "ДанныеМЭДО.Документ В (&МассивДокументов)");
		Запрос.УстановитьПараметр("МассивДокументов", МассивДокументов);
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ОтборДокументов", "ИСТИНА");
	КонецЕсли;
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

// Исходящий документ должен отправляться каждый раз с новым идентификатором сообщения (если он уже отправлялся и надо
// переотправить). Если документ уже был отправлен, то создает новый вспомогательный документ ДанныеДокументаМЭДО,
// старый "помещает в историю". Неявно возвращает ДанныеДокументаМЭДО уже подмененные новые.
// 
// Параметры:
//  ДанныеДокументаМЭДО - Структура - Состав полей, см. ДокументОбъект.ДанныеДокументаМЭДО
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет
Процедура ПересоздатьДанныеМЭДОПриПовторнойОтправке(ДанныеДокументаМЭДО, ДанныеОтвета) Экспорт
	
	Если Не ДанныеДокументаМЭДО.Отправлен Тогда
		Возврат; // Еще не отправлялся, ничего делать не надо.
	КонецЕсли;
	
	// Старый документ "помещаем в историю":
	ДанныеОбъект = ДанныеДокументаМЭДО.Ссылка.ПолучитьОбъект();
	ДанныеОбъект.ПредыдущаяОтправка = Истина; // Помещаем в "историю".
	ДанныеОбъект.ГотовКОтправке = Ложь;
	ДанныеОбъект.Записать();
	
	// создаем новый:
	ДанныеОбъект = Документы.ДанныеДокументаМЭДО.СоздатьДокумент();
	ДанныеОбъект.Документ = ДанныеДокументаМЭДО.Документ;
	ДанныеОбъект.Дата = ТекущаяДатаСеанса();
	ДанныеОбъект.Отправлен = Ложь;
	ДанныеОбъект.ГотовКОтправке = Истина;
	ЗаполнитьЗначенияСвойств(
		ДанныеОбъект, ДанныеДокументаМЭДО,
		"ВидДокумента, ГлавныйФайл, ГрифДоступа, Комментарий, МестоСоставления, Организация, Ответственный,
		|Направление");
	// ТЧ "Пакеты" создастся "ПередЗаписью".
	ДанныеОбъект.ДополнительныеСвойства.Вставить("ПропуститьПроверкуУникальности", Истина);
	ДанныеОбъект.Записать();
	
	// Подменяем данные новым вспомогательным документом:
	ДанныеДокументаМЭДО = Документы.ДанныеДокументаМЭДО.ДанныеДокументаМЭДО(
		ДанныеДокументаМЭДО.Документ, "*", ДанныеОтвета);
	
КонецПроцедуры

// Определяет список уведомлений, которые требуется отправить через МЭДО.
//
// Параметры:
//  Организация - ОпределяемыйТип.Организация -
//  МассивУведомлений - Массив из ДокументСсылка.УведомлениеМЭДО - Если Неопределено, то все, подлежащие 
//  																отправке по этой организации, 
//																	либо отбор по выбранным уведомлениям.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица с колонками:
//     * ПредметСообщения - ДокументСсылка.УведомлениеМЭДО
//     * ТипУведомления - ПеречислениеСсылка.ТипыУведомленийМЭДО
//     * Документ - ОпределяемыйТип.ПредметМЭДО - Входящий документ
//     * ИдентификаторСообщения - Строка
//     * Состояние - ПеречислениеСсылка.СостоянияДокументовМЭДО - состояние входящего документа.
Функция ИсходящиеУведомленияКОтправке(Организация, МассивУведомлений = Неопределено) Экспорт
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 9999
		|	Уведомление.Ссылка КАК ПредметСообщения,
		|	Уведомление.ТипУведомления,
		|	Уведомление.Документ,
		|	Уведомление.ИдентификаторУведомления КАК ИдентификаторСообщения,
		|	Состояния.Состояние
		|ИЗ
		|	Документ.УведомлениеМЭДО КАК Уведомление
		|	ЛЕВОЕ СОЕДИНЕНИЕ
		|	РегистрСведений.СостоянияДокументовМЭДО.СрезПоследних(
		|		, Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Входящее)
		|		) КАК Состояния
		|		ПО Уведомление.Документ = Состояния.Документ
		|ГДЕ
		|	Уведомление.ГотовоКОтправке
		|	И НЕ Уведомление.ПометкаУдаления
		|	И НЕ ЕСТЬNULL(Уведомление.Документ.ПометкаУдаления, ЛОЖЬ)
		|	И Уведомление.Организация = &Организация
		|	И Уведомление.Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Исходящее)
		|	И &ОтборУведомлений
		|
		|УПОРЯДОЧИТЬ ПО
		|	Уведомление.Дата");
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "9999", Формат(МЭДОПовтИсп.РазмерПорцииОбработки(), "ЧГ=0;"));
	Запрос.УстановитьПараметр("Организация", Организация);
	Если МассивУведомлений <> Неопределено Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ОтборУведомлений", "Уведомление.Ссылка В (&МассивУведомлений)");
		Запрос.УстановитьПараметр("МассивУведомлений", МассивУведомлений);
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ОтборУведомлений", "ИСТИНА");
	КонецЕсли;
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

// Гриф доступа в виде структуры для последующей записи ее в файл контейнера.
// 
// Параметры:
//  ГрифДоступа - ОпределяемыйТип.ГрифДоступаМЭДО - Гриф доступа
//  НастройкиОрганизации - Структура - поля соответствуют ресурсам РС НастройкиОрганизацийМЭДО, в том числе:
//   * ГрифОбычнаяИнформация - ОпределяемыйТип.ГрифДоступаМЭДО
//   * ГрифИнформацияОграниченногоРаспространения  - ОпределяемыйТип.ГрифДоступаМЭДО
// 
// Возвращаемое значение:
//  см. МЭДОСтруктурыДанных.НовыйОграниченноеЗначение.
Функция ГрифДоступаВВидеСтруктуры(ГрифДоступа, НастройкиОрганизации) Экспорт
	
	СтруктураГриф = МЭДОСтруктурыДанных.НовыйОграниченноеЗначение();
	
	Если ГрифДоступа = НастройкиОрганизации.ГрифОбычнаяИнформация Тогда
		СтруктураГриф.Идентификатор = "DC00000000";
		СтруктураГриф.Наименование = "Обычная информация";
	ИначеЕсли ГрифДоступа = НастройкиОрганизации.ГрифИнформацияОграниченногоРаспространения Тогда
		СтруктураГриф.Идентификатор = "DC00000001";
		СтруктураГриф.Наименование = "Информация ограниченного распространения";
	КонецЕсли;
	
	Возврат СтруктураГриф;
	
КонецФункции

// Процедура - делает тоже, что и СоздатьЗапись, но в фоновом задании, чтобы если эта запись в журнал осталась, даже
//   если произошла отмена транзакции, из которой вызвана эта процедура.
// 
// На выходе присвоит входной структуре Данные поля:
//   Успех = Ложь
//   СообщениеОбОшибке = Подробный текст ошибки.
//
// Параметры:
//  Уровень - ПеречислениеСсылка.УровниСобытийМЭДО - Уровень: Ошибка, Предупреждение, Информация.
//  Объект - ОпределяемыйТип.ОбъектСОшибкойМЭДО - Объект, с которым связана ошибка.
//  ТекстОшибкиКратко - Строка - Краткий текст ошибки
//  ТекстОшибкиПодробно - Строка - Подробный текст ошибки
//  ДанныеОтвета - Структура, Неопределено - Если передано Неопределено, то в журнал не писать, 
//  						но просто выдать сообщение. см. МЭДОСтруктурыДанных.НовыйОтвет. 
Процедура ЗаписьВЖурналСобытий(
	Уровень, Объект, ТекстОшибкиКратко, ТекстОшибкиПодробно, ДанныеОтвета = Неопределено) Экспорт
	
	ДатаСобытия = ТекущаяДатаСеанса();
	Сообщение = СтрШаблон(
		НСтр("ru = '%1, %2: %3 // %4 // %5.
		|(см. Журнал событий МЭДО)'"),
		Уровень, ДатаСобытия, Объект, ТекстОшибкиКратко, ТекстОшибкиПодробно);
	
	// Продублировать на экран, если запускает пользователь, а не из регламентного задания:
	ЭтоФоновоеЗадание = МЭДОПереопределяемый.ЭтоФоновоеЗадание();
	Если Не ЭтоФоновоеЗадание Тогда
		Если ЗначениеЗаполнено(Объект) И ОбщегоНазначения.ЭтоСсылка(ТипЗнч(Объект)) Тогда
			ОбщегоНазначения.СообщитьПользователю(СтрШаблон("%1: %2", ТекстОшибкиПодробно, Объект), Объект);
		Иначе
			ОбщегоНазначения.СообщитьПользователю(ТекстОшибкиПодробно);
		КонецЕсли;
	КонецЕсли;
	Если ДанныеОтвета = Неопределено Тогда
		Возврат; // просто выдать сообщение об ошибке на экран и выйти.
	КонецЕсли;
	
	СтруктураЗаписи = Новый Структура();
	СтруктураЗаписи.Вставить("Идентификатор",		"" + Новый УникальныйИдентификатор());
	СтруктураЗаписи.Вставить("Уровень",				Уровень);
	СтруктураЗаписи.Вставить("ДатаСобытия",			ДатаСобытия);
	СтруктураЗаписи.Вставить("Объект",				Объект);
	СтруктураЗаписи.Вставить("ТекстОшибкиКратко",	ТекстОшибкиКратко);
	СтруктураЗаписи.Вставить("ТекстОшибкиПодробно",	ТекстОшибкиПодробно);
	СтруктураЗаписи.Вставить("ЭтоФоновоеЗадание",	ЭтоФоновоеЗадание);
	
	Если Уровень = Перечисления.УровниСобытийМЭДО.Ошибка Тогда
		ДанныеОтвета.Успех = Ложь;
		ДанныеОтвета.СообщениеОбОшибке = Сообщение;
	КонецЕсли;
	
	Если ТранзакцияАктивна() Тогда
		// Запись в фоне, чтобы даже при дальнейшей отмене транзакции эта запись осталась.
		Аргументы = Новый Массив();
		Аргументы.Добавить(СтруктураЗаписи);
		Аргументы.Добавить(ДанныеОтвета);
		ФоновыеЗадания.Выполнить(
			"МЭДО.ЗаписьВЖурналСобытий_ВФонеИлиНепосредственно",
			Аргументы,
			СтруктураЗаписи.Идентификатор,
			НСтр("ru = 'Запись события МЭДО в журнал'"));
	Иначе
		ЗаписьВЖурналСобытий_ВФонеИлиНепосредственно(СтруктураЗаписи, ДанныеОтвета)
	КонецЕсли;
	
КонецПроцедуры

// Признак того, что переданное значение, хранящееся в РС СлужебныеФайлыДокументов это "Положение" и оно заполнено,
// т.е. см. МЭДОСтруктурыДанных.НовыйПоложениеИзображения. Если да, то отметку (штамп) надо ставить по заданным координатам,
// иначе - по общим настройкам ДО для всех (правый верхний угол, левый нижний и т.п.)
// 
// Параметры:
//  Положение - Структура,Неопределено - Переданное значение, хранящееся в РС СлужебныеФайлыДокументов.
// 
// Возвращаемое значение:
//  Булево - Это положение по координатам или нет.
Функция ЭтоЗаполненноеПоложениеИзображения(Положение) Экспорт
	
	Возврат ТипЗнч(Положение) = Тип("Структура")
		И Положение.Свойство("Страница") И ЗначениеЗаполнено(Положение.Страница)
		И Положение.Свойство("Слева") И Положение.Слева <> Неопределено // может быть = 0
		И Положение.Свойство("Сверху") И Положение.Сверху <> Неопределено // может быть = 0
		И Положение.Свойство("Ширина") И ЗначениеЗаполнено(Положение.Ширина)
		И Положение.Свойство("Высота") И ЗначениеЗаполнено(Положение.Высота);
	
КонецФункции

// Требуется ли перезаписать "Положение". Если записанное в базе "Положение" отсутствует, или отличается от нового. 
// Записанного положения может пока не быть вообще, т.е. Неопределено, тогда сразу ответ Да. Если записанное положение
// уже есть, то проверит, отличаются ли все координаты и размеры.
// 
// Параметры:
//  ПоложениеНовое - см. МЭДОСтруктурыДанных.НовыйПоложениеИзображения
//  ПоложениеЗаписанное - см. МЭДОСтруктурыДанных.НовыйПоложениеИзображения
//  
// Возвращаемое значение:
//  Булево - Требуется перезаписать положение
Функция ТребуетсяПерезаписатьПоложение(ПоложениеНовое, ПоложениеЗаписанное) Экспорт
	
	Если Не ЭтоЗаполненноеПоложениеИзображения(ПоложениеЗаписанное) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПоложениеНовое.Страница = ПоложениеЗаписанное.Страница
		И ПоложениеНовое.Слева = ПоложениеЗаписанное.Слева
		И ПоложениеНовое.Сверху = ПоложениеЗаписанное.Сверху
		И ПоложениеНовое.Ширина = ПоложениеЗаписанное.Ширина
		И ПоложениеНовое.Высота = ПоложениеЗаписанное.Высота Тогда
		Возврат Ложь; // Положения равны, перезаписывать не нужно.
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

#Область ТекстовыеКонстанты

// Текст - "Автоуведомление".
// 
// Возвращаемое значение:
//  Строка -
Функция Текст_Автоуведомление() Экспорт

	Возврат НСтр("ru = 'Автоуведомление'");
	
КонецФункции

Функция Текст_ИсходящийДокументНеМЭДО() Экспорт
	
	Возврат НСтр("ru = 'Документ не обозначен, как отправляемый по МЭДО (указать Способ доставки = МЭДО)'");
	
КонецФункции

Функция Текст_ДокументНеЗарегистрирован() Экспорт
	
	Возврат НСтр("ru = 'Документ не зарегистрирован'");
	
КонецФункции

Функция Текст_НеЗаполненВидДокумента() Экспорт
	
	Возврат НСтр("ru = 'Поле ""Вид документа МЭДО"" не заполнено.'");
	
КонецФункции

Функция Текст_НеЗаполненоМестоСоставления() Экспорт
	
	Возврат НСтр("ru = 'Поле ""Место составления по классификатору МЭДО"" не заполнено.'");
	
КонецФункции

Функция Текст_НеОпределенГлавныйФайл() Экспорт
	
	Возврат НСтр("ru = 'Поле ""Главный файл"" не заполнено. (И у него не должно быть признака ""Скан-копия"")'");
	
КонецФункции

Функция Текст_НетПодписиГлавногоФайла() Экспорт
	
	Возврат НСтр("ru = 'У главного файла документа нет ни одной электронной подписи.'");
	
КонецФункции

Функция Текст_НеуспешнаяОтправка() Экспорт
	
	Возврат НСтр("ru = 'Неуспешная отправка'");
	
КонецФункции

Функция Текст_ОшибкаВДокументе() Экспорт
	
	Возврат НСтр("ru = 'Ошибка в исходящем документе'");
	
КонецФункции

Функция Текст_СнятиеПризнакаГотовностиКОтправке() Экспорт
	
	Возврат НСтр("ru = 'Отправка не удалась - снятие признака готовности к отправке. См. предыдущие сообщения в журнале событий МЭДО'");
	
КонецФункции

// Текст - файл не найден.
// 
// Возвращаемое значение:
//  Строка -
Функция Текст_ФайлНеНайден() Экспорт
	
	Возврат НСтр("ru = 'Файл не найден'");
	
КонецФункции

// Текст - файл не найден, подробней.
// 
// Параметры:
//  ИмяФайла - Строка -
// 
// Возвращаемое значение:
//  Строка -
Функция Текст_ФайлНеНайденПодробно(ИмяФайла) Экспорт

	Возврат СтрШаблон(НСтр("ru = 'В контейнере не найден файл %1'"), ИмяФайла);
	
КонецФункции

Функция Обозначение_ВнешнийДокумент() Экспорт
	
	Возврат "DocumentMedo";
	
КонецФункции

Функция Обозначение_ВнешнийКонтрагент() Экспорт
	
	Возврат "OrganizationMedo";
	
КонецФункции

Функция Обозначение_ВнешнееКонтактноеЛицо() Экспорт
	
	Возврат "ContactPersonMedo";
	
КонецФункции

#КонецОбласти

// Приводит имя файла к виду [a-zA-Z0-9_]{1,250}.[a-zA-Z0-9]{3,4} - т.е. определенные символы, имя до 250 символов, 
// расширение от 3 до 4 символов.
// 
// Параметры:
//  ИмяФайла - Строка - Исходное Имя файла, без расширения
//  РасширениеФайла - Строка - Исходное расширение файла
//  ВсеИменаФайлов - Массив Из Строка - Массив уже внесенных имен файлов в структуру данных для отправки, чтобы
//  									предотвратить дублирование имен файлов.
// 
// Возвращаемое значение:
//  Строка
Функция ЗаменитьНеподходящееИмяФайла(Знач ИмяФайла, Знач РасширениеФайла, ВсеИменаФайлов) Экспорт
	
	ИмяФайла = СокрЛП(СтроковыеФункции.СтрокаЛатиницей(ИмяФайла));
	Если СтрДлина(ИмяФайла) > 250 Тогда
		ИмяФайла = Лев(ИмяФайла, 250);
	КонецЕсли;
	ИмяФайла = ЗаменитьНеподходящиеСимволы(ИмяФайла);
	
	РасширениеФайла = СокрЛП(СтроковыеФункции.СтрокаЛатиницей(РасширениеФайла));
	Если СтрДлина(РасширениеФайла) < 3 Тогда
		РасширениеФайла = РасширениеФайла + "___"; // что гарантированно было больше 3 символов.
	КонецЕсли;
	Если СтрДлина(РасширениеФайла) > 4 Тогда
		РасширениеФайла = Лев(РасширениеФайла, 4);
	КонецЕсли;
	РасширениеФайла = ЗаменитьНеподходящиеСимволы(РасширениеФайла);
	
	ИмяФайлаДопустимое = СтрШаблон("%1.%2", ИмяФайла, РасширениеФайла);
	Если ВсеИменаФайлов.Найти(ИмяФайлаДопустимое) <> Неопределено Тогда
		// Среди уже добавленных такое есть, добавим сзади "_":
		ИмяФайлаДопустимое = СтрШаблон("%1_.%2", ИмяФайла, РасширениеФайла);
	КонецЕсли;
	ВсеИменаФайлов.Добавить(ИмяФайлаДопустимое);
	
	Возврат ИмяФайлаДопустимое;
	
КонецФункции

// Получить поля контрагента, участвующего в обмене МЭДО, для заполнения стандартных структур.
// 
// Параметры:
//  КонтрагентСсылка - ОпределяемыйТип.КонтрагентМЭДО - контрагент.
//  ДатаСведений - Дата - На какую дату получить сведения о наименовании (если поддерживается в конфигурации). 
//  						Если передана пустая дата, то будет актуальное наименование.
//  ВыдатьОшибку - Булево - выдать ошибку, если не заполнены некоторые поля, т.е. если контрагент не настроен 
//  							полностью для обмена по МЭДО. Актуально для исходящих отправок.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
// 
// Возвращаемое значение:
//  см. МЭДОСтруктурыДанных.НовыйКонтрагент.
Функция ПоляКонтрагента(КонтрагентСсылка, ДатаСведений, ВыдатьОшибку, ДанныеОтвета) Экспорт
	
	СтруктураКонтрагент = МЭДОСтруктурыДанных.НовыйКонтрагент();
	
	Настройки = РегистрыСведений.НастройкиКонтрагентовМЭДО.НастройкиКонтрагента(КонтрагентСсылка, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат СтруктураКонтрагент;
	КонецЕсли;
	
	СтруктураКонтрагент.Идентификатор		= МЭДОПереопределяемый.ИдентификаторВнешнегоОбъекта(
		КонтрагентСсылка, Обозначение_ВнешнийКонтрагент());
	СтруктураКонтрагент.Наименование		= МЭДОПереопределяемый.НаименованиеЮрлицаНаДату(КонтрагентСсылка, ДатаСведений);
	СтруктураКонтрагент.АдресМЭДО			= Настройки.АдресМЭДО;
	СтруктураКонтрагент.ВерсияМЭДО			= Настройки.ВерсияФорматаМЭДО;
	СтруктураКонтрагент.КонтрагентСсылка	= КонтрагентСсылка;
	
	Если ВыдатьОшибку Тогда
		ТекстОшибкиПодробно = "";
		Если Не ЗначениеЗаполнено(СтруктураКонтрагент.АдресМЭДО) Тогда
			ТекстОшибкиПодробно = ТекстОшибкиПодробно + СтрШаблон(
				НСтр("ru = 'У контрагента ""%1"" не указан адрес МЭДО.'"), КонтрагентСсылка) + Символы.ПС;
		КонецЕсли;
		
		Если Не ЗначениеЗаполнено(СтруктураКонтрагент.Идентификатор) Тогда
			Если ТекстОшибкиПодробно <> "" Тогда
				ТекстОшибкиПодробно = ТекстОшибкиПодробно + Символы.ПС;
			КонецЕсли;
			ТекстОшибкиПодробно = ТекстОшибкиПодробно + СтрШаблон(
				НСтр("ru = 'У контрагента ""%1"" не указан идентификатор МЭДО'"), КонтрагентСсылка);
		КонецЕсли;
		
		Если Не ЗначениеЗаполнено(СтруктураКонтрагент.ВерсияМЭДО) Тогда
			Если ТекстОшибкиПодробно <> "" Тогда
				ТекстОшибкиПодробно = ТекстОшибкиПодробно + Символы.ПС;
			КонецЕсли;
			ТекстОшибкиПодробно = ТекстОшибкиПодробно + СтрШаблон(
				НСтр("ru = 'У контрагента ""%1"" в настройках не указана версия формата МЭДО'"), КонтрагентСсылка);
		КонецЕсли;
		
		Если ТекстОшибкиПодробно <> "" Тогда
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				КонтрагентСсылка,
				Текст_ОшибкаВКонтрагенте(),
				ТекстОшибкиПодробно,
				ДанныеОтвета);
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураКонтрагент;
	
КонецФункции

#Область ОперацииСКаталогами

// Проверить существует ли каталог.
// 
// Параметры:
//  Путь - Строка - Путь
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
// 
// Возвращаемое значение:
//  Булево - Истина - существует, Ложь - нет.
Функция ПроверитьСуществуетЛиКаталог(Путь, ДанныеОтвета = Неопределено) Экспорт
	
	КаталогНаДиске = Новый Файл(Путь);
	Если НЕ КаталогНаДиске.Существует() Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			Путь,
			Текст_КаталогНеСуществует(),
			СтрШаблон(НСтр("ru = 'Каталог обмена ""%1"" не существует или недоступен с сервера 1С:Предприятия.'"), Путь),
			ДанныеОтвета);
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти

// Обработчик подписки на событие. Синхронизирует данные документа МЭДО с предметом МЭДО - пометку удаления.
// 
// Параметры:
//  Источник - ОпределяемыйТип.ПредметМЭДООбъект - Источник
//  Отказ - Булево - Отказ
Процедура СинхронизироватьДанныеДокументаМЭДОПриЗаписи(Источник, Отказ) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ЗначениеЗаполнено(Источник.Ссылка) Тогда
		Возврат;
	ИначеЕсли Не ПолучитьФункциональнуюОпцию("ИспользоватьМЭДО") Тогда
		Возврат;
	КонецЕсли;
	
	Результат = Документы.ДанныеДокументаМЭДО.РезультатЗапросаДанныеДокументаМЭДО(
		Источник.Ссылка, "Ссылка, ПометкаУдаления", Ложь);
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
		
		Если МЭДОПереопределяемый.ЭтоВходящийДокумент(Источник) Или МЭДОПереопределяемый.ЭтоИсходящийДокумент(Источник) Тогда
			Если Выборка.ПометкаУдаления <> Источник.ПометкаУдаления Тогда
				ДанныеМЭДООбъект = Выборка.Ссылка.ПолучитьОбъект();
				ДанныеМЭДООбъект.УстановитьПометкуУдаления(Источник.ПометкаУдаления);
			КонецЕсли;
		Иначе
			// В МЭДО участвуют только входящие и исходящие документы, если каким-то образом начала все-таки был создан
			// вспомогательных документ, но потом например изменили вид документа-владельца, теперь вспомогательный
			// не нужен:
			Если Выборка.ПометкаУдаления <> Истина Тогда
				ДанныеМЭДООбъект = Выборка.Ссылка.ПолучитьОбъект();
				ДанныеМЭДООбъект.УстановитьПометкуУдаления(Истина);
			КонецЕсли;
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Если Не ВнешнееСоединение Тогда

// Читает и обрабатывает Электронное Сообщение Документооборота, полученное через МЭДО.
// 
// Параметры:
//  ФайлZip - Файл - ссылается на ЭСД. Исходный zip-ФайлZip с сообщением ЭСД
//  Настройки - См. РегистрыСведений.НастройкиОрганизацийМЭДО.НовыйНастройки
//  ТипКонтента - Строка - принимает значения "Транспортный контейнер" или "Уведомление".
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет. 
// 
Процедура ОбработатьВходящееЭСД(ФайлZip, Настройки, ТипКонтента, ДанныеОтвета)
	
	УстановитьПривилегированныйРежим(Истина);
	
	Попытка
		ВременныйКаталог = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ПолучитьИмяВременногоФайла());
		АрхивЭСД = Новый ЧтениеZipФайла(ФайлZip.ПолноеИмя);
		АрхивЭСД.ИзвлечьВсе(ВременныйКаталог, РежимВосстановленияПутейФайловZIP.Восстанавливать);
		АрхивЭСД.Закрыть();
	Исключение
		ТекстОшибкиПодробно = СтрШаблон(
				НСтр("ru = 'Ошибка при распаковке архива %1 - %2'"),
				ФайлZip.ПолноеИмя, ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				ФайлZip.ПолноеИмя,
				Текст_ОшибкаЧтенияXml(),
				ТекстОшибкиПодробно,
				ДанныеОтвета);
		Возврат;
	КонецПопытки;
	
	
	АдресМЭДООтправителя = "";
	Попытка
		// Файл конверта - обычно envelope.ini или envelope.ltr:
		ФайлыКонверта = НайтиФайлы(ВременныйКаталог, ПреобразованнаяМаскаФайловLinux("envelope*"), Истина);
		Если ФайлыКонверта.Количество() = 0 Тогда
			ФайлыКонверта = НайтиФайлы(ВременныйКаталог, ПреобразованнаяМаскаФайловLinux("*.ini"), Истина);
		КонецЕсли;
		Если ФайлыКонверта.Количество() = 0 Тогда
			ФайлыКонверта = НайтиФайлы(ВременныйКаталог, ПреобразованнаяМаскаФайловLinux("*.ltr"), Истина);
		КонецЕсли;
		Если ФайлыКонверта.Количество() <> 0 Тогда
			Для Каждого НайденныйФайл Из ФайлыКонверта Цикл
				Чтение = Новый ЧтениеТекста(НайденныйФайл.ПолноеИмя, КодировкаТекста.ANSI);
				Пока Истина Цикл
					СтрокаФайла = Чтение.ПрочитатьСтроку();
					Если СтрокаФайла = Неопределено Тогда
						Прервать;
					КонецЕсли;
					
					// Адрес в секции файла [АДРЕСАТЫ]
					Если ВРег(СтрокаФайла) = "[АДРЕСАТЫ]" Тогда
						СтрокаСАдресом = Чтение.ПрочитатьСтроку();
						Если СтрокаСАдресом <> Неопределено Тогда
							// Строка имеет вид: "0=АдресМэдо"
							Части = СтрРазделить(СтрокаСАдресом, "=", Ложь);
							Если Части.Количество() = 2 Тогда
								АдресМЭДООтправителя = Части[1];
								Прервать;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
				Чтение.Закрыть();
				
				Прервать; // Файл конверта должен быть только один, остальное игнорируем.
			КонецЦикла;
		Иначе
			// Ненормальная ситуация, но считаем допустимой, вся информация в других файлах, здесь нужен только
			// адрес МЭДО отправителя, который при получении сообщений от контрагента можно задать первый раз и вручную.
		КонецЕсли;
	Исключение
		ТекстОшибкиПодробно = СтрШаблон(
				НСтр("ru = 'Ошибка при разборе файла-конверта из сообщения ЭСД. %1 - %2'"),
				ФайлZip.ПолноеИмя, ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				ФайлZip.ПолноеИмя,
				Текст_ОшибкаЧтенияXml(),
				ТекстОшибкиПодробно,
				ДанныеОтвета);
		УдалитьФайлы(ВременныйКаталог);
		Возврат;
	КонецПопытки;
	
	
	ФайлыЭСД = НайтиФайлы(ВременныйКаталог, ПреобразованнаяМаскаФайловLinux("*.xml"), Истина);
	
	Если ФайлыЭСД.Количество() = 0 Тогда
		
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			ФайлZip.ПолноеИмя,
			Текст_ОшибкаЧтенияXml(), 
			СтрШаблон(НСтр("ru = 'В файле ЭСД %1 не обнаружено файлов .xml'"), ФайлZip.Имя),
			ДанныеОтвета);
	Иначе
		
		Попытка
			// В сообщении может быть и архив document.edc.zip
			// и папка с распакованным содержимым того же самого document.edc
			// В данный момент нужно не перепутать и прочесть именно ЭСД, а не xml из document.edc:
			ФайлСообщения = Неопределено;
			ВерсияМЭДО = Неопределено;
			Для Каждого НайденныйФайл Из ФайлыЭСД Цикл
				ВерсияМЭДО = ПрочитатьАтрибутИзXml(НайденныйФайл.ПолноеИмя, "communication", "version", ДанныеОтвета);
				Если ЗначениеЗаполнено(ВерсияМЭДО) Тогда
					ФайлСообщения = НайденныйФайл;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			Если Не ДанныеОтвета.Успех Тогда
				УдалитьФайлы(ВременныйКаталог);
				Возврат;
			КонецЕсли;
			
			ПакетXDTO = ПакетXDTOСообщенияПоВерсииМЭДО(ВерсияМЭДО);
			ТипCommunication = ПакетXDTO.КорневыеСвойства.Получить("communication").Тип;
			communication = ПрочитатьXMLФабрикой(ФайлСообщения.ПолноеИмя, ТипCommunication, ДанныеОтвета);
			Если Не ДанныеОтвета.Успех Тогда
				УдалитьФайлы(ВременныйКаталог);
				Возврат;
			КонецЕсли;
			
			type = communication.header.type;
			Если Не (type = "Транспортный контейнер" Или type = "Документ"
				Или type = "Уведомление" Или type = "Квитанция") Тогда
				ЗаписьВЖурналСобытий(
					Перечисления.УровниСобытийМЭДО.Ошибка,
					ФайлZip.ПолноеИмя,
					Текст_ОшибкаЧтенияXml(), 
					СтрШаблон(НСтр("ru = 'Пропущено сообщение неизвестного типа ""%1""'"), type),
					ДанныеОтвета);
				УдалитьФайлы(ВременныйКаталог);
				Возврат;
			КонецЕсли;
			Если ТипКонтента <> Неопределено И СтрНайти(ТипКонтента, type) = 0 Тогда
				// ТипКонтента правильный, но в данный момент загружается другой, просто пропускаем.
				ДанныеОтвета.СообщениеОбОшибке = "ДругойВерныйТипСообщения";
				УдалитьФайлы(ВременныйКаталог);
				Возврат;
			КонецЕсли;
			
			Если type = "Транспортный контейнер" Тогда; // Версия МЭДО 2.7, 2.7.1
				ОбработатьВходящийТранспортныйКонтейнер(
					ВременныйКаталог, Настройки, АдресМЭДООтправителя, communication, ДанныеОтвета);
			ИначеЕсли type = "Документ" Тогда // Версия МЭДО 2.2 или 2.5
				ОбработатьВходящийДокумент22_25(
					ВременныйКаталог, Настройки, АдресМЭДООтправителя, communication, ДанныеОтвета);
			ИначеЕсли type = "Уведомление" Тогда
				ДвоичныеДанные = Новый ДвоичныеДанные(ФайлСообщения.ПолноеИмя);
				ОбработатьВходящееУведомление(ВременныйКаталог, communication, ДвоичныеДанные, ДанныеОтвета);
			ИначеЕсли type = "Квитанция" Тогда
				ДвоичныеДанные = Новый ДвоичныеДанные(ФайлСообщения.ПолноеИмя);
				ОбработатьВходящуюКвитанцию(ВременныйКаталог, communication, ДвоичныеДанные, ДанныеОтвета);
			Иначе
				ЗаписьВЖурналСобытий(
					Перечисления.УровниСобытийМЭДО.Ошибка,
					ФайлZip.ПолноеИмя,
					Текст_ОшибкаЧтенияXml(), 
					СтрШаблон(НСтр("ru = 'Пропущено сообщение неизвестного типа ""%1""'"), type),
					ДанныеОтвета);
			КонецЕсли;
			
			УдалитьФайлы(ВременныйКаталог);
		Исключение
			ТекстОшибкиПодробно = СтрШаблон(
				НСтр("ru = 'Ошибка при загрузке файла %1 - %2'"),
				ФайлZip.ПолноеИмя, ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				ФайлZip.ПолноеИмя,
				Текст_ОшибкаЧтенияXml(),
				ТекстОшибкиПодробно,
				ДанныеОтвета);
		КонецПопытки;
		
	КонецЕсли;
	
КонецПроцедуры

#Область ВходящиеДокументы

// Читает и обрабатывает Электронное Сообщение Документооборота, полученное через МЭДО,
// с документом по формату 2.2 и 2.5.
// 
// Параметры:
//  ВременныйКаталог - Строка - путь к временному каталогу, содержащему документ.
//  Настройки - См. РегистрыСведений.НастройкиОрганизацийМЭДО.НовыйНастройки
//  АдресМэдоОтправителя - Строка - Адрес контрагента-отправителя в система МЭДО, записанный в файле-"конверте".
//  communication - ОбъектXDTO - содержит данные ЭСД.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
// 
Процедура ОбработатьВходящийДокумент22_25(
	ВременныйКаталог, Настройки, АдресМэдоОтправителя, communication, ДанныеОтвета)
	
	ВерсияМЭДО = communication.version;
	
	Если ВерсияМЭДО <> "2.2" И ВерсияМЭДО <> "2.5" Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Предупреждение, 
			ВременныйКаталог,
			НСтр("ru = 'Не поддерживаемая версия для типа сообщения ""Документ"". Но все-таки будет произведена попытка прочитать сообщение'"),
			Текст_ВерсияНеПоддерживается(ВерсияМЭДО), 
			ДанныеОтвета);
	КонецЕсли;
	
	ИдентификаторСообщения = communication.header.uid;
	
	// Если ИдентификаторСообщения был обработан ранее - считаем что сообщение пришло повторно по ошибке,
	// но все же загрузим его, с предупреждением.
	Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Состояния.ИдентификаторСообщения КАК ИдентификаторСообщения
		|ИЗ
		|	РегистрСведений.СостоянияДокументовМЭДО.СрезПоследних( , 
		|		Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Входящее)) КАК Состояния
		|ГДЕ
		|	ИдентификаторСообщения = &ИдентификаторСообщения");
	Запрос.УстановитьПараметр("ИдентификаторСообщения", ИдентификаторСообщения);
	РезультатЗапроса = Запрос.Выполнить();
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'ЭСД %1 было обработано ранее, согласно регистру ""Состояния документов МЭДО"".
			|Документ будет перезаписан заново'"), ИдентификаторСообщения);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Предупреждение,
			СтрШаблон(НСтр("ru = 'ЭСД %1  Файл %2'"), ИдентификаторСообщения, ВременныйКаталог),
			НСтр("ru = 'Сообщение уже обработано, загрузка повторно'"), ТекстОшибкиПодробно, ДанныеОтвета);
	КонецЕсли;
	
	
	document = СвойствоXDTOЕслиЕсть(communication, "document", Неопределено);
	Если document = Неопределено Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, 
			ВременныйКаталог,
			НСтр("ru = 'Ошибка во входящем сообщении'"),
			НСтр("ru = 'Для формата 2.2, 2.5 данные о документе берутся из сообщения, а в сообщении не найдено секции ""communication/document""'"),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	
	ДанныеДокумента = МЭДОСтруктурыДанных.НовыйДанныеВходящегоДокументаДляСоздания();
	
	ЗаполнитьЗначенияСвойств(ДанныеДокумента.НастройкиОрганизации, Настройки);
	ДанныеДокумента.ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.ЗначениеПоСтроковомуЗначению(ВерсияМЭДО);
	Если Не ЗначениеЗаполнено(ДанныеДокумента.ВерсияМЭДО) Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, 
			ВременныйКаталог,
			НСтр("ru = 'Ошибка во входящем сообщении'"),
			СтрШаблон(НСтр("ru = 'Не поддерживается версия МЭДО из входящего сообщения: %1'"), ВерсияМЭДО),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	ДанныеДокумента.ИдентификаторДокумента = document.uid;
	ДанныеДокумента.ИдентификаторСообщения = ИдентификаторСообщения;
	ДанныеДокумента.Заголовок = СвойствоXDTOЕслиЕсть(document, "annotation", "");
	ДанныеДокумента.ИсходящаяДата = ЗначениеВДату(СвойствоXDTOЕслиЕсть(document.num, "date", '00010101'));
	ДанныеДокумента.ИсходящийНомер = document.num.number;
	ДанныеДокумента.Содержание = СвойствоXDTOЕслиЕсть(document, "comment", "");
	
	ДанныеДокумента.Организация.Наименование = Настройки.НаименованиеМЭДО;
	ДанныеДокумента.Организация.ОрганизацияСсылка = Настройки.Организация;
	ДанныеДокумента.Организация.Идентификатор = Настройки.ИдентификаторМЭДО;
	ДанныеДокумента.Организация.АдресМЭДО = Настройки.АдресМЭДО;
	
	
	ПолученУспешно = Ложь;
	НачатьТранзакцию();
	Попытка
		КонтрагентСсылка = МЭДОПереопределяемый.НайтиСоздатьКонтрагента(
			communication.header.source.organization,
			communication.header.source.uid,
			ДанныеДокумента.ИсходящаяДата,
			Ложь);
		Если Не ЗначениеЗаполнено(КонтрагентСсылка) Тогда
			ВызватьИсключение Текст_НеУдалосьНайтиСоздатьКонтрагента(
				communication.header.source.organization, communication.header.source.uid);
		КонецЕсли;
		НастройкиКонтрагента = Новый Структура();
		НастройкиКонтрагента.Вставить("ВерсияФорматаМЭДО", ДанныеДокумента.ВерсияМЭДО);
		НастройкиКонтрагента.Вставить("АдресМЭДО", АдресМэдоОтправителя);
		РегистрыСведений.НастройкиКонтрагентовМЭДО.ОбновитьНастройки(
			КонтрагентСсылка, НастройкиКонтрагента);
		ПоляКонтрагента = ПоляКонтрагента(
			КонтрагентСсылка, ДанныеДокумента.ИсходящаяДата, Истина, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(ДанныеДокумента.Отправитель.Контрагент, ПоляКонтрагента);
		
		Если document.signatories.signatory.Количество() <> 0 Тогда
			Если document.signatories.signatory[0].Установлено("person") Тогда
				НаименованиеПодписавшего = communication.document.signatories.signatory[0].person.__content;
				ИдентификаторПодписавшего = 
					СвойствоXDTOЕслиЕсть(document.signatories.signatory[0].person, "id", "");
				Если ЗначениеЗаполнено(НаименованиеПодписавшего) Тогда
					КонтактноеЛицоСсылка = МЭДОПереопределяемый.НайтиСоздатьКонтактноеЛицо(
						КонтрагентСсылка,
						НаименованиеПодписавшего,
						ИдентификаторПодписавшего,
						ДанныеДокумента.ИсходящаяДата);
					ПоляКЛ = МЭДОПереопределяемый.ПоляКонтактногоЛица(КонтактноеЛицоСсылка, ДанныеДокумента.ИсходящаяДата);
					ЗаполнитьЗначенияСвойств(ДанныеДокумента.Подписал, ПоляКЛ);
					ЗаполнитьЗначенияСвойств(ДанныеДокумента.Отправитель.КонтактноеЛицо, ПоляКЛ);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	
		Документ = МЭДОПереопределяемый.НайтиСоздатьВходящийДокумент(ДанныеДокумента, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
		КонецЕсли;
		
		
		МЭДОПереопределяемый.УдалитьФайлыПодписиИСлужебныеФайлы(Документ);// На случай повторной загрузки.
		
		Если ЕстьСвойствоXDTO(communication, "files") Тогда
			Для Каждого file Из communication.files.file Цикл
				КомментарийФайла = СвойствоXDTOЕслиЕсть(file, "description", "");
				
				// ВременныйКаталог может быть с подкаталогами:
				ФайлВМассиве = НайтиФайлы(ВременныйКаталог, file.localName, Истина);
				Если ФайлВМассиве.Количество() = 0 Тогда
					ЗаписьВЖурналСобытий(
						Перечисления.УровниСобытийМЭДО.Ошибка,
						ВременныйКаталог,
						Текст_ФайлНеНайден(),
						Текст_ФайлНеНайденПодробно(file.localName),
						ДанныеОтвета);
					ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
				КонецЕсли;
				
				ДанныеДокумента.ГлавныйФайл = МЭДОПереопределяемый.ПрисоединитьФайл(
					Документ, file.localName, ФайлВМассиве[0].ПолноеИмя, КомментарийФайла, ДанныеОтвета);
				Если Не ДанныеОтвета.Успех Тогда
					ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		
		// Данные для вспомогательного документа "Данные документа МЭДО":
		ЗаписатьДанныеВходящегоДокументаМЭДО(Документ, ДанныеДокумента, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
		КонецЕсли;
		
		
		СоздатьИсходящуюКвитанцию(
			ИдентификаторСообщения, Документ, ДанныеДокумента.Отправитель.Контрагент.КонтрагентСсылка, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
		КонецЕсли;
		
		
		ПолученУспешно = Истина;
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		
		// Пишем в журнал только если ошибка не обработана во вложенных процедурах, вложенные сами пишут в журнал.
		Если ДанныеОтвета.Успех Тогда
			ТекстОшибкиПодробно = СтрШаблон(
				"Документ %1 ID=%2
				|%3",
				ДанныеДокумента.Заголовок,
				ДанныеДокумента.ИдентификаторДокумента,
				ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				ДанныеДокумента.ИдентификаторДокумента,
				Текст_ОшибкаЧтенияXml(),
				ТекстОшибкиПодробно,
				ДанныеОтвета);
		КонецЕсли;
	КонецПопытки;
	
	Если ПолученУспешно Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Информация,
			Документ,
			Текст_ОбъектПолученУспешно(),
			Текст_ОбъектПолученУспешно(),
			ДанныеОтвета);
	КонецЕсли;
	
КонецПроцедуры

// Функция - Читает и обрабатывает Электронное сообщение документооборота, полученное через МЭДО,
// в составе транспортного контейнера по формату 2.7, 2.7.1.
// 
// Параметры:
//  ВременныйКаталог - Строка - путь к временному каталогу, содержащему communication.
//  Настройки - См. РегистрыСведений.НастройкиОрганизацийМЭДО.НовыйНастройки
//  АдресМЭДООтправителя - Строка - Адрес контрагента-отправителя в система МЭДО, записанный в файле-"конверте".
//  communication - ОбъектXDTO - содержит данные сообщения ЭСД.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
// 
Процедура ОбработатьВходящийТранспортныйКонтейнер(
	ВременныйКаталог, Настройки, АдресМЭДООтправителя, communication, ДанныеОтвета)
	
	ВерсияМЭДО = communication.version;
	
	Если ВерсияМЭДО <> "2.7" И ВерсияМЭДО <> "2.7.1" Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			ВременныйКаталог,
			НСтр("ru = 'Не поддерживаемая версия'"),
			Текст_ВерсияНеПоддерживается(ВерсияМЭДО),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	ДанныеДокумента = МЭДОСтруктурыДанных.НовыйДанныеВходящегоДокументаДляСоздания();
	ОбщиеПоляУведомленияОтказа = Неопределено; ОтказВРегистрации = Неопределено;
	ПолученУспешно = Ложь;
	НачатьТранзакцию();
	Попытка
		ЗаполнитьЗначенияСвойств(ДанныеДокумента.НастройкиОрганизации, Настройки);
		ДанныеДокумента.ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.ЗначениеПоСтроковомуЗначению(ВерсияМЭДО);
		Если Не ЗначениеЗаполнено(ДанныеДокумента.ВерсияМЭДО) Тогда
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка, 
				ВременныйКаталог,
				НСтр("ru = 'Ошибка во входящем сообщении'"),
				СтрШаблон(НСтр("ru = 'Не поддерживается версия МЭДО из входящего сообщения: %1'"), ВерсияМЭДО),
				ДанныеОтвета);
			ВызватьИсключение Текст_ВерсияНеПоддерживается(ВерсияМЭДО);
		КонецЕсли;
		
		
		// Контрагент:
		ДатаСозданияСообщения = ЗначениеВДату(СвойствоXDTOЕслиЕсть(communication.header , "created", '00010101'));
		КонтрагентСсылка = МЭДОПереопределяемый.НайтиСоздатьКонтрагента(
			communication.header.source.organization,
			communication.header.source.uid,
			ДатаСозданияСообщения,
			Ложь);
		Если Не ЗначениеЗаполнено(КонтрагентСсылка) Тогда
			ВызватьИсключение Текст_НеУдалосьНайтиСоздатьКонтрагента(
				communication.header.source.organization, communication.header.source.uid);
		КонецЕсли;
		НастройкиКонтрагента = Новый Структура();
		НастройкиКонтрагента.Вставить("ВерсияФорматаМЭДО", ДанныеДокумента.ВерсияМЭДО);
		НастройкиКонтрагента.Вставить("АдресМЭДО", АдресМЭДООтправителя);
		РегистрыСведений.НастройкиКонтрагентовМЭДО.ОбновитьНастройки(
			КонтрагентСсылка, НастройкиКонтрагента);
		ПоляКонтрагента = ПоляКонтрагента(
			КонтрагентСсылка, ДатаСозданияСообщения, Истина, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(ДанныеДокумента.Отправитель.Контрагент, ПоляКонтрагента);
		
		communication_container = ЗначениеВМассивеXDTO(communication.container);
		
		ИмяФайлаПаспорта = communication_container[0].body; // строка вида "container.edc.zip"
		ZipФайлВМассиве = НайтиФайлы(ВременныйКаталог, ИмяФайлаПаспорта, Истина);
		Если ZipФайлВМассиве.Количество() = 0 Тогда
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				ВременныйКаталог,
				СтрШаблон(НСтр("ru = 'Не удалось найти в контейнере файл паспорта документа %1'"), ИмяФайлаПаспорта),
				НСтр("ru = 'Файл не найден'"),
				ДанныеОтвета);
			Возврат;
		КонецЕсли;
		ПутьКZipФайлу = ZipФайлВМассиве[0].ПолноеИмя;
		
		ТранспортныйКонтейнер = Новый ЧтениеZipФайла(ПутьКZipФайлу);
		ВременныйКаталогКонтейнера = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(
			ВременныйКаталог + Новый УникальныйИдентификатор());
		ТранспортныйКонтейнер.ИзвлечьВсе(ВременныйКаталогКонтейнера, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
		ТранспортныйКонтейнер.Закрыть();
		ИмяФайлаКонтейнера = ВременныйКаталогКонтейнера + ИмяФайлаPassportXml();
		
		ДанныеДокумента.ИдентификаторСообщения = communication.header.uid;
		ПакетXDTO = ПакетXDTOКонтейнераПоВерсииМЭДО(ДанныеДокумента.ВерсияМЭДО); 
		ТипContainer = ПакетXDTO.КорневыеСвойства.Получить("container").Тип;
		container = ПрочитатьXMLФабрикой(ИмяФайлаКонтейнера, ТипContainer, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			// XML невалидный с точки зрения схемы (ошибка будет в журнале событий), но если удастся достать из файла 
			// нужные данные, то можно отправить уведомление отправителю:
			ДанныеДокумента.ИдентификаторДокумента = ПрочитатьАтрибутИзXml(
				ИмяФайлаКонтейнера, "container", "uid", ДанныеОтвета);
			Если ЗначениеЗаполнено(ДанныеДокумента.ИдентификаторДокумента) Тогда
				ТекстОшибкиПодробно = СтрШаблон(
					НСтр("ru = '%1: Файл %2 не проходит валидацию по xsd-схеме'"),
					Текст_Автоуведомление(), ИмяФайлаPassportXml());
				ОбщиеПоляУведомленияОтказа = МЭДОСтруктурыДанных.НовыйОбщиеПоляУведомления(
					Неопределено,
					Настройки.Организация,
					КонтрагентСсылка,
					ТекстОшибкиПодробно,
					ДанныеДокумента.ИдентификаторДокумента,
					ДанныеДокумента.ИдентификаторСообщения);
				ОбщиеПоляУведомленияОтказа.ВерсияМЭДО = ПоляКонтрагента.ВерсияМЭДО;
				ОтказВРегистрации = ОтказВРегистрацииЕслиНеВалидныйФайл(ПоляКонтрагента.ВерсияМЭДО, КонтрагентСсылка);
				ВызватьИсключение Текст_ОшибкаЧтенияXml();
			Иначе
				ВызватьИсключение Текст_ОшибкаЧтенияXml();
			КонецЕсли;
		КонецЕсли;
		ДанныеДокумента.ИдентификаторДокумента = container.uid;
		
		ВерсияПаспорта = container.version;
		Если ВерсияПаспорта <> ВерсияПаспортаПоВерсииМЭДО(ВерсияМЭДО) Тогда
			ТекстОшибкиПодробно = СтрШаблон(НСтр(
				"ru = 'Версия транспортного контейнера %1 для версии МЭДО %2 не поддерживается.'"), 
				ВерсияПаспорта, ВерсияМЭДО);
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка, ИмяФайлаКонтейнера,
				НСтр("ru = 'Не поддерживаемая версия'"), ТекстОшибкиПодробно, ДанныеОтвета);
			
			ОбщиеПоляУведомленияОтказа = МЭДОСтруктурыДанных.НовыйОбщиеПоляУведомления(
				Неопределено,
				Настройки.Организация,
				КонтрагентСсылка,
				СтрШаблон("%1: %2", Текст_Автоуведомление(), ТекстОшибкиПодробно),
				ДанныеДокумента.ИдентификаторДокумента,
				ДанныеДокумента.ИдентификаторСообщения);
			ОбщиеПоляУведомленияОтказа.ВерсияМЭДО = ПоляКонтрагента.ВерсияМЭДО;
			ОтказВРегистрации = ОтказВРегистрацииЕслиНеВалидныйФайл(ПоляКонтрагента.ВерсияМЭДО, КонтрагентСсылка);
			ВызватьИсключение ТекстОшибкиПодробно;
		КонецЕсли;
		
		// Если ЭСД уже было обработано ранее - считаем что нужно обработать заново и перезаписать документ
		Запрос = Новый Запрос( 
			"ВЫБРАТЬ ПЕРВЫЕ 1
			|	Состояния.ИдентификаторСообщения КАК ИдентификаторСообщения
			|ИЗ
			|	РегистрСведений.СостоянияДокументовМЭДО.СрезПоследних( , 
			|		Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Входящее)) КАК Состояния
			|ГДЕ
			|	ИдентификаторСообщения = &ИдентификаторСообщения");
		Запрос.УстановитьПараметр("ИдентификаторСообщения", ДанныеДокумента.ИдентификаторСообщения);
		РезультатЗапроса = Запрос.Выполнить();
		Если НЕ РезультатЗапроса.Пустой() Тогда
			ТекстОшибкиПодробно = СтрШаблон(
				НСтр("ru = 'ЭСД %1 было обработано ранее, согласно регистру ""Состояния документов МЭДО"".
				|Документ будет перезаписан заново'"),
				ДанныеДокумента.ИдентификаторСообщения);
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Предупреждение,
				СтрШаблон(НСтр("ru = 'ЭСД %1  Файл %2'"), ДанныеДокумента.ИдентификаторСообщения, ПутьКZipФайлу),
				НСтр("ru = 'Сообщение уже обработано, загрузка повторно'"), ТекстОшибкиПодробно, ДанныеОтвета);
		КонецЕсли;
		
		// Гриф доступа:
		Если ЕстьСвойствоXDTO(container.requisites, "classification")
			И ЕстьСвойствоXDTO(container.requisites.classification, "id") Тогда
			КодГрифаДоступа = СокрЛП(container.requisites.classification.id);
			ДанныеДокумента.ГрифДоступа = ГрифДоступаПоКоду(КодГрифаДоступа, Настройки);
		КонецЕсли;
		Если ДанныеДокумента.ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
			Если Не ЗначениеЗаполнено(КодГрифаДоступа) Тогда
				ТекстОшибкиПодробно =
					НСтр("ru = 'Для формата МЭДО версии 2.7.1 должен быть обязательно указан гриф доступа (поле classification)'");
				ЗаписьВЖурналСобытий(
					Перечисления.УровниСобытийМЭДО.Ошибка,
					СтрШаблон(НСтр("ru = 'ЭСД %1  Файл %2'"), ДанныеДокумента.ИдентификаторСообщения, ПутьКZipФайлу),
					НСтр("ru = 'Ошибка получения грифа доступа'"), ТекстОшибкиПодробно, ДанныеОтвета);
				
				ОбщиеПоляУведомленияОтказа = МЭДОСтруктурыДанных.НовыйОбщиеПоляУведомления(
					Неопределено,
					Настройки.Организация,
					КонтрагентСсылка,
					СтрШаблон("%1: %2", Текст_Автоуведомление(), ТекстОшибкиПодробно),
					ДанныеДокумента.ИдентификаторДокумента,
					ДанныеДокумента.ИдентификаторСообщения);
				ОбщиеПоляУведомленияОтказа.ВерсияМЭДО = ПоляКонтрагента.ВерсияМЭДО;
				ОтказВРегистрации = ОтказВРегистрацииЕслиНеВалидныйФайл(ПоляКонтрагента.ВерсияМЭДО, КонтрагентСсылка);
				ВызватьИсключение ТекстОшибкиПодробно;
			ИначеЕсли Не ЗначениеЗаполнено(ДанныеДокумента.ГрифДоступа) Тогда
				ТекстОшибкиПодробно = СтрШаблон(
					НСтр("ru = 'Для формата МЭДО версии 2.7.1 должен быть обязательно указан гриф доступа, его не удалось определить по коду %1 из контейнера'"),
					КодГрифаДоступа);
				ЗаписьВЖурналСобытий(
					Перечисления.УровниСобытийМЭДО.Ошибка,
					СтрШаблон(НСтр("ru = 'ЭСД %1  Файл %2'"), ДанныеДокумента.ИдентификаторСообщения, ПутьКZipФайлу),
					НСтр("ru = 'Ошибка получения грифа доступа'"), ТекстОшибкиПодробно, ДанныеОтвета);
				// (Ошибка может быть как на нашей стороне, так и при неверных данных со стороны отправителя -
				// например код передали, но он некорректный. Уведомление делать не надо.)
				ВызватьИсключение ТекстОшибкиПодробно;
			КонецЕсли;
		КонецЕсли;
		
		ДанныеДокумента.Заголовок = container.requisites.annotation;
		
		author = ЗначениеВМассивеXDTO(container.authors.author);
		ДанныеДокумента.ИсходящаяДата = ЗначениеВДату(author[0].registration.date);
		ДанныеДокумента.ИсходящийНомер = author[0].registration.number;
		
		ДанныеДокумента.Организация.Наименование = Настройки.НаименованиеМЭДО;
		ДанныеДокумента.Организация.ОрганизацияСсылка = Настройки.Организация;
		ДанныеДокумента.Организация.Идентификатор = Настройки.ИдентификаторМЭДО;
		ДанныеДокумента.Организация.АдресМЭДО = Настройки.АдресМЭДО;
		
		document = container.document;
		
		ДанныеДокумента.Содержание = СвойствоXDTOЕслиЕсть(document, "description", "");
		
		// Подписал от отправителя
		sign = ЗначениеВМассивеXDTO(author[0].sign);
		// К сожалению, здесь в sign[0].person нет id, только name, поэтому сопоставление только по
		// наименованию и контрагенту:
		КонтактноеЛицоСсылка = МЭДОПереопределяемый.НайтиСоздатьКонтактноеЛицо(
			КонтрагентСсылка, sign[0].person.name, "", ДатаСозданияСообщения);
		ПоляКЛ = МЭДОПереопределяемый.ПоляКонтактногоЛица(КонтактноеЛицоСсылка, ДатаСозданияСообщения);
		ЗаполнитьЗначенияСвойств(ДанныеДокумента.Подписал, ПоляКЛ);
		ЗаполнитьЗначенияСвойств(ДанныеДокумента.Отправитель.КонтактноеЛицо, ПоляКЛ);
		
		// Количества листов и приложений:
		ДанныеДокумента.КоличествоЛистов = СвойствоXDTOЕслиЕсть(document, "pagesQuantity", 0);
		ДанныеДокумента.КоличествоПриложений = 0;
		attachment = Новый Массив();
		Если ЕстьСвойствоXDTO(container, "attachments") И ЕстьСвойствоXDTO(container.attachments, "attachment") Тогда
			attachment = ЗначениеВМассивеXDTO(container.attachments.attachment);
			ДанныеДокумента.КоличествоПриложений = attachment.Количество();
		КонецЕсли;
		
		// Получатель/и
		ДанныеДокумента.Адресаты = Новый Массив();
		Если ЕстьСвойствоXDTO(container, "addressees") И ЕстьСвойствоXDTO(container.addressees, "addressee") Тогда
			addressee = ЗначениеВМассивеXDTO(container.addressees.addressee);
			Для Каждого Адресат Из addressee Цикл
				СтруктураАдресата = МЭДОСтруктурыДанных.НовыйСтруктураАдресата();
				
				ЕстьХотьОдно = Ложь;
				Если ЕстьСвойствоXDTO(Адресат, "organization") 
					И ЕстьСвойствоXDTO(Адресат.organization, "title") Тогда
					СтруктураАдресата.Организация = Адресат.organization.title;
					ЕстьХотьОдно = Истина;
				КонецЕсли;
				
				Если ЕстьСвойствоXDTO(Адресат, "department")
					И ЕстьСвойствоXDTO(Адресат.department, "__content") Тогда 
					СтруктураАдресата.Департамент = Адресат.department.__content;
					ЕстьХотьОдно = Истина;
				КонецЕсли;
				
				Если ЕстьСвойствоXDTO(Адресат, "person") Тогда
					person = ЗначениеВМассивеXDTO(Адресат.person); 
					Если person.Количество() > 0 Тогда 
						Если ЕстьСвойствоXDTO(person[0], "name") Тогда
							СтруктураАдресата.Персона.ФИО = person[0].name;
						КонецЕсли;
						Если ЕстьСвойствоXDTO(person[0], "id") Тогда
							СтруктураАдресата.Персона.Идентификатор = person[0].id;
						КонецЕсли;
						Если ЕстьСвойствоXDTO(person[0], "post") Тогда
							СтруктураАдресата.Персона.Должность.Наименование = person[0].post;
						КонецЕсли;
						Если ЕстьСвойствоXDTO(person[0], "phone") Тогда
							СтруктураАдресата.Персона.Телефон = person[0].phone;
						КонецЕсли;
						Если ЕстьСвойствоXDTO(person[0], "email") Тогда
							СтруктураАдресата.Персона.ЭлектроннаяПочта = person[0].email;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				
				Если ЕстьХотьОдно Тогда
					ДанныеДокумента.Адресаты.Добавить(СтруктураАдресата);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		// Непосредственно создание документа по всем выше полученным данным:
		Документ = МЭДОПереопределяемый.НайтиСоздатьВходящийДокумент(ДанныеДокумента, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			// Если документ уже зарегистрирован, уведомление будет отправлено, прошла проверка при создании документа.
			// См. МЭДОПереопределяемый.НайтиСоздатьВходящийДокумент
			ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
		КонецЕсли;
		
		// Основной файл документа "главный файл":
		ПутьКГлавномуФайлу = ВременныйКаталогКонтейнера + document.localName;
		ОписаниеФайла = ?(ЕстьСвойствоXDTO(document, "description"), document.description, "");
		ДанныеДокумента.ГлавныйФайл = МЭДОПереопределяемый.ПрисоединитьФайл(
			Документ, document.localName, ПутьКГлавномуФайлу, ОписаниеФайла, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
		КонецЕсли;
		
		// Данные для вспомогательного документа "Данные документа МЭДО":
		КодМЭДО = "";
		ДанныеДокумента.ВидДокумента = Справочники.ВидыДокументовМЭДО.ПустаяСсылка();
		Если ЕстьСвойствоXDTO(container.requisites, "documentKind")
			И ЕстьСвойствоXDTO(container.requisites.documentKind, "id") Тогда
			КодМЭДО = container.requisites.documentKind.id;
			ДанныеДокумента.ВидДокумента = Справочники.ВидыДокументовМЭДО.НайтиВидДокумента(
				КодМЭДО, container.requisites.documentKind.__content);
		КонецЕсли;
		КодМЭДО = "";
		ДанныеДокумента.МестоСоставления = Справочники.МестаСоставленияДокументовМЭДО.ПустаяСсылка();
		Если ЕстьСвойствоXDTO(container.requisites, "documentPlace")
			И ЕстьСвойствоXDTO(container.requisites.documentPlace, "id") Тогда
			КодМЭДО = container.requisites.documentPlace.id;
			ДанныеДокумента.МестоСоставления = Справочники.МестаСоставленияДокументовМЭДО.НайтиМестоСоставления(
				КодМЭДО, container.requisites.documentPlace.__content);
		КонецЕсли;
		ЗаписатьДанныеВходящегоДокументаМЭДО(Документ, ДанныеДокумента, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
		КонецЕсли;
		
		#Область ЗагрузкаПодписейГлавногоФайлаКонтейнера
		МЭДОПереопределяемый.УдалитьФайлыПодписиИСлужебныеФайлы(Документ); // Если есть, на случай повторной загрузки.
		
		// Для визуализации:
		ДанныеОтметок = Новый Массив(); // Массив Из См. МЭДОСтруктурыДанных.НовыйДанныеОтметки
		
		ИдентификаторыПодписейУжеБыли = Новый Массив();
		Для Каждого Автор Из author Цикл
			Положение = ПоложениеИзображенияИзПаспортаКонтейнера(
				Автор.registration.registrationStamp.position);
			ПутьККартинке = ВременныйКаталогКонтейнера + Автор.registration.registrationStamp.localName;
			МЭДОПереопределяемый.ЗаписатьРегистрационныйШтамп(
				Документ,
				ДанныеДокумента.ГлавныйФайл,
				Перечисления.ОтношенияСлужебныхФайлов.РегистрационныйШтампКорреспондента,
				ПутьККартинке,
				Положение);
			
			ДанныеОтметки = МЭДОСтруктурыДанных.НовыйДанныеОтметки();
			ДанныеОтметки.ДвоичныеДанныеОтметки = Новый ДвоичныеДанные(ПутьККартинке);
			ЗаполнитьЗначенияСвойств(ДанныеОтметки.Положение, Положение);
			ДанныеОтметок.Добавить(ДанныеОтметки);
			
			sign = ЗначениеВМассивеXDTO(Автор.sign);
			Для Каждого Подпись Из sign Цикл
				Положение = ПоложениеИзображенияИзПаспортаКонтейнера(
					Подпись.documentSignature.signatureStamp.position);
				ПутьККартинке = ВременныйКаталогКонтейнера + Подпись.documentSignature.signatureStamp.localName;
				
				ДанныеОтметки = МЭДОСтруктурыДанных.НовыйДанныеОтметки();
				ДанныеОтметки.ДвоичныеДанныеОтметки = Новый ДвоичныеДанные(ПутьККартинке);
				ЗаполнитьЗначенияСвойств(ДанныеОтметки.Положение, Положение);
				ДанныеОтметок.Добавить(ДанныеОтметки);
				
				ИдентификаторПодписи = МЭДОПереопределяемый.ЗаписатьВнешнююЭП(
					Документ,
					ДанныеДокумента.ГлавныйФайл, 
					ВременныйКаталогКонтейнера + Подпись.documentSignature.localName,
					ИдентификаторыПодписейУжеБыли);
				Если Не ЗначениеЗаполнено(ИдентификаторПодписи) Тогда
					ТекстОшибкиПодробно = СтрШаблон(
						НСтр("ru = 'Не удалось получить идентификатор подписи для главного файла документа ID=%1
						|%2'"), ДанныеДокумента.ИдентификаторДокумента, ДанныеДокумента.Заголовок);
					ЗаписьВЖурналСобытий(
						Перечисления.УровниСобытийМЭДО.Ошибка, ПутьКZipФайлу,
						Текст_ОшибкаЧтенияXml(), ТекстОшибкиПодробно, ДанныеОтвета);
					ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
				КонецЕсли;
				
				МЭДОПереопределяемый.ЗаписатьОтметкуЭП(Документ, "" + ИдентификаторПодписи, ПутьККартинке, Положение);
			КонецЦикла;
		КонецЦикла;
		#КонецОбласти
		
		// Файлы-приложения к документу, если они есть, и подписи к ним:
		Для Каждого Приложение Из attachment Цикл
			ОписаниеФайла = ?(ЕстьСвойствоXDTO(Приложение, "description"), Приложение.description, "");
			
			ФайлСсылка = МЭДОПереопределяемый.ПрисоединитьФайл(
				Документ, Приложение.localName, ВременныйКаталогКонтейнера + Приложение.localName, ОписаниеФайла, ДанныеОтвета);
			Если Не ДанныеОтвета.Успех Тогда
				ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
			КонецЕсли;
			
			Если ЕстьСвойствоXDTO(Приложение, "signature") Тогда
				signature = ЗначениеВМассивеXDTO(Приложение.signature);
				Для Каждого Подпись Из signature Цикл
					МЭДОПереопределяемый.ЗаписатьВнешнююЭП(
						Документ,
						ФайлСсылка,
						ВременныйКаталогКонтейнера + Подпись.localName,
						ИдентификаторыПодписейУжеБыли);
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
		
		// Визуализация.
		МЭДОПереопределяемый.СоздатьВизуализациюЭП(
			Документ, ДанныеДокумента.ГлавныйФайл, ДанныеОтметок, ДанныеОтвета, Неопределено);
		
		СоздатьИсходящуюКвитанцию(
			ДанныеДокумента.ИдентификаторСообщения,
			Документ,
			ДанныеДокумента.Отправитель.Контрагент.КонтрагентСсылка,
			ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
		КонецЕсли;
		
		ПолученУспешно = Истина;
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		
		// Пишем в журнал только если ошибка не обработана во вложенных процедурах, вложенные сами пишут в журнал.
		Если ДанныеОтвета.Успех Тогда
			ТекстОшибкиПодробно = СтрШаблон(
				"Документ %1 ID=%2
				|%3",
				ДанныеДокумента.Заголовок,
				ДанныеДокумента.ИдентификаторДокумента,
				ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка, ПутьКZipФайлу,
				Текст_ОшибкаЧтенияXml(), ТекстОшибкиПодробно, ДанныеОтвета);
		КонецЕсли;
	КонецПопытки;

	Если ПолученУспешно Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Информация,
			Документ,
			Текст_ОбъектПолученУспешно(),
			Текст_ОбъектПолученУспешно(),
			ДанныеОтвета);
	КонецЕсли;
	
	Если ОбщиеПоляУведомленияОтказа <> Неопределено И ОтказВРегистрации <> Неопределено Тогда
		СоздатьИсходящееУведомлениеОбОтказеВРегистрации(ОбщиеПоляУведомленияОтказа, ОтказВРегистрации);
	КонецЕсли;
	
КонецПроцедуры

// Определяет гриф доступа по коду из МЭДО.
// 
// Параметры:
//  КодГрифаДоступа - Строка
//  НастройкиОрганизации - Структура - поля соответствуют ресурсам РС НастройкиОрганизацийМЭДО, в том числе:
//   * ГрифОбычнаяИнформация - СправочникСсылка.ГрифыДоступа
//   * ГрифИнформацияОграниченногоРаспространения  - СправочникСсылка.ГрифыДоступа
// 
// Возвращаемое значение:
//  Произвольный, СправочникСсылка.ГрифыДоступа - Гриф доступа по коду
Функция ГрифДоступаПоКоду(КодГрифаДоступа, НастройкиОрганизации)
	
	Если КодГрифаДоступа = "DC00000000" Тогда 
		Возврат НастройкиОрганизации.ГрифОбычнаяИнформация;
	ИначеЕсли КодГрифаДоступа = "DC00000001" Тогда
		Возврат НастройкиОрганизации.ГрифИнформацияОграниченногоРаспространения;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Функция - Создать положение изображения с путем к картинке - промежуточную структуру для наложения штампов.
//
// Параметры:
//  position - ОбъектXDTO - Часть дерева, описывающего файл, начиная от ветки position
// 
// Возвращаемое значение:
//  см. МЭДОСтруктурыДанных.НовыйПоложениеИзображения.
//
Функция ПоложениеИзображенияИзПаспортаКонтейнера(position)
	
	Положение = МЭДОСтруктурыДанных.НовыйПоложениеИзображения(
		Число(position.page),
		Число(position.topLeft.x),
		Число(position.topLeft.y),
		Число(position.dimension.w),
		Число(position.dimension.h));
	
	Возврат Положение;
	
КонецФункции

// Вспомогательный документ "Данные документа МЭДО" для хранения дополнительных данных МЭДО,
// отсутствующих в основном документе
// 
// Параметры:
//  Документ - ОпределяемыйТип.ПредметМЭДО
//  ДанныеДокумента - см. МЭДОСтруктурыДанных.НовыйДанныеВходящегоДокументаДляСоздания.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ЗаписатьДанныеВходящегоДокументаМЭДО(Документ, ДанныеДокумента, ДанныеОтвета)
	
	ДанныеОбъект = Документы.ДанныеДокументаМЭДО.ОбъектДанныхДокумента(Документ, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(
		ДанныеОбъект, ДанныеДокумента,
		"ВидДокумента, ГлавныйФайл, ГрифДоступа, ИдентификаторДокумента, МестоСоставления");
	ДанныеОбъект.Направление = Перечисления.НаправленияСообщенийМЭДО.Входящее;
	ДанныеОбъект.Организация = ДанныеДокумента.Организация.ОрганизацияСсылка;
	СтрокаТЧ = Неопределено;
	Если ДанныеОбъект.Пакеты.Количество() = 0 Тогда
		СтрокаТЧ = ДанныеОбъект.Пакеты.Добавить();
	Иначе
		СтрокаТЧ = ДанныеОбъект.Пакеты[0];
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(СтрокаТЧ, ДанныеДокумента, "ВерсияМЭДО, ИдентификаторСообщения");
	
	ДанныеОбъект.Записать();
	
КонецПроцедуры

#КонецОбласти

#КонецЕсли

#Область ВходящиеУведомленияИКвитанции

// Обрабатывает входящее сообщение, соответствующее уведомлению.
//
Процедура ОбработатьВходящееУведомление(ВременныйКаталог, communication, ДвоичныеДанныеЭСД, ДанныеОтвета)
	
	notification = communication.notification;
	
	ИдентификаторУведомления = communication.header.uid;
	ИдентификаторСообщенияДокумента = СвойствоXDTOЕслиЕсть(notification, "mid", "");
	ИдентификаторДокумента = notification.uid;
	Документ = МЭДОПереопределяемый.ДокументПоИдентификатору(ИдентификаторДокумента);


	Если Не ЗначениеЗаполнено(Документ) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Во входящем уведомлении ID=%1 по исх.сообщению %2 указан идентификатор %3,
			|но по нему не обнаружено документа в нашей ИБ...
			|Временный каталог %4'"), 
			ИдентификаторУведомления, ИдентификаторСообщенияДокумента, ИдентификаторДокумента, ВременныйКаталог);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Документ,
			Текст_ОшибкаЗагрузкиВходящегоУведомления(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	ТипУведомленияИзСообщения = notification.type;
	ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ЗначениеПоСтроковомуЗначению(ТипУведомленияИзСообщения);
	Если Не ЗначениеЗаполнено(ТипУведомления) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Во входящем уведомлении ID=%1 по исх.сообщению %2
			|не удалось разобрать тип уведомления - указано ""%3""
			|Документ %4'"), 
			ИдентификаторУведомления, ИдентификаторСообщенияДокумента, ТипУведомленияИзСообщения, Документ);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Документ,
			Текст_ОшибкаЗагрузкиВходящегоУведомления(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	ДатаУведомления = ЗначениеВДату(СвойствоXDTOЕслиЕсть(communication.header , "created", '00010101'));
	
	
	// Проверим соответствие идентификаторов данным нашей ИБ.
	СтруктураСостояния = РегистрыСведений.СостоянияДокументовМЭДО.СостояниеДокумента(
		Документ, Перечисления.СостоянияДокументовМЭДО.ДокументОтправлен, "ИдентификаторСообщения", ДатаУведомления);
	Если Не ЗначениеЗаполнено(СтруктураСостояния.ИдентификаторСообщения) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Получено входящее уведомление ID=%1 с исх.сообщением %2,
			|На документ %3, сведения об отправке которого отсутствуют в нашей ИБ.'"),
			ИдентификаторУведомления, ИдентификаторСообщенияДокумента, Документ);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Документ, 
			Текст_ОшибкаЗагрузкиВходящегоУведомления(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ИдентификаторСообщенияДокумента) Тогда
		// получим идентификатор исходящего сообщения документа по данным нашей ИБ.
		ИдентификаторСообщенияДокумента = СтруктураСостояния.ИдентификаторСообщения;
	КонецЕсли;
	
	
	Реквизиты = МЭДОПереопределяемый.ТребуемыеДанныеИсходящегоДокумента(
		Документ, "Организация, ДатаУчетаДокумента, Контрагенты", ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	КонтрагентИзУведомления = МЭДОПереопределяемый.НайтиСоздатьКонтрагента(
		communication.header.source.organization, communication.header.source.uid, ДатаУведомления, Истина);
	Если Не ЗначениеЗаполнено(КонтрагентИзУведомления) Тогда
		ТекстОшибкиПодробно = СтрШаблон(НСтр(
			"ru = 'Не удалось распознать контрагента %1, id=%2
			|во входящем уведомлении %3 - в нашей ИБ не обнаружен,
			|на исходящий документе %4,
			|идентификатор исходящего сообщения %5'"),
			communication.header.source.organization,
			communication.header.source.uid,
			ИдентификаторУведомления,
			Документ,
			ИдентификаторСообщенияДокумента);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Документ, 
			Текст_ОшибкаЗагрузкиВходящегоУведомления(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	Реквизиты.Контрагент = КонтрагентИзУведомления; // Меняем, вначале туда записан первый контрагент из документа.
	Найден = Ложь;
	Для Каждого СтруктураКонтрагент Из Реквизиты.Контрагенты Цикл
		Если СтруктураКонтрагент.Контрагент = КонтрагентИзУведомления Тогда
			Найден = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если Не Найден Тогда
		ТекстОшибкиПодробно = СтрШаблон(НСтр(
			"ru = 'Контрагент %1 из входящего уведомления %2
			|не найден в исходящем документе %3,
			|идентификатор исходящего сообщения %4'"),
			КонтрагентИзУведомления, ИдентификаторУведомления, Документ, ИдентификаторСообщенияДокумента);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Предупреждение, Документ, 
			Текст_ОшибкаЗагрузкиВходящегоУведомления(), ТекстОшибкиПодробно, ДанныеОтвета);
		// Но тем не менее - документ распознан, не будем считать это критичной ошибкой, загрузка идет дальше.
	КонецЕсли;
	
	
	// Уведомление каждый раз создается заново, т.к. может быть много уведомлений по документу
	Уведомление = Документы.УведомлениеМЭДО.СоздатьДокумент();
	Уведомление.Дата = ТекущаяДатаСеанса();
	Уведомление.ИсходящаяДата = ДатаУведомления;
	Уведомление.ТипУведомления = ТипУведомления;
	Уведомление.Направление = Перечисления.НаправленияСообщенийМЭДО.Входящее;
	Уведомление.Заполнить(Неопределено);
	Уведомление.Организация = Реквизиты.Организация;
	Уведомление.Контрагент = КонтрагентИзУведомления;
	Уведомление.Документ = Документ;
	Уведомление.ИдентификаторДокумента = НРег(ИдентификаторДокумента);
	Уведомление.ИдентификаторСообщенияДокумента = ИдентификаторСообщенияДокумента;
	Уведомление.ИдентификаторУведомления = ИдентификаторУведомления;
	Уведомление.ДанныеСообщения = Новый ХранилищеЗначения(ДвоичныеДанныеЭСД);
	Уведомление.ПометкаУдаления = Ложь;
	Уведомление.Комментарий = СвойствоXDTOЕслиЕсть(notification, "comment", "");
	
	ПолученоУспешно = Ложь;
	НачатьТранзакцию();
	Попытка
		
		Если ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОПостановкеНаКонтроль
			И ЕстьСвойствоXDTO(notification, "documentSent") Тогда
			
			documentSent = notification.documentSent;
			Уведомление.ПостановкаНаКонтроль.Очистить();
			Уведомление.ПостановкаНаКонтроль_КонтрольныеПунктыДокумента.Очистить();
			НоваяСтрока = Уведомление.ПостановкаНаКонтроль.Добавить();
			НоваяСтрока.ТребуетсяРегистрация = documentSent.needRegistration;
			НоваяСтрока.ТребуетсяИсполнение = documentSent.needExecution;
			НоваяСтрока.ТребуетсяПубликация = documentSent.needPublication;
			clauses = СвойствоXDTOЕслиЕсть(documentSent, "clauses", Неопределено);
			Если clauses <> Неопределено И ЕстьСвойствоXDTO(clauses, "clause") Тогда
				clause = ЗначениеВМассивеXDTO(clauses.clause);
				ПунктыДокумента = Новый Массив();
				Для Каждого claus_i Из clause Цикл
					Пункт = ПрочитатьDocumentClause(claus_i, Реквизиты.ДатаУчетаДокумента);
					ПунктыДокумента.Добавить(Пункт);
					Если ЗначениеЗаполнено(НоваяСтрока.ПунктыДокументаПредставление)
						И ЗначениеЗаполнено(Пункт.ПолноеПредставление) Тогда
						НоваяСтрока.ПунктыДокументаПредставление = НоваяСтрока.ПунктыДокументаПредставление + Символы.ПС;
					КонецЕсли;
					НоваяСтрока.ПунктыДокументаПредставление = НоваяСтрока.ПунктыДокументаПредставление
						+ ЗаполненноеЗначениеСтрокой("", Пункт.ПолноеПредставление, Символы.ПС, "");
					
					НоваяСтрокаПункт = Уведомление.ПостановкаНаКонтроль_КонтрольныеПунктыДокумента.Добавить();
					ЗаполнитьЗначенияСвойств(
						НоваяСтрокаПункт, Пункт, 
						"НомерПоПорядку, ИдентификаторПункта, Наименование, ТекстПункта, СрокИсполнения, Комментарий");
					НоваяСтрокаПункт.Юрлицо = Пункт.Ответственный.ЮрлицоСсылка;
					НоваяСтрокаПункт.Ответственный = Пункт.Ответственный.КонтактноеЛицоСсылка;
					НоваяСтрокаПункт.ОтветственныйПредставление = Пункт.ПолноеПредставление;
				КонецЦикла;
			КонецЕсли;
			
		ИначеЕсли ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОРегистрации
			И ЕстьСвойствоXDTO(notification, "documentAccepted") Тогда
			
			Уведомление.Регистрация.Очистить();
			НоваяСтрока = Уведомление.Регистрация.Добавить();
			НоваяСтрока.РегистрационныйНомер = notification.documentAccepted.num.number;
			НоваяСтрока.ДатаРегистрации = notification.documentAccepted.num.date;
			
			МЭДОПереопределяемый.ЗаписатьВИсходящийДокументРегистрациюКонтрагента(
				Документ,
				КонтрагентИзУведомления,
				НоваяСтрока.РегистрационныйНомер,
				НоваяСтрока.ДатаРегистрации,
				ДанныеОтвета);
			Если Не ДанныеОтвета.Успех Тогда
				ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
			КонецЕсли;
			
		ИначеЕсли ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОбОтказеВРегистрации
			И ЕстьСвойствоXDTO(notification, "documentRefused") Тогда
			
			ИменаПредопределенных = Метаданные.Справочники.ПричиныОтказаВРегистрацииМЭДО.ПолучитьИменаПредопределенных();
			УдалосьНайти = Ложь;
			ПричинаОтказа = Неопределено;
			ПричинаОтказаИзСообщения = ЗначениеВМассивеXDTO(notification.documentRefused.reason)[0];
			Для Каждого ИмяПредопределенного Из ИменаПредопределенных Цикл
				ПричинаОтказа = Справочники.ПричиныОтказаВРегистрацииМЭДО[ИмяПредопределенного];
				Если "" + ПричинаОтказа = ПричинаОтказаИзСообщения Тогда
					Уведомление.ОтказВРегистрации.Очистить();
					НоваяСтрока = Уведомление.ОтказВРегистрации.Добавить();
					НоваяСтрока.ПричинаОтказа = ПричинаОтказа;
					УдалосьНайти = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не УдалосьНайти Тогда 
				НоваяСтрока = Уведомление.ОтказВРегистрации.Добавить();
				НоваяСтрока.ПричинаОтказа = Справочники.ПричиныОтказаВРегистрацииМЭДО.НеРаспознана;
				Уведомление.Комментарий = Уведомление.Комментарий + Символы.ПС
					+ СтрШаблон(НСтр("ru = 'Не распознанная причина отказа: %1'"), ПричинаОтказаИзСообщения);
			КонецЕсли;
			
		ИначеЕсли ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОПринятииКИсполнению
			И ЕстьСвойствоXDTO(notification, "executorAssigned") Тогда
			
			executorAssigned = notification.executorAssigned;
			
			Уведомление.ПринятиеКИсполнению.Очистить();
			НоваяСтрока = Уведомление.ПринятиеКИсполнению.Добавить();
			
			secretary = СвойствоXDTOЕслиЕсть(executorAssigned, "secretary", Неопределено);
			Если secretary <> Неопределено Тогда
				РуководительСекретарь = ПрочитатьAnyone(secretary, Реквизиты.ДатаУчетаДокумента);
				Если ЗначениеЗаполнено(РуководительСекретарь.ЮрлицоСсылка) Тогда
					НоваяСтрока.Юрлицо = РуководительСекретарь.ЮрлицоСсылка;
				КонецЕсли;
				НоваяСтрока.РуководительСекретарь = РуководительСекретарь.КонтактноеЛицоСсылка;
				Комментарий = СвойствоXDTOЕслиЕсть(secretary, "comment", "");
				НоваяСтрока.КомментарийРуководителяСекретаря = Комментарий;
				НоваяСтрока.РуководительСекретарьПредставление = 
					НСтр("ru = 'Руководитель/секретарь учреждения'") + Символы.ПС
					+ РуководительСекретарь.ПолноеПредставление
					+ ЗаполненноеЗначениеСтрокой(НСтр("ru = 'Комментарий:'"), Комментарий, "");
			КонецЕсли;
			
			manager = СвойствоXDTOЕслиЕсть(executorAssigned, "manager", Неопределено);
			Если manager <> Неопределено Тогда
				РуководительПодразделения = ПрочитатьAnyone(manager, Реквизиты.ДатаУчетаДокумента);
				Если ЗначениеЗаполнено(РуководительПодразделения.ЮрлицоСсылка) Тогда
					// Если даже заполнено выше, то конкретизируем нижестоящим ведомством
					НоваяСтрока.Юрлицо = РуководительПодразделения.ЮрлицоСсылка;
				КонецЕсли;
				НоваяСтрока.РуководительПодразделения = РуководительПодразделения.КонтактноеЛицоСсылка;
				Комментарий = СвойствоXDTOЕслиЕсть(manager, "comment", "");
				НоваяСтрока.КомментарийРуководителяПодразделения = Комментарий;
				НоваяСтрока.РуководительПодразделенияПредставление =
					НСтр("ru = 'Руководитель подразделения'") + Символы.ПС
					+ РуководительПодразделения.ПолноеПредставление
					+ ЗаполненноеЗначениеСтрокой(НСтр("ru = 'Комментарий:'"), Комментарий, "");
			КонецЕсли;
			
			executor = СвойствоXDTOЕслиЕсть(executorAssigned, "executor", Неопределено);
			Если executor <> Неопределено Тогда
				Исполнитель = ПрочитатьAnyone(executor, Реквизиты.ДатаУчетаДокумента);
				Если ЗначениеЗаполнено(Исполнитель.ЮрлицоСсылка) Тогда
					// Если даже заполнено выше, то конкретизируем нижестоящим ведомством
					НоваяСтрока.Юрлицо = Исполнитель.ЮрлицоСсылка;
				КонецЕсли;
				НоваяСтрока.Исполнитель = Исполнитель.КонтактноеЛицоСсылка;
				Комментарий = СвойствоXDTOЕслиЕсть(manager, "comment", "");
				НоваяСтрока.КомментарийИсполнителя = Комментарий;
				НоваяСтрока.ИсполнительПредставление =
					НСтр("ru = 'Исполнитель'") + Символы.ПС
					+ Исполнитель.ПолноеПредставление
					+ ЗаполненноеЗначениеСтрокой(НСтр("ru = 'Комментарий:'"), Комментарий, "");
			КонецЕсли;
			
		ИначеЕсли ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОПодготовкеДоклада 
			И ЕстьСвойствоXDTO(notification, "reportPrepared") Тогда
			
			reportPrepared = notification.reportPrepared;
			signatory = СвойствоXDTOЕслиЕсть(reportPrepared, "signatory", Неопределено);
			Если signatory <> Неопределено Тогда
				Уведомление.ПодготовкаДоклада.Очистить();
				НоваяСтрока = Уведомление.ПодготовкаДоклада.Добавить();
				НоваяСтрока.ДатаПодписания = ЗначениеВДату(СвойствоXDTOЕслиЕсть(signatory, "signed", Неопределено));
				Комментарий = СвойствоXDTOЕслиЕсть(signatory, "comment", "");
				НоваяСтрока.КомментарийПодписания = Комментарий;
				
				Ответственный = ПрочитатьAnyone(signatory, Реквизиты.ДатаУчетаДокумента);
				НоваяСтрока.Юрлицо = Ответственный.ЮрлицоСсылка;
				НоваяСтрока.Ответственный = Ответственный.КонтактноеЛицоСсылка;
				НоваяСтрока.ОтветственныйПредставление = Ответственный.ПолноеПредставление
					+ ЗаполненноеЗначениеСтрокой(НСтр("ru = 'Комментарий:'"), Комментарий, "");
			КонецЕсли;
			
		ИначеЕсли ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОНаправленииДоклада
			И ЕстьСвойствоXDTO(notification, "reportSent") Тогда
			
			reportSent = notification.reportSent;
			
			report = СвойствоXDTOЕслиЕсть(reportSent, "report", Неопределено);
			Если report <> Неопределено Тогда
				Уведомление.НаправлениеДоклада.Очистить();
				НоваяСтрока = Уведомление.НаправлениеДоклада.Добавить();
				СведенияОДокументе = ПрочитатьDocumentReference(report, Реквизиты.ДатаУчетаДокумента);
				НоваяСтрока.Юрлицо = СведенияОДокументе.ЮрлицоСсылка;
				НоваяСтрока.Ответственный = СведенияОДокументе.КонтактноеЛицоСсылка;
				НоваяСтрока.РегистрационныйНомер = СведенияОДокументе.РегистрационныеДанные.РегистрационныйНомер;
				НоваяСтрока.ДатаРегистрации = СведенияОДокументе.РегистрационныеДанные.ДатаРегистрации;
				НоваяСтрока.Комментарий = СведенияОДокументе.Комментарий;
				НоваяСтрока.ОтветственныйПредставление = СведенияОДокументе.ПолноеПредставление;
			КонецЕсли;
			
		ИначеЕсли ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОХодеИсполнения
			И ЕстьСвойствоXDTO(notification, "courseChanged") Тогда
			
			courseChanged = notification.courseChanged;
			
			Уведомление.ХодИсполнения.Очистить();
			НоваяСтрока = Уведомление.ХодИсполнения.Добавить();
			НоваяСтрока.ОписаниеХодаИсполнения = courseChanged.courseText;
			
			reference = СвойствоXDTOЕслиЕсть(courseChanged, "reference", Неопределено);
			СведенияОДокументе = МЭДОСтруктурыДанных.НовыйСведенияОДокументе();
			Если reference <> Неопределено Тогда
				СведенияОДокументе = ПрочитатьDocumentReference(
					reference, Реквизиты.ДатаУчетаДокумента);
				НоваяСтрока.Юрлицо = СведенияОДокументе.ЮрлицоСсылка;
				НоваяСтрока.Ответственный = СведенияОДокументе.КонтактноеЛицоСсылка;
				НоваяСтрока.РегистрационныйНомер = СведенияОДокументе.РегистрационныеДанные.РегистрационныйНомер;
				НоваяСтрока.ДатаРегистрации = СведенияОДокументе.РегистрационныеДанные.ДатаРегистрации;
				НоваяСтрока.Комментарий = СведенияОДокументе.Комментарий;
				НоваяСтрока.ОтветственныйПредставление = СведенияОДокументе.ПолноеПредставление;
			КонецЕсли;
			
		ИначеЕсли ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОбОпубликовании
			И ЕстьСвойствоXDTO(notification, "documentPublished") Тогда
			
			documentPublished = notification.documentPublished;
			
			Уведомление.Опубликование.Очистить();
			НоваяСтрока = Уведомление.Опубликование.Добавить();
			НоваяСтрока.РегистрационныйНомер = СвойствоXDTOЕслиЕсть(documentPublished.num, "number", "");
			НоваяСтрока.ДатаРегистрации = СвойствоXDTOЕслиЕсть(documentPublished.num, "date", "");
			НоваяСтрока.ПечатныйОрган = СвойствоXDTOЕслиЕсть(documentPublished, "publicationPoint", "");
			
		Иначе
			
			ТекстОшибкиПодробно = СтрШаблон(
				НСтр("ru = 'Во входящем уведомлении ID=%1 по исх.сообщению %2
				|не предусмотренный тип уведомления - указано ""%3""
				|Временный каталог %4'"), 
				ИдентификаторУведомления, ИдентификаторСообщенияДокумента, ТипУведомленияИзСообщения, ВременныйКаталог);
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка, Документ,
				Текст_ОшибкаЗагрузкиВходящегоУведомления(), ТекстОшибкиПодробно, ДанныеОтвета);
			ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
		КонецЕсли;
		
		Уведомление.Записать();
		
		
		СоздатьИсходящуюКвитанцию(
			ИдентификаторУведомления, Уведомление.Ссылка, КонтрагентИзУведомления, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
		КонецЕсли;
		
		
		ПолученоУспешно = Истина;
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		
		// Пишем в журнал только если ошибка не обработана во вложенных процедурах, вложенные сами пишут в журнал.
		Если ДанныеОтвета.Успех Тогда
			ТекстОшибкиПодробно = СтрШаблон(
				НСтр("ru = 'Временный файл %1. %2'"),
				ВременныйКаталог, ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка, Документ,
				Текст_ОшибкаЗагрузкиВходящегоУведомления(), ТекстОшибкиПодробно, ДанныеОтвета);
		КонецЕсли;
	КонецПопытки;
	
	Если ПолученоУспешно Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Информация,
			Уведомление.Ссылка,
			Текст_ОбъектПолученУспешно(),
			Текст_ОбъектПолученУспешно(),
			ДанныеОтвета);
	КонецЕсли;
	
КонецПроцедуры

Функция ПрочитатьDocumentClause(ОбъектXDTO, ДатаУчетаДокумента)

	Пункт = МЭДОСтруктурыДанных.НовыйПунктДокумента();
	
	Если ОбъектXDTO = Неопределено Тогда
		Возврат Пункт;
	КонецЕсли;
	
	Пункт.НомерПоПорядку = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "localId", 0);
	Пункт.ИдентификаторПункта = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "id", "");
	Пункт.Наименование = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "designation", "");
	Пункт.ТекстПункта = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "text", "");
	Пункт.СрокИсполнения = ЗначениеВДату(
		СвойствоXDTOЕслиЕсть(ОбъектXDTO, "deadline", '00010101'));
	
	principal = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "principal", Неопределено);
	Пункт.Ответственный = ПрочитатьAnyone(principal, ДатаУчетаДокумента);
	Пункт.ПолноеПредставление = Пункт.Ответственный.ПолноеПредставление;
	Пункт.Ответственный.ПолноеПредставление = "";// отсюда убираем, чтобы не дублировать, оптимизация хранения.
	Если principal <> Неопределено Тогда
		Пункт.Комментарий = СвойствоXDTOЕслиЕсть(principal, "comment", Неопределено);
		Пункт.ПолноеПредставление = Пункт.ПолноеПредставление
			+ ЗаполненноеЗначениеСтрокой(НСтр("ru = 'Комментарий:'"), Пункт.Комментарий, "");
	КонецЕсли;
	
	Возврат Пункт;

КонецФункции

// Читает из сообщения уведомления объект, описывающий исполнителя - anyone.
// 
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - Объект из дерева сообщения, прочитанного фабрикой XDTO.
//  ДатаУчетаДокумента - Дата - Дата, на которую нужно получить сведения о контрагенте и контактном лице.
// 
// Возвращаемое значение:
//  см. МЭДОСтруктурыДанных.НовыйОтветственнаяСтруктурнаяЕдиница.
Функция ПрочитатьAnyone(ОбъектXDTO, ДатаУчетаДокумента)
	
	ОтветственнаяСтруктурнаяЕдиница = МЭДОСтруктурыДанных.НовыйОтветственнаяСтруктурнаяЕдиница();
	
	Если ОбъектXDTO = Неопределено Тогда
		Возврат ОтветственнаяСтруктурнаяЕдиница;
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(ОтветственнаяСтруктурнаяЕдиница.Регион, ПрочитатьQualifiedValue(ОбъектXDTO, "region"));
	
	ЗаполнитьЗначенияСвойств(
		ОтветственнаяСтруктурнаяЕдиница.Юрлицо, ПрочитатьQualifiedValue(ОбъектXDTO, "organization"));
	ЗаполнитьЗначенияСвойств(
		ОтветственнаяСтруктурнаяЕдиница.Персона, ПрочитатьQualifiedValue(ОбъектXDTO, "person"));
	
	Если ЗначениеЗаполнено(ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Идентификатор) Тогда
		// Специально создавать не контрагента не будем, то попытаемся опознать, если уже есть.
		КонтрагентСсылка = МЭДОПереопределяемый.НайтиСоздатьКонтрагента(
			ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Наименование,
			ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Идентификатор,
			ДатаУчетаДокумента,
			Истина);
		Если ЗначениеЗаполнено(КонтрагентСсылка) Тогда
			ОтветственнаяСтруктурнаяЕдиница.ЮрлицоСсылка = КонтрагентСсылка;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ОтветственнаяСтруктурнаяЕдиница.Персона.Идентификатор)
			И ЗначениеЗаполнено(ОтветственнаяСтруктурнаяЕдиница.ЮрлицоСсылка) Тогда
			// Если известен контрагент, то привяжем контактное лицо:
			ОтветственнаяСтруктурнаяЕдиница.КонтактноеЛицоСсылка = МЭДОПереопределяемый.НайтиСоздатьКонтактноеЛицо(
				КонтрагентСсылка,
				ОтветственнаяСтруктурнаяЕдиница.Персона.Наименование,
				ОтветственнаяСтруктурнаяЕдиница.Персона.Идентификатор,
				ДатаУчетаДокумента);
		КонецЕсли;
	КонецЕсли;
	
	// Должности и подразделения контрагентов храним просто в виде строк:
	ЗаполнитьЗначенияСвойств(
		ОтветственнаяСтруктурнаяЕдиница.Подразделение, ПрочитатьQualifiedValue(ОбъектXDTO, "department"));
	ЗаполнитьЗначенияСвойств(
		ОтветственнаяСтруктурнаяЕдиница.Должность, ПрочитатьQualifiedValue(ОбъектXDTO, "post"));
	
	ОтветственнаяСтруктурнаяЕдиница.КонтактнаяИнформацияПредставление
		= СвойствоXDTOЕслиЕсть(ОбъектXDTO, "contactInfo", "");
	
	ОтветственнаяСтруктурнаяЕдиница.ПолноеПредставление
		= ПредставлениеОтветственнойСтруктурнойЕдиницы(ОтветственнаяСтруктурнаяЕдиница);
	
	Возврат ОтветственнаяСтруктурнаяЕдиница;
	
КонецФункции

// Читает из сообщения уведомления объект, описывающий сведения о документе - documentReference.
// 
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - Объект из дерева сообщения, прочитанного фабрикой XDTO.
//  ДатаУчетаДокумента - Дата - Дата, на которую нужно получить сведения о контрагенте и контактном лице.
// 
// Возвращаемое значение:
//  см. МЭДОСтруктурыДанных.НовыйСведенияОДокументе.
Функция ПрочитатьDocumentReference(ОбъектXDTO, ДатаУчетаДокумента)
	
	СведенияОДокументе = МЭДОСтруктурыДанных.НовыйСведенияОДокументе();
	
	Если ОбъектXDTO = Неопределено Тогда
		Возврат СведенияОДокументе;
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(СведенияОДокументе.Регион, ПрочитатьQualifiedValue(ОбъектXDTO, "region"));
	ЗаполнитьЗначенияСвойств(
		СведенияОДокументе.Юрлицо, ПрочитатьQualifiedValue(ОбъектXDTO, "organization"));
	ЗаполнитьЗначенияСвойств(
		СведенияОДокументе.Персона, ПрочитатьQualifiedValue(ОбъектXDTO, "person"));
	
	Если ЗначениеЗаполнено(СведенияОДокументе.Юрлицо.Идентификатор) Тогда
		// Специально создавать не контрагента не будем, то попытаемся опознать, если уже есть.
		КонтрагентСсылка = МЭДОПереопределяемый.НайтиСоздатьКонтрагента(
			СведенияОДокументе.Юрлицо.Наименование,
			СведенияОДокументе.Юрлицо.Идентификатор,
			ДатаУчетаДокумента,
			Истина);
		Если ЗначениеЗаполнено(КонтрагентСсылка) Тогда
			СведенияОДокументе.ЮрлицоСсылка = КонтрагентСсылка;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(СведенияОДокументе.Персона.Идентификатор)
			И ЗначениеЗаполнено(СведенияОДокументе.ЮрлицоСсылка) Тогда
			// Если известен контрагент, то привяжем контактное лицо:
			СведенияОДокументе.КонтактноеЛицоСсылка = МЭДОПереопределяемый.НайтиСоздатьКонтактноеЛицо(
				КонтрагентСсылка,
				СведенияОДокументе.Персона.Наименование,
				СведенияОДокументе.Персона.Идентификатор,
				ДатаУчетаДокумента);
		КонецЕсли;
	КонецЕсли;
	
	// Должности и подразделения контрагентов храним просто в виде строк:
	ЗаполнитьЗначенияСвойств(
		СведенияОДокументе.Подразделение, ПрочитатьQualifiedValue(ОбъектXDTO, "department"));
	ЗаполнитьЗначенияСвойств(
		СведенияОДокументе.Должность, ПрочитатьQualifiedValue(ОбъектXDTO, "post"));
	
	num = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "num", Неопределено);
	Если num <> Неопределено Тогда
		СведенияОДокументе.РегистрационныеДанные.РегистрационныйНомер = СвойствоXDTOЕслиЕсть(num, "number", "");
		СведенияОДокументе.РегистрационныеДанные.ДатаРегистрации =
			ЗначениеВДату(СвойствоXDTOЕслиЕсть(num, "date", '00010101'));
	КонецЕсли;
	
	СведенияОДокументе.Комментарий = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "comment", "");
	
	СведенияОДокументе.ПолноеПредставление = ПолучитьПредставлениеСведенийОДокументе(СведенияОДокументе);
	
	Возврат СведенияОДокументе;
	
КонецФункции

// Обрабатывает входящее сообщение, соответствующее входящей квитанции на исходящий документ или исходящее уведомление.
//
Процедура ОбработатьВходящуюКвитанцию(ВременныйКаталог, communication, ДвоичныеДанныеЭСД, ДанныеОтвета)
	
	ВерсияМЭДОСтрокой = communication.version;
	
	acknowledgment = communication.acknowledgment;
	ИдентификаторКвитанции	= communication.header.uid;
	ИдентификаторСообщения = acknowledgment.uid;
	
	Если Не ЗначениеЗаполнено(ИдентификаторСообщения) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Во входящей квитанции не обнаружен идентификатор сообщения (поле acknowledgment.uid),
			|относительно которого создается квитанция. uid квитанции=%1, временный файл %2'"), 
			ИдентификаторКвитанции,
			ВременныйКаталог);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			СтрШаблон("ru = 'Квитанция %1'", ИдентификаторКвитанции),
			Текст_ОшибкаЗаписиКвитанции(),
			ТекстОшибкиПодробно,
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	// Получим предмет по идентификатору исходящего сообщения, это либо документ, либо уведомление:
	Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Состояния.Документ КАК Предмет,
		|	""ИсходящийДокумент"" КАК ТипПредмета
		|ИЗ
		|	РегистрСведений.СостоянияДокументовМЭДО КАК Состояния
		|ГДЕ
		|	ИдентификаторСообщения = &ИдентификаторСообщения
		|	И Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Исходящее)
		|	И Состояние = ЗНАЧЕНИЕ(Перечисление.СостоянияДокументовМЭДО.ДокументОтправлен)
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	Уведомления.Ссылка КАК Предмет,
		|	""ИсходящееУведомление"" КАК ТипПредмета
		|ИЗ
		|	Документ.УведомлениеМЭДО КАК Уведомления
		|ГДЕ
		|	Уведомления.ИдентификаторУведомления = &ИдентификаторСообщения
		|	И Уведомления.Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Исходящее)");
	Запрос.УстановитьПараметр("ИдентификаторСообщения", ИдентификаторСообщения);
	Выборка = Запрос.Выполнить().Выбрать();
	ТипПредмета = Неопределено;
	Предмет = Неопределено;
	Если Выборка.Следующий() Тогда
		Предмет = Выборка.Предмет;
		ТипПредмета = Выборка.ТипПредмета;
	Иначе
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'По входящей квитанции с идентификатором %1 в базе данных не обнаружен
			|предмет с идентификатором %2 - документ или уведомление,
			|временный файл %3'"), 
			ИдентификаторКвитанции,
			ИдентификаторСообщения,
			ВременныйКаталог);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			СтрШаблон("ru = 'Входящая квитанция ID=%1'", ИдентификаторКвитанции),
			Текст_ОшибкаЗаписиКвитанции(),
			ТекстОшибкиПодробно,
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	ИсходящаяДатаКвитанции = ЗначениеВДату(acknowledgment.time);
	Организация = Неопределено;
	Контрагент = Неопределено;
	Если ТипПредмета = "ИсходящееУведомление" Тогда
		Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Предмет, "Организация, Дата, Контрагент");
		Организация = Реквизиты.Организация;
		Контрагент = Реквизиты.Контрагент;
	ИначеЕсли ТипПредмета = "ИсходящийДокумент" Тогда
		Реквизиты = МЭДОПереопределяемый.ТребуемыеДанныеИсходящегоДокумента(
			Предмет, "Организация, ДатаУчетаДокумента, Контрагенты", ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат;
		КонецЕсли;
		Организация = Реквизиты.Организация;
		
		Контрагент = МЭДОПереопределяемый.НайтиСоздатьКонтрагента(
			communication.header.source.organization, communication.header.source.uid, ИсходящаяДатаКвитанции, Истина);
		Если Не ЗначениеЗаполнено(Контрагент) Тогда
			ТекстОшибкиПодробно = СтрШаблон(НСтр(
				"ru = 'Не удалось распознать контрагента %1, id=%2
				|во входящей квитанции id=%3 - в нашей ИБ не обнаружен,
				|на исходящий документе %4,
				|идентификатор сообщения %5'"),
				communication.header.source.organization,
				communication.header.source.uid,
				ИдентификаторКвитанции,
				Предмет,
				ИдентификаторСообщения);
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка, Предмет, 
				Текст_ОшибкаЗаписиКвитанции(), ТекстОшибкиПодробно, ДанныеОтвета);
			Возврат;
		КонецЕсли;
		Найден = Ложь;
		Для Каждого СтруктураКонтрагент Из Реквизиты.Контрагенты Цикл
			Если СтруктураКонтрагент.Контрагент = Контрагент Тогда
				Найден = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если Не Найден Тогда
			ТекстОшибкиПодробно = СтрШаблон(НСтр(
				"ru = 'Контрагент %1 из входящей квитанции id=%2
				|не найден в исходящем документе %3,
				|идентификатор сообщения %4'"),
				Контрагент, ИдентификаторКвитанции, Предмет, ИдентификаторСообщения);
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Предупреждение, Предмет, 
				Текст_ОшибкаЗаписиКвитанции(), ТекстОшибкиПодробно, ДанныеОтвета);
			// Но тем не менее - документ по id распознан, не будем считать это критичной ошибкой, загрузка идет дальше.
		КонецЕсли;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Контрагент) Тогда
		ТекстОшибкиПодробно = СтрШаблон(НСтр(
			"ru = 'В документе %1 входящей квитанции id=%2
			|по исх.сообщению %3 Не удалось найти контрагента.'"),
			Предмет, ИдентификаторКвитанции, ИдентификаторСообщения);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Предмет, 
			Текст_ОшибкаЗаписиКвитанции(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	
	// Квитанцию каждый раз будем заново делать, может направляться несколько раз на одну цепочку.
	Квитанция = Документы.КвитанцияМЭДО.СоздатьДокумент();
	Квитанция.Предмет = Предмет;
	Квитанция.Дата = ТекущаяДатаСеанса();
	Квитанция.ИсходящаяДата = ИсходящаяДатаКвитанции;
	Квитанция.Направление = Перечисления.НаправленияСообщенийМЭДО.Входящее;
	Квитанция.Заполнить(Неопределено);
	Квитанция.ИдентификаторКвитанции = ИдентификаторКвитанции;
	Квитанция.ИдентификаторСообщения = ИдентификаторСообщения;
	Квитанция.Контрагент = Контрагент;
	Квитанция.Организация = Организация;
	Квитанция.ДанныеСообщения = Новый ХранилищеЗначения(ДвоичныеДанныеЭСД);
	Квитанция.СообщениеПринято = acknowledgment.accepted;
	Квитанция.ПометкаУдаления = Ложь;
	Если Не Квитанция.СообщениеПринято Тогда
		Если ВерсияМЭДОСтрокой = "2.7.1" Тогда
			Квитанция.КодОшибки = СвойствоXDTOЕслиЕсть(acknowledgment, "errorCode", 0);
		КонецЕсли;
		
		Квитанция.КомментарийОшибки = СвойствоXDTOЕслиЕсть(acknowledgment, "comment", "");
	КонецЕсли;
	
	Попытка
		Квитанция.Записать();
		
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Информация,
			Квитанция.Ссылка,
			Текст_ОбъектПолученУспешно(),
			Текст_ОбъектПолученУспешно(),
			ДанныеОтвета);
	Исключение
		СтекОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Ошибка при записи квитанции ID=%1: %2, временный файл %3'"), 
			Квитанция.ИдентификаторКвитанции,
			СтекОшибки,
			ВременныйКаталог);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Квитанция.ИдентификаторКвитанции,
			Текст_ОшибкаЗаписиКвитанции(), ТекстОшибкиПодробно, ДанныеОтвета);
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

#Область ИсходящиеКвитанции

// Создает и записывает исходящую квитанцию. 
//
// Параметры:
//   ИдентификаторСообщения - Строка - Идентификатор сообщения, в ответ на которое создается квитанция.
//   Предмет - ОпределяемыйТип.ПредметМЭДО,
//             ДокументСсылка.УведомлениеМЭДО - Предмет исходящей квитанции.
//   Контрагент - ОпределяемыйТип.КонтрагентМЭДО
//   ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет
//
Процедура СоздатьИсходящуюКвитанцию(ИдентификаторСообщения, Предмет, Контрагент, ДанныеОтвета)
	
	Если Не ЗначениеЗаполнено(Предмет) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Не определен предмет (документ или уведомление) для исходящей квитанции по сообщению %1'"),
			ИдентификаторСообщения);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Предупреждение, 
			Предмет, 
			НСтр("ru = 'Не определен предмет для квитанции'"),
			ТекстОшибкиПодробно,
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	

	// Сообщение с одним id может приходить несколько раз, каждый раз будем отвечать заново.
	Квитанция = Документы.КвитанцияМЭДО.СоздатьДокумент();
	Квитанция.Направление = Перечисления.НаправленияСообщенийМЭДО.Исходящее;
	Квитанция.Заполнить(Неопределено);
	
	Если ТипЗнч(Предмет) = Тип("ДокументСсылка.УведомлениеМЭДО") Тогда
		Квитанция.Организация = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Предмет, "Организация");
	Иначе
		Реквизиты = МЭДОПереопределяемый.ТребуемыеДанныеВходящегоДокумента(Предмет, "Организация", ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат;
		КонецЕсли;
		Квитанция.Организация = Реквизиты.Организация;
	КонецЕсли;
	Квитанция.Дата = ТекущаяДатаСеанса() + 10; // Чуть позже, т.к. может записаться в ту же секунду, что и соответствующий документ/уведомление
	Квитанция.ДанныеКонверта			= Неопределено;
	Квитанция.ДанныеСообщения			= Неопределено;
	// Квитанция.ИдентификаторКвитанции - заполняется при первой записи квитанции в ПередЗаписью().
	Квитанция.ИдентификаторСообщения	= ИдентификаторСообщения;
	Квитанция.Отправлена				= Ложь;
	Если МЭДОПовтИсп.АвтоматическиОтправлятьКвитанцииМЭДО() Тогда
		Квитанция.ГотоваКОтправке = Истина;
	КонецЕсли;
	Квитанция.Контрагент				= Контрагент;
	Квитанция.Предмет					= Предмет;
	Квитанция.ПометкаУдаления			= Ложь;
	Квитанция.Записать();
	
КонецПроцедуры

// Функция - Возвращает данные неотправленных ранее исходящих квитанций для отправки по МЭДО.
//
// Параметры:
//  Настройки - См. РегистрыСведений.НастройкиОрганизацийМЭДО.НовыйНастройки
//  МассивКвитанций - Массив из ДокументСсылка.КвитанцияМЭДО - Если Неопределено, то все, подлежащие 
//  																отправке по этой организации, 
//																	либо отбор по выбранным квитанциям.
//
// Возвращаемое значение:
//   Соответствие из КлючИЗначение
//   * Ключ - ДокументСсылка.КвитанцияМЭДО - Ссылка на квитанцию.
//   * Значение - Структура - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящейКвитанцииДляОтправки.
//
Функция ДанныеИсходящихКвитанцийДляОтправки(Настройки, МассивКвитанций = Неопределено)
	
	УстановитьПривилегированныйРежим(Истина);
	
	ДанныеКвитанций = Новый Соответствие();
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 9999
		|	Квитанции.Ссылка КАК Квитанция,
		|	Квитанции.Дата КАК Дата,
		|	Квитанции.Предмет КАК Предмет,
		|	Квитанции.ИдентификаторСообщения КАК ИдентификаторСообщения,
		|	Квитанции.ИдентификаторКвитанции КАК ИдентификаторКвитанции,
		|	Квитанции.Контрагент КАК Контрагент,
		|	ВЫБОР
		|		КОГДА НЕ Настройки.ВерсияФорматаМЭДО IS NULL
		|			И Настройки.ВерсияФорматаМЭДО <> ЗНАЧЕНИЕ(Перечисление.ВерсииФорматаМЭДО.ПустаяСсылка)
		|			ТОГДА Настройки.ВерсияФорматаМЭДО
		|		ИНАЧЕ &ПоследняяВерсия
		|	КОНЕЦ КАК ВерсияМЭДО,
		|	Настройки.АдресМЭДО КАК АдресМЭДОКонтрагента
		|ИЗ
		|	Документ.КвитанцияМЭДО КАК Квитанции
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.НастройкиКонтрагентовМЭДО КАК Настройки
		|		ПО Настройки.Контрагент = Квитанции.Контрагент
		|ГДЕ
		|	Квитанции.ГотоваКОтправке
		|	И Квитанции.Организация = &Организация
		|	И НЕ Квитанции.ПометкаУдаления
		|	И НЕ Квитанции.Отправлена
		|	И Квитанции.Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Исходящее)
		|	И &ОтборКвитанций");
	Запрос.УстановитьПараметр("Организация", Настройки.Организация);
	Если МассивКвитанций <> Неопределено Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ОтборКвитанций", "Квитанции.Ссылка В (&МассивКвитанций)");
		Запрос.УстановитьПараметр("МассивКвитанций", МассивКвитанций);
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ОтборКвитанций", "ИСТИНА");
	КонецЕсли;
	Запрос.УстановитьПараметр("ПоследняяВерсия", Перечисления.ВерсииФорматаМЭДО.ПоследняяВерсия());
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "9999", Формат(МЭДОПовтИсп.РазмерПорцииОбработки(), "ЧГ=0;"));
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Данные = МЭДОСтруктурыДанных.НовыйДанныеИсходящейКвитанцииДляОтправки();
		ЗаполнитьЗначенияСвойств(
			Данные, Выборка, 
			"Квитанция, ВерсияМЭДО, Дата, Предмет, ИдентификаторСообщения, ИдентификаторКвитанции");
		
		ДанныеОтвета = МЭДОСтруктурыДанных.НовыйОтвет();
		
		Реквизиты = Неопределено;
		ДатаУчета = '00010101';
		Если ТипЗнч(Данные.Предмет) = Тип("ДокументСсылка.УведомлениеМЭДО") Тогда
			Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Данные.Предмет, "Организация, Контрагент, Дата");
			ДатаУчета = Реквизиты.Дата;
		Иначе
			Реквизиты = МЭДОПереопределяемый.ТребуемыеДанныеВходящегоДокумента(
				Данные.Предмет, "Организация, Контрагент, ДатаУчетаДокумента", ДанныеОтвета);
			ДатаУчета = Реквизиты.ДатаУчетаДокумента;
			Если Не ДанныеОтвета.Успех Тогда
				Продолжить; // Если не отправилось по одному документу, то по другим все-таки пусть отправит.
			КонецЕсли;
		КонецЕсли;
		
		Данные.Организация.Наименование = Настройки.НаименованиеМЭДО;
		Данные.Организация.ОрганизацияСсылка = Реквизиты.Организация;
		Данные.Организация.Идентификатор = Настройки.ИдентификаторМЭДО;
		Данные.Организация.АдресМЭДО = Настройки.АдресМЭДО;
		
		СтруктураКонтрагент = ПоляКонтрагента(
			Реквизиты.Контрагент, ДатаУчета, Истина, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Продолжить; // Если не отправилась одна квитанция, то другие пусть все-таки отправятся.
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(Данные.Контрагент, СтруктураКонтрагент);
		
		ДанныеКвитанций[Выборка.Квитанция] = Данные;
	КонецЦикла;
	
	Возврат ДанныеКвитанций;
	
КонецФункции

// Процедура - Создает и записывает сообщение по исходящей квитанции.
// 
// Параметры:
//  Путь - Строка - путь к каталогу для помещения сообщения.
//  Квитанция - ДокументСсылка.КвитанцияМЭДО - Исходящая квитанция для отправки.
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящейКвитанцииДляОтправки.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ЗаписатьСообщениеПоИсходящейКвитанции(Путь, Квитанция, Данные, ДанныеОтвета)
	
	УстановитьПривилегированныйРежим(Истина);
	
	ВерсияМЭДО = Данные.ВерсияМЭДО;
	Если Не ЗначениеЗаполнено(ВерсияМЭДО) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'У получателя квитанции ""%1"" по документу %2 не указана версия МЭДО
			|(можно указать либо для контрагента, либо для самого документа)'"),
			Данные.Контрагент.Наименование,
			Данные.Предмет);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Данные.Предмет,
			Текст_ОшибкаВКонтрагенте(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(Данные.Контрагент.Идентификатор) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'У получателя квитанции ""%1"" не указан идентификатор МЭДО'"),
			Данные.Контрагент.Наименование);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Данные.Предмет,
			Текст_ОшибкаВКонтрагенте(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(Данные.Контрагент.АдресМЭДО) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'У получателя квитанции ""%1"" не указан адрес МЭДО'"),
			Данные.Контрагент.Наименование);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Данные.Предмет,
			Текст_ОшибкаВКонтрагенте(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	Попытка
		
		ПодкаталогСообщения = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(
			ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(Путь) + Данные.ИдентификаторКвитанции);
		СоздатьКаталог(ПодкаталогСообщения);
		Данные.ПодкаталогСообщения = ПодкаталогСообщения;
		
		ПолноеИмяФайлаКонверта = ПодкаталогСообщения + "envelope.ini";
		
		// Адресат - наша организация, чтоб на стороне приема контрагент прочитал этот адрес:
		АдресОтправителяДляКонверта = "0=" + Данные.Организация.АдресМЭДО;
		Конверт = Новый ТекстовыйДокумент();
		Конверт.УстановитьТекст(СтрШаблон(
			"[ПИСЬМО КП ПС СЗИ]
			|АВТООТПРАВКА=1
			|[АДРЕСАТЫ]
			|%1
			|[ФАЙЛЫ]
			|0=acknowledgment.xml",
			АдресОтправителяДляКонверта));
		Конверт.Записать(ПолноеИмяФайлаКонверта, "windows-1251");
		
		ПолноеИмяФайлаСообщения = ПодкаталогСообщения + "acknowledgment.xml";
		Пакет = ПакетXDTOСообщенияПоВерсииМЭДО(ВерсияМЭДО);
		ТипCommunication = Пакет.КорневыеСвойства.Получить("communication").Тип;
		communication = ФабрикаXDTO.Создать(ТипCommunication);
		communication.version = "" + ВерсияМЭДО;
		communication.header = ФабрикаXDTO.Создать(ТипCommunication.Свойства.Получить("header").Тип);
		communication.header.type = "Квитанция";
		communication.header.uid = НРег(Данные.ИдентификаторКвитанции);
		communication.header.created = 
			?(ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271, ДатаФорматаDateTimeZone(Данные.Дата), Данные.Дата);
		communication.header.source = НовыйОбъектСообщения("communicationPartner", ВерсияМЭДО);
		communication.header.source.uid = НРег(Данные.Организация.Идентификатор);
		communication.header.source.organization = Данные.Организация.Наименование;
		
		communication.acknowledgment = ФабрикаXDTO.Создать(
			ТипCommunication.Свойства.Получить("acknowledgment").Тип);
		communication.acknowledgment.uid = НРег(Данные.ИдентификаторСообщения);
		communication.acknowledgment.time = 
			?(ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271, ДатаФорматаDateTimeZone(Данные.Дата), Данные.Дата);
		communication.acknowledgment.accepted = Истина;
		
		destination = НовыйОбъектСообщения("communicationPartner", ВерсияМЭДО);
		destination.uid = НРег(Данные.Контрагент.Идентификатор);
		destination.organization = Данные.Контрагент.Наименование;
		deliveryDestination = НовыйОбъектСообщения("deliveryDestination", ВерсияМЭДО);
		deliveryDestination.destination = destination;
		communication.deliveryIndex = ФабрикаXDTO.Создать(ТипCommunication.Свойства.Получить("deliveryIndex").Тип);
		communication.deliveryIndex.destination.Добавить(deliveryDestination);
		
		
		ЗаписьXML = Новый ЗаписьXML();
		ЗаписьXML.ОткрытьФайл(ПолноеИмяФайлаСообщения, "UTF-8");
		ЗаписьXML.ЗаписатьОбъявлениеXML();
		ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, communication, "communication", , , НазначениеТипаXML.Неявное);
		ЗаписьXML.Закрыть();
		
		КвитанцияОбъект = Квитанция.ПолучитьОбъект();
		КвитанцияОбъект.Отправлена = Истина;
		КвитанцияОбъект.ГотоваКОтправке = Ложь;
		ДвоичныеДанныеКонверта = Новый ДвоичныеДанные(ПолноеИмяФайлаКонверта);
		КвитанцияОбъект.ДанныеКонверта = Новый ХранилищеЗначения(ДвоичныеДанныеКонверта);
		ДвоичныеДанныеСообщения = Новый ДвоичныеДанные(ПолноеИмяФайлаСообщения);
		КвитанцияОбъект.ДанныеСообщения = Новый ХранилищеЗначения(ДвоичныеДанныеСообщения);
		КвитанцияОбъект.Записать();
		
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Информация,
			Квитанция,
			Текст_ОбъектОтправленУспешно(),
			Текст_ОбъектОтправленУспешно(),
			ДанныеОтвета);
		
	Исключение
		СтекОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			Квитанция,
			НСтр("ru = 'Ошибка создания исходящей квитанции'"),
			СтекОшибки,
			ДанныеОтвета);
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

#Область ИсходящиеДокументы

#Если Не ВнешнееСоединение Тогда

// Записать сообщение по исходящему документу в каталог отправки
// 
// Параметры:
//  Настройки - Структура - поля:
//   * Организация - ОпределяемыйТип.Организация
//   * КаталогОтправки - Строка
//  ИсходящийДокумент - ОпределяемыйТип.ПредметМЭДО
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
//
// Возвращаемое значение:
//   Булево - Успешно или нет.
Функция ОтправитьИсходящийДокумент(Настройки, ИсходящийДокумент, ДанныеОтвета)
	
	УстановитьПривилегированныйРежим(Истина);
	
	НачатьТранзакцию();
	Попытка
	
		ДанныеДокумента = МЭДОПереопределяемый.ДанныеИсходящегоДокументаДляОтправки(
			Настройки, ИсходящийДокумент, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
		КонецЕсли;
		
		// Если получатели имеют поддержку разных версий МЭДО, то искусственно делим отправляемое сообщение на несколько
		// сообщений, каждое с получателями своей версии:
		Для Каждого Пакет Из ДанныеДокумента.Пакеты Цикл
			
			ЗаполнитьЗначенияСвойств(ДанныеДокумента.ТекущийПакет, Пакет);
			
			ЕстьПолучателиТекущейВерсии = Ложь;
			Для Каждого Получатель Из ДанныеДокумента.Получатели Цикл
				Если Получатель.Контрагент.ВерсияМЭДО = Пакет.ВерсияМЭДО Тогда
					ЕстьПолучателиТекущейВерсии = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не ЕстьПолучателиТекущейВерсии Тогда
				Продолжить;
			КонецЕсли;
			
			ЗаписатьСодержимоеКонтейнераИсходящегоДокумента(ДанныеДокумента, ДанныеОтвета);
			Если Не ДанныеОтвета.Успех Тогда
				ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
			КонецЕсли;
			
			ЗаписатьСообщениеПоИсходящемуДокументу(ДанныеДокумента, ДанныеОтвета);
			Если Не ДанныеОтвета.Успех Тогда
				Если ЗначениеЗаполнено(ДанныеДокумента.ПодкаталогСообщения) Тогда
					УдалитьФайлы(ДанныеДокумента.ПодкаталогСообщения);
				КонецЕсли;
				Если ЗначениеЗаполнено(ДанныеДокумента.ВременныйКаталог) Тогда
					УдалитьФайлы(ДанныеДокумента.ВременныйКаталог);
				КонецЕсли;
				
				ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
			КонецЕсли;
			
		КонецЦикла;
		
		МЭДОПереопределяемый.УстановитьПризнакОтправленностиИсходящегоДокумента(ДанныеДокумента.Документ);
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		
		// Пишем в журнал только если ошибка не обработана во вложенных процедурах, вложенные сами пишут в журнал.
		Если ДанныеОтвета.Успех Тогда
			ТекстОшибкиПодробно = СтрШаблон(
				"Документ %1
				|%2",
				ИсходящийДокумент, ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка, ИсходящийДокумент,
				Текст_ОшибкаВДокументе(), ТекстОшибкиПодробно, ДанныеОтвета);
			
			
			Документы.ДанныеДокументаМЭДО.СнятьПризнакГотовКОтправке(
				ИсходящийДокумент, МЭДОСтруктурыДанных.НовыйЛегкийОтвет());
		КонецЕсли;
	КонецПопытки;
	
	Возврат ДанныеОтвета.Успех;
	
КонецФункции

// Процедура - Записывает во временные файлы содержимое контейнера исходящего документа.
// 
// Параметры:
//  Данные			- см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоДокументаДляОтправки.
//  ДанныеОтвета	- см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ЗаписатьСодержимоеКонтейнераИсходящегоДокумента(Данные, ДанныеОтвета)
	
	//@skip-check missing-temporary-file-deletion
	ВременныйКаталог = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ПолучитьИмяВременногоФайла());
	// Каталог будет удален уже на последнем этапе, в конце, см. ЗаписатьСообщениеПоИсходящемуДокументу
	
	СоздатьКаталог(ВременныйКаталог);
	Данные.ВременныйКаталог = ВременныйКаталог;
	ОбъединяемыеФайлы = Новый СписокЗначений();
	
	// Паспорт контейнера (passport.xml).
	ФайлПаспортаКонтейнера = ВременныйКаталог + ИмяФайлаPassportXml();
	СоздатьПаспортКонтейнераИсходящегоДокумента(Данные, ФайлПаспортаКонтейнера, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
	КонецЕсли;
	ОбъединяемыеФайлы.Добавить(ФайлПаспортаКонтейнера, "");
	
	// Файл документа (pdf).
	ФайлДокумента = ВременныйКаталог + Данные.Файл.ЛокальноеИмя;
	Данные.Файл.ДвоичныеДанные.Записать(ФайлДокумента);
	ОбъединяемыеФайлы.Добавить(ФайлДокумента, Данные.Файл.ЛокальноеИмя);
	
	// Регистрационный штамп (png).
	ПолноеИмяФайлаРегШтампа = ВременныйКаталог + Данные.Отправитель.РегистрационныйШтамп.Файл.ЛокальноеИмя;
	Данные.Отправитель.РегистрационныйШтамп.Файл.ДвоичныеДанные.Записать(ПолноеИмяФайлаРегШтампа);
	ОбъединяемыеФайлы.Добавить(ПолноеИмяФайлаРегШтампа, Данные.Отправитель.РегистрационныйШтамп.Файл.ЛокальноеИмя);
	
	Для Каждого Подпись Из Данные.Отправитель.Подписи Цикл
		// Сама подпись (p7s).
		ПолноеИмяФайлаПодписи = ВременныйКаталог + Подпись.Файл.ЛокальноеИмя;
		Подпись.Файл.ДвоичныеДанные.Записать(ПолноеИмяФайлаПодписи);
		ОбъединяемыеФайлы.Добавить(ПолноеИмяФайлаПодписи, Подпись.Файл.ЛокальноеИмя);
		
		// Отметка подписи (png).
		ФайлОтметкиПодписи = ВременныйКаталог + Подпись.ОтметкаЭП.Файл.ЛокальноеИмя;
		Подпись.ОтметкаЭП.Файл.ДвоичныеДанные.Записать(ФайлОтметкиПодписи);
		ОбъединяемыеФайлы.Добавить(ФайлОтметкиПодписи, Подпись.ОтметкаЭП.Файл.ЛокальноеИмя);
	КонецЦикла;
	
	// Приложения, если они есть.
	Для Каждого Приложение Из Данные.Приложения Цикл
		Если ТипЗнч(Приложение.Файл.ДвоичныеДанные) <> Тип("ДвоичныеДанные") Тогда
			Продолжить;
		КонецЕсли;
			
		ПолноеИмяФайлаПриложения = ВременныйКаталог + Приложение.Файл.ЛокальноеИмя;
		Приложение.Файл.ДвоичныеДанные.Записать(ПолноеИмяФайлаПриложения);
		ОбъединяемыеФайлы.Добавить(ПолноеИмяФайлаПриложения, Приложение.Файл.ЛокальноеИмя);
		
		Для Каждого Подпись Из Приложение.Подписи Цикл
			Если ТипЗнч(Подпись.Файл.ДвоичныеДанные) <> Тип("ДвоичныеДанные") Тогда
				Продолжить;
			КонецЕсли;
			
			// Сама подпись (p7s):
			ПолноеИмяФайлаПодписи = ВременныйКаталог + Подпись.Файл.ЛокальноеИмя;
			Подпись.Файл.ДвоичныеДанные.Записать(ПолноеИмяФайлаПодписи);
			ОбъединяемыеФайлы.Добавить(ПолноеИмяФайлаПодписи);
			
			// Отметка подписи (png) - нет возможности поместить, нет поля в схеме xsd.
		КонецЦикла;
	КонецЦикла;
	
	
	ОбъединяемыеФайлы.СортироватьПоПредставлению();
	ОбъединяемыеФайлыМассив = ОбъединяемыеФайлы.ВыгрузитьЗначения();
	Данные.СодержимоеКонтейнера.ЛокальноеИмя = "container.bin";
	ИмяРезультирующегоФайла = ВременныйКаталог + Данные.СодержимоеКонтейнера.ЛокальноеИмя;
	ОбъединитьФайлы(ОбъединяемыеФайлыМассив, ИмяРезультирующегоФайла);
	Данные.СодержимоеКонтейнера.ДвоичныеДанные = Новый ДвоичныеДанные(ИмяРезультирующегоФайла);

КонецПроцедуры

#КонецЕсли

// Процедура - Создает и записывает паспорт контейнера исходящего документа.
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоДокументаДляОтправки.
//  ПолноеИмяФайла - Строка - Путь к xml-файлу - паспорту контейнера. 
//                            На выходе по этому пути будет создан сам файл (passport.xml)
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура СоздатьПаспортКонтейнераИсходящегоДокумента(Данные, ПолноеИмяФайла, ДанныеОтвета)
	
	ВерсияМЭДО = Данные.ТекущийПакет.ВерсияМЭДО;
	
	Пакет = ПакетXDTOКонтейнераПоВерсииМЭДО(ВерсияМЭДО);
	ТипContainer = Пакет.КорневыеСвойства.Получить("container").Тип;
	container = ФабрикаXDTO.Создать(ТипContainer);
	
	container.version = ВерсияПаспортаПоВерсииМЭДО(ВерсияМЭДО);
	container.uid = Данные.ИдентификаторДокумента;
	
	// Вид документа МЭДО
	container.requisites = ФабрикаXDTO.Создать(ТипContainer.Свойства.Получить("requisites").Тип);
	container.requisites.documentKind = НовыйОбъектКонтейнера("qualifiedValue", ВерсияМЭДО);
	container.requisites.documentKind.id = "" + Данные.ВидДокумента.Идентификатор;
	container.requisites.documentKind.__content = Данные.ВидДокумента.Наименование;
	
	
	// Место составления:
	Если ЗначениеЗаполнено(Данные.МестоСоставления.Наименование) Тогда
		container.requisites.documentPlace = НовыйОбъектКонтейнера("qualifiedValue", ВерсияМЭДО);
		container.requisites.documentPlace.id = Данные.МестоСоставления.Идентификатор;
		container.requisites.documentPlace.__content = Данные.МестоСоставления.Наименование;
	Иначе
		// Место составления для 2.7.1 - обязательное, для 2.7 - не обязательное.
		Если ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				Данные.Документ,
				Текст_ОшибкаВДокументе(),
				НСтр("ru = 'В документе не указано место составления, это обязательное поле.'"),
				ДанныеОтвета);
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	
	// Гриф доступа:
	Если ЗначениеЗаполнено(Данные.ГрифДоступа.Наименование) Тогда
		container.requisites.classification = НовыйОбъектКонтейнера("qualifiedValue", ВерсияМЭДО);
		container.requisites.classification.__content = Данные.ГрифДоступа.Наименование;
		Если ЗначениеЗаполнено(Данные.ГрифДоступа.Идентификатор) Тогда
			container.requisites.classification.id = Данные.ГрифДоступа.Идентификатор;
		Иначе
			Если ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
				ТекстОшибкиПодробно =
					НСтр("ru = 'Для отправки документа по формату версии МЭДО 2.7.1 должен быть задан гриф доступа и в документе и в настройках'");
				ЗаписьВЖурналСобытий(
					Перечисления.УровниСобытийМЭДО.Ошибка,
					Данные.Документ,
					Текст_ОшибкаВДокументе(),
					ТекстОшибкиПодробно,
					ДанныеОтвета);
				Возврат;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	
	Заголовок = СтрЗаменить(Данные.Заголовок, """", "");
	Заголовок = СтрЗаменить(Заголовок, "'", "");
	container.requisites.annotation = Заголовок;
	
	
	container.document = ФабрикаXDTO.Создать(ТипContainer.Свойства.Получить("document").Тип);
	container.document.localName = Данные.Файл.ЛокальноеИмя;
	container.document.description = Данные.Содержание;
	container.document.pagesQuantity = Данные.КоличествоЛистов;
	
	
	// Отправитель:
	container.authors = ФабрикаXDTO.Создать(ТипContainer.Свойства.Получить("authors").Тип);
	issuer = НовыйОбъектКонтейнера("issuer", ВерсияМЭДО);
	issuer.organization = НовыйОбъектКонтейнера("organization", ВерсияМЭДО);
	issuer.organization.id = Данные.Отправитель.Организация.Идентификатор;
	issuer.organization.title = Данные.Отправитель.Организация.Наименование;
	issuer.registration = НовыйОбъектКонтейнера("registration", ВерсияМЭДО);
	issuer.registration.number = Данные.Отправитель.РегистрационныйНомер;
	Если ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
		issuer.registration.date = Формат(Данные.Отправитель.ДатаРегистрации, "ДФ=yyyy-MM-dd;");
	Иначе
		issuer.registration.date = Данные.Отправитель.ДатаРегистрации;
	КонецЕсли;
	
	issuer.registration.registrationStamp = НовыйОбъектКонтейнера("stamp", ВерсияМЭДО);
	РегистрационныйШтамп = Данные.Отправитель.РегистрационныйШтамп;
	
	СтраницаРегШтампа = 1;
	Если ТипЗнч(РегистрационныйШтамп.Положение.Страница) = Тип("Число")
		И РегистрационныйШтамп.Положение.Страница <> 0 Тогда
		СтраницаРегШтампа = РегистрационныйШтамп.Положение.Страница;
	ИначеЕсли РегистрационныйШтамп.Положение.Страница = Перечисления.СтраницаВставкиКартинки.Последняя Тогда
		СтраницаРегШтампа = Данные.КоличествоЛистов;
	КонецЕсли;
	
	issuer.registration.registrationStamp.localName = РегистрационныйШтамп.Файл.ЛокальноеИмя;
	position = НовыйОбъектКонтейнера("position", ВерсияМЭДО);
	position.page = СтраницаРегШтампа;
	position.topLeft = НовыйОбъектКонтейнера("coordinate", ВерсияМЭДО);
	position.topLeft.x = РегистрационныйШтамп.Положение.Слева;
	position.topLeft.y = РегистрационныйШтамп.Положение.Сверху;
	position.dimension = НовыйОбъектКонтейнера("dimension", ВерсияМЭДО);
	position.dimension.w = РегистрационныйШтамп.Положение.Ширина;
	position.dimension.h = РегистрационныйШтамп.Положение.Высота;
	issuer.registration.registrationStamp.position = position;
	
	ТипSign = issuer.Свойства().Получить("sign").Тип;
	Для Каждого Подпись Из Данные.Отправитель.Подписи Цикл
		
		// "Подпись" одна, но при настройке "Каждая" она превращается в много:
		НачальнаяСтраница = Подпись.ОтметкаЭП.Положение.Страница; // Число, ПеречислениеСсылка.СтраницаВставкиКартинки
		КонечнаяСтраница = Подпись.ОтметкаЭП.Положение.Страница; // Число, ПеречислениеСсылка.СтраницаВставкиКартинки
		Если Подпись.ОтметкаЭП.Положение.Страница = Перечисления.СтраницаВставкиКартинки.Первая Тогда
			// Перестраховка, в Данные уже будет лежать в данном случае Число 1, а не ПеречислениеСсылка:
			НачальнаяСтраница = 1;
			КонечнаяСтраница = 1;
		ИначеЕсли Подпись.ОтметкаЭП.Положение.Страница = Перечисления.СтраницаВставкиКартинки.Последняя Тогда
			// Перестраховка, в Данные уже будет лежать в данном случае Число = КоличествоЛистов, а не ПеречислениеСсылка:
			НачальнаяСтраница = Данные.КоличествоЛистов;
			КонечнаяСтраница = Данные.КоличествоЛистов;
		ИначеЕсли Подпись.ОтметкаЭП.Положение.Страница = Перечисления.СтраницаВставкиКартинки.Каждая Тогда
			НачальнаяСтраница = 1;
			КонечнаяСтраница = Данные.КоличествоЛистов;
		КонецЕсли;
		
		Для ТекущийНомерСтраницы = НачальнаяСтраница По КонечнаяСтраница Цикл
			sign = ФабрикаXDTO.Создать(ТипSign);
			sign.person = НовыйОбъектКонтейнера("signer", ВерсияМЭДО);
			sign.person.name = Подпись.Подписал.ФИО;
			ПрисвоитьЗаполненное(sign.person.post, Подпись.Подписал.Должность.Наименование);
			ПрисвоитьЗаполненное(sign.person.email, Подпись.Подписал.ЭлектроннаяПочта);
			ПрисвоитьЗаполненное(sign.person.id, Подпись.Подписал.Идентификатор);
			ПрисвоитьЗаполненное(sign.person.phone, Подпись.Подписал.Телефон);
			sign.documentSignature = НовыйОбъектКонтейнера("signatureInfo", ВерсияМЭДО);
			sign.documentSignature.localname = Подпись.Файл.ЛокальноеИмя;
			sign.documentSignature.signatureStamp = НовыйОбъектКонтейнера("stamp", ВерсияМЭДО);
			position = НовыйОбъектКонтейнера("position", ВерсияМЭДО);
			position.page = ТекущийНомерСтраницы;
			position.topLeft = НовыйОбъектКонтейнера("coordinate", ВерсияМЭДО);
			position.topLeft.x = Подпись.ОтметкаЭП.Положение.Слева;
			position.topLeft.y = Подпись.ОтметкаЭП.Положение.Сверху;
			position.dimension = НовыйОбъектКонтейнера("dimension", ВерсияМЭДО);
			position.dimension.w = Подпись.ОтметкаЭП.Положение.Ширина;
			position.dimension.h = Подпись.ОтметкаЭП.Положение.Высота;
			sign.documentSignature.signatureStamp.position = position;
			sign.documentSignature.signatureStamp.localName = Подпись.ОтметкаЭП.Файл.ЛокальноеИмя;
			issuer.sign.Добавить(sign);
		КонецЦикла;
	КонецЦикла;
	// Исполнитель:
	Если ЗначениеЗаполнено(Данные.Отправитель.Исполнитель.ФИО) Тогда
		issuer.executor = НовыйОбъектКонтейнера("executor", ВерсияМЭДО);
		issuer.executor.name = Данные.Отправитель.Исполнитель.ФИО;
		ПрисвоитьЗаполненное(issuer.executor.post, Данные.Отправитель.Исполнитель.Должность.Наименование);
		ПрисвоитьЗаполненное(issuer.executor.phone, Данные.Отправитель.Исполнитель.Телефон);
	Иначе
		Если ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				Данные.Документ,
				Текст_ОшибкаВДокументе(),
				НСтр("ru = 'В документе не указан исполнитель, для формата 2.7.1 это обязательное поле.'"),
				ДанныеОтвета);
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	container.authors.author.Добавить(issuer);
	
	
	// Получатели:
	ТипAddressees = ТипContainer.Свойства.Получить("addressees").Тип;
	container.addressees = ФабрикаXDTO.Создать(ТипAddressees);
	ТипAddressee = ТипAddressees.Свойства.Получить("addressee").Тип;
	Для Каждого Получатель Из Данные.Получатели Цикл
		Если Получатель.Контрагент.ВерсияМЭДО <> ВерсияМЭДО Тогда
			Продолжить; // Пропускаем получателей с другой версией.
		КонецЕсли;
		
		addressee = ФабрикаXDTO.Создать(ТипAddressee);
		addressee.organization = НовыйОбъектКонтейнера("organization", ВерсияМЭДО);
		addressee.organization.id = Получатель.Контрагент.Идентификатор;
		addressee.organization.title = Получатель.Контрагент.Наименование;
		Если ЗначениеЗаполнено(Получатель.КонтактноеЛицо.ФИО) Тогда
			person = НовыйОбъектКонтейнера("person", ВерсияМЭДО);
			person.name = Получатель.КонтактноеЛицо.ФИО;
			ПрисвоитьЗаполненное(person.id, Получатель.КонтактноеЛицо.Идентификатор);
			ПрисвоитьЗаполненное(person.post, Получатель.КонтактноеЛицо.Должность.Наименование);
			ПрисвоитьЗаполненное(person.phone, Получатель.КонтактноеЛицо.Телефон);
			ПрисвоитьЗаполненное(person.email, Получатель.КонтактноеЛицо.ЭлектроннаяПочта);
			addressee.person.Добавить(person);
		КонецЕсли;
		container.addressees.addressee.Добавить(addressee);
	КонецЦикла;
	
	
	Если Данные.ПодписьКонтейнера.ДвоичныеДанные <> Неопределено Тогда
		container.containerSignature = ФабрикаXDTO.Создать(ТипContainer.Свойства.Получить("containerSignature").Тип);
		container.containerSignature.localName = "signature.p7s";
	КонецЕсли;
	
	
	// Приложения:
	Если Данные.Приложения.Количество() > 0 Тогда
		ТипAttachments = ТипContainer.Свойства.Получить("attachments").Тип;
		container.attachments = ФабрикаXDTO.Создать(ТипAttachments);
		ТипAttachment = ТипAttachments.Свойства.Получить("attachment").Тип;		
		ПорядковыйНомер = 0;
		Для Каждого Приложение Из Данные.Приложения Цикл
			attachment = ФабрикаXDTO.Создать(ТипAttachment);
			attachment.localName = Приложение.Файл.ЛокальноеИмя;
			ПорядковыйНомер = ПорядковыйНомер + 1;
			attachment.order = ПорядковыйНомер;
			
			// Подписи приложений, если есть:
			Если Приложение.Подписи.Количество() > 0 Тогда
				Для Каждого Подпись Из Приложение.Подписи Цикл
					Если ТипЗнч(Подпись.Файл.ДвоичныеДанные) <> Тип("ДвоичныеДанные") Тогда
						Продолжить;
					КонецЕсли;
					
					ТипSignature = ТипAttachment.Свойства.Получить("signature").Тип;
					signature = ФабрикаXDTO.Создать(ТипSignature);
					signature.localName = Подпись.Файл.ЛокальноеИмя;
					
					// Отметку к сожалению нельзя поместить - нет поля в схеме xsd.
					
					attachment.signature.Добавить(signature);
				КонецЦикла;
			КонецЕсли;
			
			container.attachments.attachment.Добавить(attachment);
		КонецЦикла;
	КонецЕсли;
	
	
	ЗаписьXML = Новый ЗаписьXML();
	ЗаписьXML.ОткрытьФайл(ПолноеИмяФайла, "UTF-8");
	ЗаписьXML.ЗаписатьОбъявлениеXML();
	ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, container, "container", , , НазначениеТипаXML.Неявное);
	ЗаписьXML.Закрыть();
	
КонецПроцедуры

// Создает и записывает сообщение по исходящему документу.
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоДокументаДляОтправки.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ЗаписатьСообщениеПоИсходящемуДокументу(Данные, ДанныеОтвета)
	
	ВерсияМЭДО = Данные.ТекущийПакет.ВерсияМЭДО;
	ИдентификаторСообщения = Данные.ТекущийПакет.ИдентификаторСообщения;
	
	ЕстьКонтейнер = (ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия27
		Или ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271);
	
	ПодкаталогСообщения = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(
		ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(Данные.НастройкиОрганизации.КаталогОтправки)
		+ ИдентификаторСообщения);
	СоздатьКаталог(ПодкаталогСообщения);
	Данные.ПодкаталогСообщения = ПодкаталогСообщения;
	
	// В 2.5 нет контейнера, в новых версиях есть:
	ФайлыСтрокой = "";
	Если ЕстьКонтейнер Тогда
		ПолноеИмяФайлаКонтейнера = ПодкаталогСообщения + "document.edc.zip";
		ДвоичныеДанные = ДвоичныеДанныеКонтейнераИсходящегоДокумента(Данные);
		ДвоичныеДанные.Записать(ПолноеИмяФайлаКонтейнера);
		ФайлыСтрокой = 
			"0=document.edc.zip
			|1=document.xml";
	Иначе
		ФайлыСтрокой = СтрШаблон(
			"0=document.xml
			|1=%1", Данные.Файл.ЛокальноеИмя);
		НомерФайла = 1;
		ПереместитьФайл(
			Данные.ВременныйКаталог + Данные.Файл.ЛокальноеИмя, ПодкаталогСообщения + Данные.Файл.ЛокальноеИмя);
		Для Каждого Приложение Из Данные.Приложения Цикл
			НомерФайла = НомерФайла + 1;
			ФайлыСтрокой = ФайлыСтрокой + Символы.ПС
				+ СтрШаблон("%1=%2", Формат(НомерФайла, "ЧН=0; ЧГ=0"), Приложение.Файл.ЛокальноеИмя);
			ПереместитьФайл(
				Данные.ВременныйКаталог + Приложение.Файл.ЛокальноеИмя,
				ПодкаталогСообщения + Приложение.Файл.ЛокальноеИмя);
		КонецЦикла;
	КонецЕсли;
	
	Данные.Заголовок = СтрЗаменить(Данные.Заголовок, """", "");
	Данные.Заголовок = СтрЗаменить(Данные.Заголовок, "'", "");
	
	// Адресат - наша организация, чтоб на стороне приема контрагент прочитал этот адрес:
	АдресОтправителяДляКонверта = "0=" + Данные.Отправитель.Организация.АдресМЭДО;
	ПолноеИмяФайлаКонверта = ПодкаталогСообщения + "envelope.ini";
	Конверт = Новый ТекстовыйДокумент;
	Конверт.УстановитьТекст(СтрШаблон(
		"[ПИСЬМО КП ПС СЗИ]
		|ТЕМА=%1
		|АВТООТПРАВКА=1
		|[АДРЕСАТЫ]
		|%2
		|[ФАЙЛЫ]
		|%3",
		Данные.Заголовок, АдресОтправителяДляКонверта, ФайлыСтрокой));
	Конверт.Записать(ПолноеИмяФайлаКонверта, "windows-1251");
	
	ПолноеИмяФайлаСообщения = ПодкаталогСообщения + "document.xml";
	Пакет = ПакетXDTOСообщенияПоВерсииМЭДО(ВерсияМЭДО);
	ТипCommunication = Пакет.КорневыеСвойства.Получить("communication").Тип;
	communication = ФабрикаXDTO.Создать(ТипCommunication);
	
	communication.version = "" + ВерсияМЭДО;
	
	communication.header = ФабрикаXDTO.Создать(ТипCommunication.Свойства.Получить("header").Тип);
	communication.header.type = ?(ЕстьКонтейнер, "Транспортный контейнер", "Документ");
	communication.header.uid = НРег(ИдентификаторСообщения);
	communication.header.source = НовыйОбъектСообщения("communicationPartner", ВерсияМЭДО);
	communication.header.source.uid = НРег(Данные.Отправитель.Организация.Идентификатор);
	communication.header.source.organization = Данные.Отправитель.Организация.Наименование;
	
	Если ЕстьКонтейнер Тогда
		communication.container = НовыйОбъектСообщения("documentContainer", ВерсияМЭДО);
		communication.container.body = "document.edc.zip";
	КонецЕсли;
	
	Если ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
		communication.header.created = ДатаФорматаDateTimeZone(Данные.ДатаУчетаДокумента);
	Иначе
		communication.header.created = Данные.ДатаУчетаДокумента;
		
		// В 2.5 все данные документа берутся из пакета сообщения. В 2.7 так тоже возможно, но есть и второй 
		// пакет контейнер, внутри.
		document = НовыйОбъектСообщения("document", ВерсияМЭДО); // Есть только в схеме 2.7.
		document.uid = НРег(Данные.ИдентификаторДокумента);
		
		Данные.Заголовок = СтрЗаменить(Данные.Заголовок, """", "");
		Данные.Заголовок = СтрЗаменить(Данные.Заголовок, "'", "");
		document.annotation = Данные.Заголовок;
		document.pages = Данные.КоличествоЛистов;
		
		num = НовыйОбъектСообщения("documentNumber", ВерсияМЭДО);
		num.number = Данные.Отправитель.РегистрационныйНомер;
		num.date = Данные.Отправитель.ДатаРегистрации;
		document.num = num;
		
		ПрисвоитьЗаполненное(document.comment, Данные.Содержание);
		
		signatory = НовыйОбъектСообщения("signatory", ВерсияМЭДО);
		// в 2.5 учитываем только первого подписавшего:
		ДатаПодписи = Неопределено;
		Если Данные.Отправитель.Подписи.Количество() > 0 Тогда
			ДатаПодписи = Данные.Отправитель.Подписи[0].ДатаПодписания;
		КонецЕсли;
		Если Не ЗначениеЗаполнено(ДатаПодписи) Тогда
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				Данные.Документ,
				Текст_ОшибкаВДокументе(),
				НСтр("ru = 'В подписях отправителя не обнаружена дата, либо вообще нет подписей'"),
				ДанныеОтвета);
			ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
		КонецЕсли;
		signatory.signed = ДатаПодписи;
		ОтветственнаяСтруктурнаяЕдиница = МЭДОСтруктурыДанных.НовыйОтветственнаяСтруктурнаяЕдиница();
		ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
			ОтветственнаяСтруктурнаяЕдиница,
			Данные.Отправитель.Организация.ОрганизацияСсылка,
			Данные.Отправитель.Исполнитель.КонтактноеЛицоСсылка,
			Данные.ДатаУчетаДокумента,
			Данные.НастройкиОрганизации);
		ЗаполнитьAnyone(signatory, ОтветственнаяСтруктурнаяЕдиница, ВерсияМЭДО);
		document.signatories = ФабрикаXDTO.Создать(document.Тип().Свойства.Получить("signatories").Тип);
		document.signatories.signatory.Добавить(signatory);
		
		document.addressees = ФабрикаXDTO.Создать(document.Тип().Свойства.Получить("addressees").Тип);
		Для Каждого Получатель Из Данные.Получатели Цикл
			Если Получатель.Контрагент.ВерсияМЭДО <> ВерсияМЭДО Тогда
				Продолжить; // Пропускаем получателей с другой версией.
			КонецЕсли;
			
			addressee = НовыйОбъектСообщения("addressee", ВерсияМЭДО);
			ОтветственнаяСтруктурнаяЕдиница = МЭДОСтруктурыДанных.НовыйОтветственнаяСтруктурнаяЕдиница();
			ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
				ОтветственнаяСтруктурнаяЕдиница, 
				Получатель.Контрагент.КонтрагентСсылка,
				Получатель.КонтактноеЛицо.КонтактноеЛицоСсылка,
				Данные.ДатаУчетаДокумента,
				Данные.НастройкиОрганизации);
			ЗаполнитьAnyone(addressee, ОтветственнаяСтруктурнаяЕдиница, ВерсияМЭДО);
			document.addressees.addressee.Добавить(addressee);
		КонецЦикла;
		communication.document = document;
		
		
		// Файлы добавляем только для формата 2.5 - тут единственное место, где можно добавить файлы,
		// контейнера внутри нет.
		Если ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия25
			И ЗначениеЗаполнено(Данные.Файл.ЛокальноеИмя) Тогда
			communication.files = ФабрикаXDTO.Создать(ТипCommunication.Свойства.Получить("files").Тип);
			file1 = НовыйОбъектСообщения("associatedFile", ВерсияМЭДО);
			file1.localName = Данные.Файл.ЛокальноеИмя;
			file1.group = "Текст документа";
			communication.files.file.Добавить(file1);
			Для Каждого Приложение Из Данные.Приложения Цикл
				file1 = НовыйОбъектСообщения("associatedFile", ВерсияМЭДО);
				file1.localName = Приложение.Файл.ЛокальноеИмя;
				file1.group = "Текст приложения";
				communication.files.file.Добавить(file1);
			КонецЦикла;
		КонецЕсли;
		
	КонецЕсли;
	
	communication.deliveryIndex = ФабрикаXDTO.Создать(ТипCommunication.Свойства.Получить("deliveryIndex").Тип);
	Для Каждого Получатель Из Данные.Получатели Цикл
		Если Получатель.Контрагент.ВерсияМЭДО <> ВерсияМЭДО Тогда
			Продолжить; // Пропускаем получателей с другой версией.
		КонецЕсли;
		
		destination = НовыйОбъектСообщения("communicationPartner", ВерсияМЭДО);
		destination.uid = НРег(Получатель.Контрагент.Идентификатор);
		destination.organization = Получатель.Контрагент.Наименование;
		deliveryDestination = НовыйОбъектСообщения("deliveryDestination", ВерсияМЭДО);
		deliveryDestination.destination = destination;
		communication.deliveryIndex.destination.Добавить(deliveryDestination);
	КонецЦикла;
	
	ЗаписьXML = Новый ЗаписьXML();
	ЗаписьXML.ОткрытьФайл(ПолноеИмяФайлаСообщения, "UTF-8");
	ЗаписьXML.ЗаписатьОбъявлениеXML();
	ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, communication, "communication", , , НазначениеТипаXML.Неявное);
	ЗаписьXML.Закрыть();
	
	УдалитьФайлы(Данные.ВременныйКаталог);
	
	
	// Данные для вспомогательного документа "Данные документа МЭДО".
	// Итоговую папку к отправке подкладываем для хранения истории к исходному документу. Для расследования ошибок:
	ЗаписьZip = Новый ЗаписьZipФайла();
	ЗаписьZip.Добавить(ПодкаталогСообщения);
	Если ДанныеОтвета.Свойство("Файл") Тогда
		ДанныеОтвета.Файл.ЛокальноеИмя = СтрШаблон("%1.zip", ИдентификаторСообщения);
		ДанныеОтвета.Файл.ДвоичныеДанные = ЗаписьZip.ПолучитьДвоичныеДанные();
	КонецЕсли;
	Данные.Отправлен = Истина;
	Данные.ГотовКОтправке = Ложь;
	ЗаписатьДанныеИсходящегоДокументаМЭДО(Данные.Документ, Данные, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
	КонецЕсли;
	
	
	ЗаписьВЖурналСобытий(
		Перечисления.УровниСобытийМЭДО.Информация,
		Данные.Документ,
		Текст_ОбъектОтправленУспешно(),
		Текст_ОбъектОтправленУспешно(),
		ДанныеОтвета);
	
КонецПроцедуры

// Функция - Возвращает двоичные данные zip-архива - контейнера исходящего документа
//
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоДокументаДляОтправки.
// 
// Возвращаемое значение:
//  ДвоичныеДанные - 
//
Функция ДвоичныеДанныеКонтейнераИсходящегоДокумента(Данные)
	
	ФайлыКУдалению = Новый Массив;
	ЗаписьZip = Новый ЗаписьZipФайла();
	
	ИмяФайла = Данные.ВременныйКаталог + ИмяФайлаPassportXml();
	ЗаписьZip.Добавить(ИмяФайла);
	ФайлыКУдалению.Добавить(ИмяФайла);
	
	ИмяФайла = Данные.ВременныйКаталог + Данные.Файл.ЛокальноеИмя;
	ЗаписьZip.Добавить(ИмяФайла);
	ФайлыКУдалению.Добавить(ИмяФайла);
	
	ИмяФайла = Данные.ВременныйКаталог + Данные.Отправитель.РегистрационныйШтамп.Файл.ЛокальноеИмя;
	ЗаписьZip.Добавить(ИмяФайла);
	ФайлыКУдалению.Добавить(ИмяФайла);
	
	Для Каждого Подпись Из Данные.Отправитель.Подписи Цикл
		
		ИмяФайла = Данные.ВременныйКаталог + Подпись.Файл.ЛокальноеИмя;
		ЗаписьZip.Добавить(ИмяФайла);
		ФайлыКУдалению.Добавить(ИмяФайла);
		
		ИмяФайла = Данные.ВременныйКаталог + Подпись.ОтметкаЭП.Файл.ЛокальноеИмя;
		ЗаписьZip.Добавить(ИмяФайла);
		ФайлыКУдалению.Добавить(ИмяФайла);
		
	КонецЦикла;
	
	// Подписывание при отправке может быть отключено.
	Если Данные.ПодписьКонтейнера.ДвоичныеДанные <> Неопределено Тогда
		ИмяФайла = Данные.ВременныйКаталог + Данные.ПодписьКонтейнера.ЛокальноеИмя;
		ЗаписьZip.Добавить(ИмяФайла);
		ФайлыКУдалению.Добавить(ИмяФайла);
	КонецЕсли;
	
	
	Для Каждого Приложение Из Данные.Приложения Цикл
		ИмяФайла = Данные.ВременныйКаталог + Приложение.Файл.ЛокальноеИмя;
		ЗаписьZip.Добавить(ИмяФайла);
		ФайлыКУдалению.Добавить(ИмяФайла);
		
		Для Каждого Подпись Из Приложение.Подписи Цикл
			Если ТипЗнч(Подпись.Файл.ДвоичныеДанные) <> Тип("ДвоичныеДанные") Тогда
				Продолжить;
			КонецЕсли;
			
			ИмяФайла = Данные.ВременныйКаталог + Подпись.Файл.ЛокальноеИмя;
			ЗаписьZip.Добавить(ИмяФайла);
			ФайлыКУдалению.Добавить(ИмяФайла);
		КонецЦикла;
	КонецЦикла;
	
	
	ИмяФайла = Данные.ВременныйКаталог + Данные.СодержимоеКонтейнера.ЛокальноеИмя; // не архивируем
	ФайлыКУдалению.Добавить(ИмяФайла);
	
	ДвоичныеДанныеКонтейнера = ЗаписьZip.ПолучитьДвоичныеДанные();
	
	Для Каждого ФайлКУдалению Из ФайлыКУдалению Цикл
		УдалитьФайлы(ФайлКУдалению);
	КонецЦикла;
	
	Возврат ДвоичныеДанныеКонтейнера;
	
КонецФункции

// Вспомогательный документ "Данные документа МЭДО" для хранения дополнительных данных МЭДО,
// отсутствующих в основном документе
// 
// Параметры:
//  Документ - ОпределяемыйТип.ПредметМЭДО
//  ДанныеДокумента - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоДокументаДляОтправки.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ЗаписатьДанныеИсходящегоДокументаМЭДО(Документ, ДанныеДокумента, ДанныеОтвета)
	
	ДанныеОбъект = Документы.ДанныеДокументаМЭДО.ОбъектДанныхДокумента(Документ, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(
		ДанныеОбъект, ДанныеДокумента,
		"ИдентификаторДокумента, Отправлен, ГотовКОтправке");
	ДанныеОбъект.ВидДокумента = ДанныеДокумента.ВидДокументаСсылка;
	ДанныеОбъект.ГлавныйФайл = ДанныеДокумента.ГлавныйФайлСсылка;
	ДанныеОбъект.ГрифДоступа = ДанныеДокумента.ГрифДоступаСсылка;
	ДанныеОбъект.МестоСоставления = ДанныеДокумента.МестоСоставленияСсылка;
	ДанныеОбъект.Направление = Перечисления.НаправленияСообщенийМЭДО.Исходящее;
	ДанныеОбъект.Организация = ДанныеДокумента.Отправитель.Организация.ОрганизацияСсылка;
	ДанныеОбъект.Записать();
	
КонецПроцедуры

#КонецОбласти

#Область ИсходящиеУведомления

// Записать сообщение по исходящему уведомлению в каталог отправки
// 
// Параметры:
//  Настройки - См. РегистрыСведений.НастройкиОрганизацийМЭДО.НовыйНастройки
//  УведомлениеСсылка - ОпределяемыйТип.ПредметМЭДО
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
//
// Возвращаемое значение:
//   Булево - Успешно или нет.
Функция ОтправитьИсходящееУведомление(Настройки, УведомлениеСсылка, ДанныеОтвета)

	Если Не ЗначениеЗаполнено(УведомлениеСсылка) Тогда
		Возврат Ложь;
	КонецЕсли;

	ДанныеУведомления = ДанныеИсходящегоУведомленияДляОтправки(Настройки, УведомлениеСсылка, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Документы.УведомлениеМЭДО.СнятьПризнакГотовоКОтправке(
			УведомлениеСсылка, МЭДОСтруктурыДанных.НовыйЛегкийОтвет());
		Возврат Ложь;
	КонецЕсли;
	
	ДанныеОтвета = МЭДОСтруктурыДанных.НовыйЛегкийОтвет();
	ЗаписатьСообщениеПоИсходящемуУведомлению(ДанныеУведомления, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Если ЗначениеЗаполнено(ДанныеУведомления.ПодкаталогСообщения) Тогда
			УдалитьФайлы(ДанныеУведомления.ПодкаталогСообщения);
		КонецЕсли;
		Если ЗначениеЗаполнено(ДанныеУведомления.ВременныйКаталог) Тогда
			УдалитьФайлы(ДанныеУведомления.ВременныйКаталог);
		КонецЕсли;
		
		Документы.УведомлениеМЭДО.СнятьПризнакГотовоКОтправке(
			УведомлениеСсылка, МЭДОСтруктурыДанных.НовыйЛегкийОтвет());
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;

КонецФункции

// Функция - Возвращает данные уведомления для отправки по МЭДО.
// 
// Параметры:
//  Настройки - См. РегистрыСведений.НастройкиОрганизацийМЭДО.НовыйНастройки
//  УведомлениеСсылка - ДокументСсылка.УведомлениеМЭДО - Ссылка на исходящее уведомление.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
// 
// Возвращаемое значение:
//  см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
Функция ДанныеИсходящегоУведомленияДляОтправки(Настройки, УведомлениеСсылка, ДанныеОтвета)
	
	УстановитьПривилегированныйРежим(Истина);
	
	Данные = МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки();
	
	РеквизитыУведомления = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
		УведомлениеСсылка,
		"Документ, Контрагент, Комментарий, ТипУведомления, ВерсияМЭДО, Дата, 
		|ПостановкаНаКонтроль_КонтрольныеПунктыДокумента,
		|ИдентификаторУведомления, ИдентификаторДокумента, ИдентификаторСообщенияДокумента");
	
	#Область ИдентификаторыИсходящегоУведомления
	Данные.ИдентификаторДокумента = РеквизитыУведомления.ИдентификаторДокумента;
	Данные.ИдентификаторСообщенияДокумента = РеквизитыУведомления.ИдентификаторСообщенияДокумента;
	Если Не ЗначениеЗаполнено(Данные.ИдентификаторДокумента)
		Или Не ЗначениеЗаполнено(Данные.ИдентификаторСообщенияДокумента) Тогда
		// Ненормальная ситуация, но перестраховка, тогда берем идентификаторы из РС Состояний:
		СтруктураСостояния = РегистрыСведений.СостоянияДокументовМЭДО.СостояниеДокумента(
			РеквизитыУведомления.Документ,
			Перечисления.СостоянияДокументовМЭДО.ДокументПолучен,
			"ИдентификаторДокумента, ИдентификаторСообщения",
			РеквизитыУведомления.Дата);
		Данные.ИдентификаторДокумента = НРег(СтруктураСостояния.ИдентификаторДокумента);
		Данные.ИдентификаторСообщенияДокумента = СтруктураСостояния.ИдентификаторСообщения;
		Если Не ЗначениеЗаполнено(СтруктураСостояния.ИдентификаторДокумента)
			Или Не ЗначениеЗаполнено(СтруктураСостояния.ИдентификаторСообщения) Тогда
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				УведомлениеСсылка,
				Текст_ОшибкаВРегистреСостояний(),
				НСтр("ru = 'Для отправки уведомления нет записи по нужному документу в регистре ""Состояния документов МЭДО"".'"),
				ДанныеОтвета);
			Возврат Данные;
		КонецЕсли;
	КонецЕсли;
	Данные.ИдентификаторУведомления = РеквизитыУведомления.ИдентификаторУведомления;
	Если Не ЗначениеЗаполнено(Данные.ИдентификаторУведомления) Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВРегистреСостояний(),
			НСтр("ru = 'У исходящего уведомления не заполнен ""Идентификатор уведомления"" - обычно он заполняется при записи.
			|Можно попробовать перезаписать уведомление еще раз.'"),
			ДанныеОтвета);
		Возврат Данные;
	КонецЕсли;
	#КонецОбласти
	
	КонтрольныеПунктыДокумента = РеквизитыУведомления.ПостановкаНаКонтроль_КонтрольныеПунктыДокумента.Выгрузить();
	
	ЗаполнитьЗначенияСвойств(Данные.НастройкиОрганизации, Настройки);
	
	Данные.УведомлениеСсылка = УведомлениеСсылка;
	Данные.Документ = РеквизитыУведомления.Документ;
	Данные.Комментарий = РеквизитыУведомления.Комментарий;
	Данные.Состояние = Перечисления.СостоянияДокументовМЭДО.ОтправленоУведомление;
	Данные.Дата = РеквизитыУведомления.Дата;
	Данные.ТипУведомленияСсылка = РеквизитыУведомления.ТипУведомления;
	Данные.ТипУведомления = Перечисления.ТипыУведомленийМЭДО.СтроковоеЗначениеПоЗначению(Данные.ТипУведомленияСсылка);
	
	#Область ПоляИсходящегоУведомленияВЗависимостиОтТипа
	Если Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОПостановкеНаКонтроль Тогда
		
		ИсходящееУведомление_ЗаполнитьПостановкуНаКонтроль(
			Данные, УведомлениеСсылка, КонтрольныеПунктыДокумента, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		
	ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОРегистрации Тогда
		
		Реквизиты = МЭДОПереопределяемый.ТребуемыеДанныеВходящегоДокумента(
			Данные.Документ, "РегистрационныйНомер, ДатаРегистрации", ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		Если Не ЗначениеЗаполнено(Реквизиты.РегистрационныйНомер) 
			Или Не ЗначениеЗаполнено(Реквизиты.ДатаРегистрации) Тогда
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				УведомлениеСсылка,
				Текст_ОшибкаВУведомлении(),
				НСтр("ru = 'Входящий документ не зарегистрирован (нет рег. № и даты). Уведомление о регистрации в таком случае отправить невозможно.'"),
				ДанныеОтвета);
		КонецЕсли;
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(Данные.Регистрация, Реквизиты, "РегистрационныйНомер, ДатаРегистрации");
		
	ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОбОтказеВРегистрации Тогда
		
		ИсходящееУведомление_ЗаполнитьОтказВРегистрации(Данные, УведомлениеСсылка, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		
	ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОПринятииКИсполнению Тогда 
		
		ИсходящееУведомление_ЗаполнитьПринятиеКИсполнению(Данные, УведомлениеСсылка, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		
	ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОПодготовкеДоклада Тогда
		
		ИсходящееУведомление_ЗаполнитьПодготовкуДоклада(Данные, УведомлениеСсылка, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		
	ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОНаправленииДоклада Тогда
		
		ИсходящееУведомление_ЗаполнитьНаправлениеДоклада(Данные, УведомлениеСсылка, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		
	ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОХодеИсполнения Тогда
		
		ИсходящееУведомление_ЗаполнитьХодИсполнения(Данные, УведомлениеСсылка, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		
	ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОбОпубликовании Тогда
		
		ИсходящееУведомление_ЗаполнитьОпубликование(Данные, УведомлениеСсылка, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		
	Иначе
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Невозможно отправить %1 типа ""%2"" для документа %3
			|Возможно, некорректный тип уведомления.'"),
			УведомлениеСсылка, Данные.ТипУведомленияСсылка, Данные.Документ);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Данные.Документ,
			Текст_ОшибкаВУведомлении(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат Данные;
	КонецЕсли;
	#КонецОбласти
	
	// Общие поля для всех видов уведомлений:
	Реквизиты = МЭДОПереопределяемый.ТребуемыеДанныеВходящегоДокумента(
		Данные.Документ, 
		"Контрагент, ДатаУчетаДокумента, ИсходящийНомер, ИсходящаяДата, ИсходящийПодписал, Комментарий",
		ДанныеОтвета);
	Если Не ЗначениеЗаполнено(Данные.Документ) Тогда
		Реквизиты.ИсходящийНомер = НСтр("ru = 'Не распознан'"); // для уведомления об отказе - это обязательное поле.
	КонецЕсли;
	Если Не ДанныеОтвета.Успех Тогда
		Возврат Данные;
	КонецЕсли;
	
	Контрагент = ?(
		ЗначениеЗаполнено(РеквизитыУведомления.Контрагент),РеквизитыУведомления.Контрагент, Реквизиты.Контрагент);
	
	Данные.Организация.Наименование = Настройки.НаименованиеМЭДО;
	Данные.Организация.ОрганизацияСсылка = Настройки.Организация;
	Данные.Организация.Идентификатор = Настройки.ИдентификаторМЭДО;
	Данные.Организация.АдресМЭДО = Настройки.АдресМЭДО;
	
	// Сведения о входящем документе, относительно которого создано уведомление:
	ЗаполнитьСведенияОДокументе(
		Данные.СведенияОДокументе,
		Контрагент,
		Реквизиты.ИсходящийПодписал,
		Реквизиты.ДатаУчетаДокумента,
		МЭДОСтруктурыДанных.НовыйРегистрация(Реквизиты.ИсходящийНомер, Реквизиты.ИсходящаяДата),
		Реквизиты.Комментарий,
		Настройки);
	
	Данные.Контрагент = ПоляКонтрагента(Контрагент, Реквизиты.ДатаУчетаДокумента, Истина, ДанныеОтвета);
	
	// Данные.ПунктДокумента - если нужен.
	// ТЧ ПостановкаНаКонтроль_КонтрольныеПунктыДокумента используется не только для уведомлений типа "Постановка
	// на контроль", но и для указания пункта документа к которому относится уведомление, при любом типе уведомления.
	Если КонтрольныеПунктыДокумента <> Неопределено И КонтрольныеПунктыДокумента.Количество() > 0 Тогда
		СтрокаТЧ = КонтрольныеПунктыДокумента[0];
		ЗаполнитьЗначенияСвойств(
			Данные.ПунктДокумента, СтрокаТЧ,
			"НомерПоПорядку, ИдентификаторПункта, Наименование, ТекстПункта, СрокИсполнения, Комментарий");
		ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
			Данные.ПунктДокумента.Ответственный,
			СтрокаТЧ.Юрлицо,
			СтрокаТЧ.Ответственный,
			Реквизиты.ДатаУчетаДокумента,
			Данные.НастройкиОрганизации);
		Данные.ПунктДокумента.ПолноеПредставление = СтрокаТЧ.ОтветственныйПредставление;
	КонецЕсли;
	
	// ВерсияМЭДО - если не указана у контрагента, то может быть указана в уведомлении, 
	// потом напрямую в документе, если и там нет,
	// то только тогда берется последняя версия:
	Данные.ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.ПоследняяВерсия();// ниже может быть переопределена.
	Если ЗначениеЗаполнено(РеквизитыУведомления.ВерсияМЭДО) Тогда
		Данные.ВерсияМЭДО = РеквизитыУведомления.ВерсияМЭДО;
	КонецЕсли;
	Если ЗначениеЗаполнено(Данные.Контрагент.ВерсияМЭДО) Тогда
		Данные.ВерсияМЭДО = Данные.Контрагент.ВерсияМЭДО;
	Иначе
		ДанныеДокумента = Документы.ДанныеДокументаМЭДО.ДанныеДокументаМЭДО(
			Данные.Документ, "ВерсияМЭДО", ДанныеОтвета); 
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		Если ЗначениеЗаполнено(ДанныеДокумента.ВерсияМЭДО) Тогда
			Данные.ВерсияМЭДО = ДанныеДокумента.ВерсияМЭДО;
		КонецЕсли;
	КонецЕсли;
	
	Если Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОПостановкеНаКонтроль И
		(Данные.ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия25 
		Или Данные.ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия27) Тогда
		
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Запись отменена. Для версии МЭДО %1 нельзя создавать уведомления типа ""%2""!'"),
			Данные.ВерсияМЭДО, Данные.ТипУведомленияСсылка );
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВУведомлении(),
			ТекстОшибкиПодробно,
			ДанныеОтвета);
		Возврат Данные;
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

// Процедура - Создает и записывает сообщение по исходящему уведомлению.
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ЗаписатьСообщениеПоИсходящемуУведомлению(Данные, ДанныеОтвета)
	
	ВерсияМЭДО = Данные.ВерсияМЭДО;
	
	Если Не ЗначениеЗаполнено(ВерсияМЭДО) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'У получателя уведомления ""%1"" по документу %2 не указана версия МЭДО
			|(можно указать либо для контрагента, либо для самого документа)'"),
			Данные.Контрагент.Наименование, Данные.Документ);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Данные.Документ,
			Текст_ОшибкаВКонтрагенте(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(Данные.Контрагент.Идентификатор) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'У получателя уведомления ""%1"" не указан идентификатор МЭДО'"),
			Данные.Контрагент.Наименование);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Данные.Документ,
			Текст_ОшибкаВКонтрагенте(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(Данные.Контрагент.АдресМЭДО) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'У получателя уведомления ""%1"" не указан адрес МЭДО'"),
			Данные.Контрагент.Наименование);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Данные.Документ,
			Текст_ОшибкаВКонтрагенте(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	ОтправленоУспешно = Ложь;
	НачатьТранзакцию();
	Попытка
		
		ПодкаталогСообщения = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(
			ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(Данные.НастройкиОрганизации.КаталогОтправки)
			+ Данные.ИдентификаторУведомления);
		СоздатьКаталог(ПодкаталогСообщения);
		Данные.ПодкаталогСообщения = ПодкаталогСообщения;
		
		ПолноеИмяФайлаКонверта = ПодкаталогСообщения + "envelope.ini";
		
		// Адресат - наша организация, чтоб на стороне приема контрагент прочитал этот адрес:
		АдресОтправителяДляКонверта = "0=" + Данные.Организация.АдресМЭДО;
		Конверт = Новый ТекстовыйДокумент();
		Конверт.УстановитьТекст(СтрШаблон(
			"[ПИСЬМО КП ПС СЗИ]
			|АВТООТПРАВКА=1
			|[АДРЕСАТЫ]
			|%1
			|[ФАЙЛЫ]
			|0=notification.xml",
			АдресОтправителяДляКонверта));
		Конверт.Записать(ПолноеИмяФайлаКонверта, "windows-1251");
		
		ПолноеИмяФайлаСообщения = ПодкаталогСообщения + "notification.xml";
		Пакет = ПакетXDTOСообщенияПоВерсииМЭДО(ВерсияМЭДО);
		ТипCommunication = Пакет.КорневыеСвойства.Получить("communication").Тип;
		communication = ФабрикаXDTO.Создать(ТипCommunication);
		
		communication.version = "" + ВерсияМЭДО;
		
		communication.header = ФабрикаXDTO.Создать(ТипCommunication.Свойства.Получить("header").Тип);
		communication.header.type = "Уведомление";
		communication.header.uid = НРег(Данные.ИдентификаторУведомления);
		communication.header.created = 
			?(ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271, ДатаФорматаDateTimeZone(Данные.Дата), Данные.Дата);
		communication.header.source = НовыйОбъектСообщения("communicationPartner", ВерсияМЭДО);
		communication.header.source.uid = НРег(Данные.Организация.Идентификатор);
		communication.header.source.organization = Данные.Организация.Наименование;
		
		notification = НовыйОбъектСообщения("messageNotification", ВерсияМЭДО);
		ТипNotification = notification.Тип();
		notification.type = Данные.ТипУведомления;
		notification.uid = НРег(Данные.ИдентификаторДокумента);
		notification.mid = НРег(Данные.ИдентификаторСообщенияДокумента);
		
		// Не заполняется: notification.comment (Данные.Комментарий). Некоторые операторы это поле в файле считают
		// ошибочным, кроме случая, когда отказ в регистрации и там уточнение причины отказа.
		
		
		// Раздел foundation - для всех видов уведомлений. Данные о документе, на который отвечает это уведомление:
		foundation = Неопределено;
		ЗаполнитьDocumentReference(foundation, Данные.СведенияОДокументе, ВерсияМЭДО);
		
		Если Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОПостановкеНаКонтроль Тогда
			
			ИсходящееУведомление_ЗаполнитьDocumentSent(notification, Данные, foundation);
			
		ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОРегистрации Тогда
			
			notification.documentAccepted
				= ФабрикаXDTO.Создать(ТипNotification.Свойства.Получить("documentAccepted").Тип);
			notification.documentAccepted.time = ТекущаяДатаСеанса();
			notification.documentAccepted.foundation = foundation;
			
			notification.documentAccepted.num = НовыйОбъектСообщения("documentNumber", ВерсияМЭДО);
			notification.documentAccepted.num.number = Данные.Регистрация.РегистрационныйНомер;
			notification.documentAccepted.num.date = Данные.Регистрация.ДатаРегистрации;
			
		ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОбОтказеВРегистрации Тогда
			
			notification.documentRefused = ФабрикаXDTO.Создать(ТипNotification.Свойства.Получить("documentRefused").Тип);
			notification.documentRefused.time = ТекущаяДатаСеанса();
			notification.documentRefused.foundation = foundation;
			notification.comment = Данные.Комментарий;
			
			Если ТипЗнч(notification.documentRefused.reason) = Тип("СписокXDTO") Тогда
				notification.documentRefused.reason.Добавить( Данные.ОтказВРегистрации.ПричинаОтказа );
			Иначе
				// Для 2.7 значения перечисления в точности соответствуют перечислению reasonForRejection в XDTO-пакете
				notification.documentRefused.reason = Данные.ОтказВРегистрации.ПричинаОтказа;
			КонецЕсли;
			
		ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОПринятииКИсполнению Тогда
			
			ИсходящееУведомление_ЗаполнитьExecutorAssigned(notification, Данные, foundation);
			
		ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОПодготовкеДоклада Тогда
			
			ИсходящееУведомление_ЗаполнитьReportPrepared(notification, Данные, foundation);
			
		ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОНаправленииДоклада Тогда
			
			ИсходящееУведомление_ЗаполнитьReportSent(notification, Данные, foundation);
			
		ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОХодеИсполнения Тогда
			
			ИсходящееУведомление_ЗаполнитьCourseChanged(notification, Данные, foundation);
			
		ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОбОпубликовании Тогда
			
			ИсходящееУведомление_ЗаполнитьDocumentPublished(notification, Данные, foundation);
			
		Иначе 
			ТекстОшибкиПодробно = СтрШаблон(
				НСтр("ru = 'При записи исходящего уведомления получен не предусмотренный тип уведомления - ""%1"".'"),
				Данные.ТипУведомленияСсылка);
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				Данные.УведомлениеСсылка,
				Текст_ОшибкаВУведомлении(),
				ТекстОшибкиПодробно,
				ДанныеОтвета);
			ВызватьИсключение ДанныеОтвета.СообщениеОбОшибке;
			
		КонецЕсли;
		
		communication.notification = notification;
		
		
		destination = НовыйОбъектСообщения("communicationPartner", ВерсияМЭДО);
		destination.uid = НРег(Данные.Контрагент.Идентификатор);
		destination.organization = Данные.Контрагент.Наименование;
		deliveryDestination = НовыйОбъектСообщения("deliveryDestination", ВерсияМЭДО);
		deliveryDestination.destination = destination;
		communication.deliveryIndex = ФабрикаXDTO.Создать(ТипCommunication.Свойства.Получить("deliveryIndex").Тип);
		communication.deliveryIndex.destination.Добавить(deliveryDestination);
		
		ЗаписьXML = Новый ЗаписьXML();
		ЗаписьXML.ОткрытьФайл(ПолноеИмяФайлаСообщения, "UTF-8");
		ЗаписьXML.ЗаписатьОбъявлениеXML();
		ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, communication, "communication", , , НазначениеТипаXML.Неявное);
		ЗаписьXML.Закрыть();
		
		
		// Заполним данные уведомления, меняющиеся при отправке.
		// Уведомление уже должно быть создано на этом этапе.
		Уведомление = Данные.УведомлениеСсылка.ПолучитьОбъект();
		Уведомление.ВерсияМЭДО = ВерсияМЭДО;
		ДвоичныеДанныеКонверта = Новый ДвоичныеДанные(ПолноеИмяФайлаКонверта);
		Уведомление.ДанныеКонверта = Новый ХранилищеЗначения(ДвоичныеДанныеКонверта);
		ДвоичныеДанныеСообщения = Новый ДвоичныеДанные(ПолноеИмяФайлаСообщения);
		Уведомление.ДанныеСообщения = Новый ХранилищеЗначения(ДвоичныеДанныеСообщения, Новый СжатиеДанных(5));
		Уведомление.ГотовоКОтправке = Ложь;
		Уведомление.Отправлено = Истина;
		Уведомление.Записать();
		
		
		ОтправленоУспешно = Истина;
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		
		// Пишем в журнал только если ошибка не обработана во вложенных процедурах, вложенные сами пишут в журнал.
		Если ДанныеОтвета.Успех Тогда
			ТекстКратко = НСтр("ru = 'Ошибка создания исходящего уведомления'");
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				Данные.Документ,
				ТекстКратко,
				СтрШаблон("%1: %2", ТекстКратко, ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())),
				ДанныеОтвета);
		КонецЕсли;
	КонецПопытки;
	
	Если ОтправленоУспешно Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Информация,
			Данные.УведомлениеСсылка,
			Текст_ОбъектОтправленУспешно(),
			Текст_ОбъектОтправленУспешно(),
			ДанныеОтвета);
	КонецЕсли;
	
КонецПроцедуры

// Исходящее уведомление - заполнить структуру по части постановки на контроль из документа "Уведомление МЭДО".
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  УведомлениеСсылка - ДокументСсылка.УведомлениеМЭДО - источник, откуда заполнять.
//  КонтрольныеПунктыДокумента - ТаблицаЗначений - выгрузка из соответственной ТЧ уведомления.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ИсходящееУведомление_ЗаполнитьПостановкуНаКонтроль(
	Данные, УведомлениеСсылка, КонтрольныеПунктыДокумента, ДанныеОтвета)
	
	Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
		УведомлениеСсылка, 
		"ТипУведомления, ПостановкаНаКонтроль, Дата");
	
	Если Реквизиты.ПостановкаНаКонтроль = Неопределено Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВУведомлении(),
			ТекстПодробно_ОшибкаВУведомленииПоТипу(Реквизиты.ТипУведомления),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	
	Для Каждого СтрокаТЧ Из Реквизиты.ПостановкаНаКонтроль.Выгрузить() Цикл
		ЗаполнитьЗначенияСвойств(
			Данные.ПостановкаНаКонтроль, СтрокаТЧ,
			"ТребуетсяРегистрация, ТребуетсяИсполнение, ТребуетсяПубликация");
	КонецЦикла;
	
	Если КонтрольныеПунктыДокумента <> Неопределено Тогда
		Для Каждого СтрокаТЧ Из КонтрольныеПунктыДокумента Цикл
			Пункт = МЭДОСтруктурыДанных.НовыйПунктДокумента();
			ЗаполнитьЗначенияСвойств(
				Пункт, СтрокаТЧ,
				"НомерПоПорядку, ИдентификаторПункта, Наименование, ТекстПункта, СрокИсполнения, Комментарий");
			ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
				Пункт.Ответственный,
				СтрокаТЧ.Юрлицо,
				СтрокаТЧ.Ответственный,
				Реквизиты.Дата,
				Данные.НастройкиОрганизации);
			Пункт.ПолноеПредставление = СтрокаТЧ.ОтветственныйПредставление;
			
			Данные.ПостановкаНаКонтроль.ПунктыДокумента.Добавить(Пункт);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Исходящее уведомление - заполнить структуру по части отказа в регистрации из документа "Уведомление МЭДО".
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  УведомлениеСсылка - ДокументСсылка.УведомлениеМЭДО - источник, откуда заполнять.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ИсходящееУведомление_ЗаполнитьОтказВРегистрации(Данные, УведомлениеСсылка, ДанныеОтвета)
	
	Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
		УведомлениеСсылка, "ТипУведомления, ОтказВРегистрации, Дата");
	Если Реквизиты.ОтказВРегистрации = Неопределено Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВУведомлении(),
			ТекстПодробно_ОшибкаВУведомленииПоТипу(Реквизиты.ТипУведомления),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	Для Каждого СтрокаТЧ Из Реквизиты.ОтказВРегистрации.Выгрузить() Цикл
		Данные.ОтказВРегистрации.ПричинаОтказа = "" + СтрокаТЧ.ПричинаОтказа;
		Данные.ОтказВРегистрации.ПричинаОтказаСсылка = СтрокаТЧ.ПричинаОтказа;
	КонецЦикла;
	
КонецПроцедуры

// Исходящее уведомление - заполнить структуру по части принятия к исполнению из документа "Уведомление МЭДО".
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  УведомлениеСсылка - ДокументСсылка.УведомлениеМЭДО - источник, откуда заполнять.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ИсходящееУведомление_ЗаполнитьПринятиеКИсполнению(Данные, УведомлениеСсылка, ДанныеОтвета)
	
	Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
		УведомлениеСсылка, "ТипУведомления, ПринятиеКИсполнению, Дата");
	Если Реквизиты.ПринятиеКИсполнению = Неопределено Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВУведомлении(),
			ТекстПодробно_ОшибкаВУведомленииПоТипу(Реквизиты.ТипУведомления),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	
	Для Каждого СтрокаТЧ Из Реквизиты.ПринятиеКИсполнению.Выгрузить() Цикл
		
		ПрисвоитьЗаполненное(Данные.ПринятиеКИсполнению.ЮрлицоСсылка, СтрокаТЧ.Юрлицо);
		
		// Есть руководитель/секретарь:
		Если ЗначениеЗаполнено(СтрокаТЧ.РуководительСекретарь)
			Или ЗначениеЗаполнено(СтрокаТЧ.РуководительСекретарьПредставление) 
			Или ЗначениеЗаполнено(СтрокаТЧ.КомментарийРуководителяСекретаря) Тогда
			
			ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
				Данные.ПринятиеКИсполнению.РуководительСекретарь,
				СтрокаТЧ.Юрлицо,
				СтрокаТЧ.РуководительСекретарь,
				Реквизиты.Дата,
				Данные.НастройкиОрганизации);
			
			ПрисвоитьЗаполненное(
				Данные.ПринятиеКИсполнению.РуководительСекретарь.ПолноеПредставление,
				СтрокаТЧ.РуководительСекретарьПредставление);
			Данные.ПринятиеКИсполнению.КомментарийРуководителяСекретаря = СтрокаТЧ.КомментарийРуководителяСекретаря;
		КонецЕсли;
		
		// Есть руководитель подразделения:
		Если ЗначениеЗаполнено(СтрокаТЧ.РуководительПодразделения)
			Или ЗначениеЗаполнено(СтрокаТЧ.РуководительПодразделенияПредставление) 
			Или ЗначениеЗаполнено(СтрокаТЧ.КомментарийРуководителяПодразделения) Тогда
			
			ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
				Данные.ПринятиеКИсполнению.РуководительПодразделения,
				СтрокаТЧ.Юрлицо,
				СтрокаТЧ.РуководительПодразделения,
				Реквизиты.Дата,
				Данные.НастройкиОрганизации);
			
			ПрисвоитьЗаполненное(
				Данные.ПринятиеКИсполнению.РуководительПодразделения.ПолноеПредставление, 
				СтрокаТЧ.РуководительПодразделенияПредставление);
			Данные.ПринятиеКИсполнению.КомментарийРуководителяПодразделения
				= СтрокаТЧ.КомментарийРуководителяПодразделения;
		КонецЕсли;
		
		// Есть исполнитель:
		Если ЗначениеЗаполнено(СтрокаТЧ.Исполнитель)
			Или ЗначениеЗаполнено(СтрокаТЧ.ИсполнительПредставление) 
			Или ЗначениеЗаполнено(СтрокаТЧ.КомментарийИсполнителя) Тогда
			
			ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
				Данные.ПринятиеКИсполнению.Исполнитель,
				СтрокаТЧ.Юрлицо,
				СтрокаТЧ.Исполнитель,
				Реквизиты.Дата,
				Данные.НастройкиОрганизации);
			ПрисвоитьЗаполненное(
				Данные.ПринятиеКИсполнению.Исполнитель.ПолноеПредставление, СтрокаТЧ.ИсполнительПредставление);
			
			Данные.ПринятиеКИсполнению.КомментарийИсполнителя = СтрокаТЧ.КомментарийИсполнителя;
		КонецЕсли;
		
	КонецЦикла;

КонецПроцедуры

// Исходящее уведомление - заполнить структуру по части подготовки доклада из документа "Уведомление МЭДО".
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  УведомлениеСсылка - ДокументСсылка.УведомлениеМЭДО - источник, откуда заполнять.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ИсходящееУведомление_ЗаполнитьПодготовкуДоклада(Данные, УведомлениеСсылка, ДанныеОтвета)
	
	Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
		УведомлениеСсылка, "ТипУведомления, ПодготовкаДоклада, Дата");
	Если Реквизиты.ПодготовкаДоклада = Неопределено Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВУведомлении(),
			ТекстПодробно_ОшибкаВУведомленииПоТипу(Реквизиты.ТипУведомления),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	Для Каждого СтрокаТЧ Из Реквизиты.ПодготовкаДоклада.Выгрузить() Цикл
		
		ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
			Данные.ПодготовкаДоклада.Ответственный,
			СтрокаТЧ.Юрлицо,
			СтрокаТЧ.Ответственный,
			Реквизиты.Дата,
			Данные.НастройкиОрганизации);
		ПрисвоитьЗаполненное(
			Данные.ПодготовкаДоклада.Ответственный.ПолноеПредставление, СтрокаТЧ.ОтветственныйПредставление);
		
		Данные.ПодготовкаДоклада.ДатаПодписания = СтрокаТЧ.ДатаПодписания;
		Данные.ПодготовкаДоклада.КомментарийПодписания = СтрокаТЧ.КомментарийПодписания;
		
	КонецЦикла;
	
КонецПроцедуры

// Исходящее уведомление - заполнить структуру по части направления доклада из документа "Уведомление МЭДО".
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  УведомлениеСсылка - ДокументСсылка.УведомлениеМЭДО - источник, откуда заполнять.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ИсходящееУведомление_ЗаполнитьНаправлениеДоклада(Данные, УведомлениеСсылка, ДанныеОтвета)
	
	Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
		УведомлениеСсылка, "ТипУведомления, НаправлениеДоклада, Дата");
	Если Реквизиты.НаправлениеДоклада = Неопределено Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВУведомлении(),
			ТекстПодробно_ОшибкаВУведомленииПоТипу(Реквизиты.ТипУведомления),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	Для Каждого СтрокаТЧ Из Реквизиты.НаправлениеДоклада.Выгрузить() Цикл
		
		ЗаполнитьСведенияОДокументе(
			Данные.НаправлениеДоклада.СведенияОДокументе,
			СтрокаТЧ.Юрлицо,
			СтрокаТЧ.Ответственный,
			Реквизиты.Дата,
			МЭДОСтруктурыДанных.НовыйРегистрация(СтрокаТЧ.РегистрационныйНомер,  СтрокаТЧ.ДатаРегистрации),
			СтрокаТЧ.Комментарий,
			Данные.НастройкиОрганизации);
		
	КонецЦикла;
	
КонецПроцедуры

// Исходящее уведомление - заполнить структуру по части хода исполнения из документа "Уведомление МЭДО".
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  УведомлениеСсылка - ДокументСсылка.УведомлениеМЭДО - источник, откуда заполнять.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ИсходящееУведомление_ЗаполнитьХодИсполнения(Данные, УведомлениеСсылка, ДанныеОтвета);

	Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(УведомлениеСсылка, "ТипУведомления, ХодИсполнения, Дата");
	Если Реквизиты.ХодИсполнения = Неопределено Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВУведомлении(),
			ТекстПодробно_ОшибкаВУведомленииПоТипу(Реквизиты.ТипУведомления),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	Для Каждого СтрокаТЧ Из Реквизиты.ХодИсполнения.Выгрузить() Цикл
		
		ЗаполнитьСведенияОДокументе(
			Данные.ХодИсполнения.СведенияОДокументе,
			СтрокаТЧ.Юрлицо,
			СтрокаТЧ.Ответственный,
			Реквизиты.Дата,
			МЭДОСтруктурыДанных.НовыйРегистрация(СтрокаТЧ.РегистрационныйНомер,  СтрокаТЧ.ДатаРегистрации),
			СтрокаТЧ.Комментарий,
			Данные.НастройкиОрганизации);
			
		Данные.ХодИсполнения.ОписаниеХодаИсполнения = СтрокаТЧ.ОписаниеХодаИсполнения;
		
	КонецЦикла;
	
КонецПроцедуры

// Исходящее уведомление - заполнить структуру по части опубликования из документа "Уведомление МЭДО".
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  УведомлениеСсылка - ДокументСсылка.УведомлениеМЭДО - источник, откуда заполнять.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ИсходящееУведомление_ЗаполнитьОпубликование(Данные, УведомлениеСсылка, ДанныеОтвета);

	Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(УведомлениеСсылка, "ТипУведомления, Опубликование, Дата");
	Если Реквизиты.Опубликование = Неопределено Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВУведомлении(),
			ТекстПодробно_ОшибкаВУведомленииПоТипу(Реквизиты.ТипУведомления),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	Для Каждого СтрокаТЧ Из Реквизиты.Опубликование.Выгрузить() Цикл
		Данные.Опубликование.РегистрационныеДанные.ДатаРегистрации = СтрокаТЧ.ДатаРегистрации;
		Данные.Опубликование.РегистрационныеДанные.РегистрационныйНомер = СтрокаТЧ.РегистрационныйНомер;
		Данные.Опубликование.ПечатныйОрган = СтрокаТЧ.ПечатныйОрган;
	КонецЦикла;
	
КонецПроцедуры

// Исходящее уведомление заполнить блок файла documentSent - постановка на контроль.
// 
// Параметры:
//  notification - ОбъектXDTO
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  foundation - ОбъектXDTO - этот общий блок вставляется во все типы уведомлений.
Процедура ИсходящееУведомление_ЗаполнитьDocumentSent(notification, Данные, foundation);
	
	documentSent = ФабрикаXDTO.Создать(notification.Тип().Свойства.Получить("documentSent").Тип);
	documentSent.foundation = foundation;
	clause = Неопределено;
	Если ЗаполнитьDocumentClause(clause, Данные.ПунктДокумента, Данные.ВерсияМЭДО) Тогда
		documentSent.clause = clause;
	КонецЕсли;
	documentSent.time = ТекущаяДатаСеанса();
	
	documentSent.needRegistration = Данные.ПостановкаНаКонтроль.ТребуетсяРегистрация;
	documentSent.needExecution = Данные.ПостановкаНаКонтроль.ТребуетсяИсполнение;
	documentSent.needPublication = Данные.ПостановкаНаКонтроль.ТребуетсяПубликация;
	
	Если Данные.ПостановкаНаКонтроль.ПунктыДокумента.Количество() <> 0 Тогда
		documentSent.clauses = ФабрикаXDTO.Создать(
			notification.Тип().Свойства.Получить("documentSent").Тип.Свойства.Получить("clauses").Тип);
		Для Каждого Пункт Из Данные.ПостановкаНаКонтроль.ПунктыДокумента Цикл
			clause = Неопределено;
			Если ЗаполнитьDocumentClause(clause, Пункт, Данные.ВерсияМЭДО) Тогда
				documentSent.clauses.clause.Добавить(clause);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	notification.documentSent = documentSent;
	
КонецПроцедуры

// Исходящее уведомление заполнить блок файла executorAssigned - принятие к исполнению.
// 
// Параметры:
//  notification - ОбъектXDTO
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  foundation - ОбъектXDTO - этот общий блок вставляется во все типы уведомлений.
Процедура ИсходящееУведомление_ЗаполнитьExecutorAssigned(notification, Данные, foundation)
	
	executorAssigned = ФабрикаXDTO.Создать(notification.Тип().Свойства.Получить("executorAssigned").Тип);
	executorAssigned.foundation = foundation;
	clause = Неопределено;
	Если ЗаполнитьDocumentClause(clause, Данные.ПунктДокумента, Данные.ВерсияМЭДО) Тогда
		executorAssigned.clause = clause;
	КонецЕсли;
	executorAssigned.time = ТекущаяДатаСеанса();
	
	secretary = ФабрикаXDTO.Создать(executorAssigned.Тип().Свойства.Получить("secretary").Тип);
	ЕстьДанные = Ложь;
	Если ЗаполнитьAnyone(secretary, Данные.ПринятиеКИсполнению.РуководительСекретарь, Данные.ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(secretary.comment, Данные.ПринятиеКИсполнению.КомментарийРуководителяСекретаря) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЕстьДанные Тогда
		executorAssigned.secretary = secretary;
	КонецЕсли;
	
	manager = ФабрикаXDTO.Создать(executorAssigned.Тип().Свойства.Получить("manager").Тип);
	ЕстьДанные = Ложь;
	Если ЗаполнитьAnyone(manager, Данные.ПринятиеКИсполнению.РуководительПодразделения, Данные.ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(manager.comment, Данные.ПринятиеКИсполнению.КомментарийРуководителяПодразделения) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЕстьДанные Тогда
		executorAssigned.manager = manager;
	КонецЕсли;
	
	
	executor = ФабрикаXDTO.Создать(executorAssigned.Тип().Свойства.Получить("executor").Тип);
	ЕстьДанные = Ложь;
	Если ЗаполнитьAnyone(executor, Данные.ПринятиеКИсполнению.Исполнитель, Данные.ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(executor.comment, Данные.ПринятиеКИсполнению.КомментарийИсполнителя) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЕстьДанные Тогда
		executorAssigned.executor = executor;
	КонецЕсли;
	
	notification.executorAssigned = executorAssigned;
	
КонецПроцедуры

// Исходящее уведомление заполнить блок файла reportPrepared - подготовка доклада.
// 
// Параметры:
//  notification - ОбъектXDTO
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  foundation - ОбъектXDTO - этот общий блок вставляется во все типы уведомлений.
Процедура ИсходящееУведомление_ЗаполнитьReportPrepared(notification, Данные, foundation)

	reportPrepared = ФабрикаXDTO.Создать(notification.Тип().Свойства.Получить("reportPrepared").Тип);
	reportPrepared.foundation = foundation;
	clause = Неопределено;
	Если ЗаполнитьDocumentClause(clause, Данные.ПунктДокумента, Данные.ВерсияМЭДО) Тогда
		reportPrepared.clause = clause;
	КонецЕсли;
	reportPrepared.time = ТекущаяДатаСеанса();
	
	signatory = НовыйОбъектСообщения("signatory", Данные.ВерсияМЭДО);
	ЕстьДанные = Ложь;
	Если ЗаполнитьAnyone(signatory, Данные.ПодготовкаДоклада.Ответственный, Данные.ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(signatory.signed, Данные.ПодготовкаДоклада.ДатаПодписания) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(signatory.comment, Данные.ПодготовкаДоклада.КомментарийПодписания) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЕстьДанные Тогда
		reportPrepared.signatory = signatory;
	КонецЕсли;
	
	notification.reportPrepared = reportPrepared;

КонецПроцедуры

// Исходящее уведомление заполнить блок файла reportSent - направление доклада.
// 
// Параметры:
//  notification - ОбъектXDTO
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  foundation - ОбъектXDTO - этот общий блок вставляется во все типы уведомлений.
Процедура ИсходящееУведомление_ЗаполнитьReportSent(notification, Данные, foundation)

	reportSent = ФабрикаXDTO.Создать(notification.Тип().Свойства.Получить("reportSent").Тип);
	reportSent.foundation = foundation;
	clause = Неопределено;
	Если ЗаполнитьDocumentClause(clause, Данные.ПунктДокумента, Данные.ВерсияМЭДО) Тогда
		reportSent.clause = clause;
	КонецЕсли;
	reportSent.time = ТекущаяДатаСеанса();
	
	report = Неопределено;
	ЗаполнитьDocumentReference(report, Данные.НаправлениеДоклада.СведенияОДокументе, Данные.ВерсияМЭДО);
	reportSent.report = report;

	notification.reportSent = reportSent;

КонецПроцедуры

// Исходящее уведомление заполнить блок файла courseChanged - ход исполнения.
// 
// Параметры:
//  notification - ОбъектXDTO
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  foundation - ОбъектXDTO - этот общий блок вставляется во все типы уведомлений.
Процедура ИсходящееУведомление_ЗаполнитьCourseChanged(notification, Данные, foundation)

	courseChanged = ФабрикаXDTO.Создать(notification.Тип().Свойства.Получить("courseChanged").Тип);
	courseChanged.foundation = foundation;
	clause = Неопределено;
	Если ЗаполнитьDocumentClause(clause, Данные.ПунктДокумента, Данные.ВерсияМЭДО) Тогда
		courseChanged.clause = clause;
	КонецЕсли;
	courseChanged.time = ТекущаяДатаСеанса();
	
	courseChanged.courseText = Данные.ХодИсполнения.ОписаниеХодаИсполнения;
	reference = Неопределено;
	ЗаполнитьDocumentReference(reference, Данные.ХодИсполнения.СведенияОДокументе, Данные.ВерсияМЭДО);
	courseChanged.reference = reference;
	
	notification.courseChanged = courseChanged;

КонецПроцедуры

// Исходящее уведомление заполнить блок файла documentPublished - опубликование.
// 
// Параметры:
//  notification - ОбъектXDTO
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  foundation - ОбъектXDTO - этот общий блок вставляется во все типы уведомлений.
Процедура ИсходящееУведомление_ЗаполнитьDocumentPublished(notification, Данные, foundation)

	documentPublished = ФабрикаXDTO.Создать(notification.Тип().Свойства.Получить("documentPublished").Тип);
	documentPublished.foundation = foundation;
	clause = Неопределено;
	Если ЗаполнитьDocumentClause(clause, Данные.ПунктДокумента, Данные.ВерсияМЭДО) Тогда
		documentPublished.clause = clause;
	КонецЕсли;
	documentPublished.time = ТекущаяДатаСеанса();
	
	num = ФабрикаXDTO.Создать(documentPublished.Тип().Свойства.Получить("num").Тип);
	num.number = Данные.Опубликование.РегистрационныеДанные.РегистрационныйНомер;
	num.date = Данные.Опубликование.РегистрационныеДанные.ДатаРегистрации;
	documentPublished.num = num;
	documentPublished.publicationPoint = Данные.Опубликование.ПечатныйОрган;
	
	notification.documentPublished = documentPublished;

КонецПроцедуры

// Заполнить объект documentReference.
// 
// Параметры:
//  documentReference - ОбъектXDTO, Неопределено - если Неопределено, то создается внутри. Объект, который нужно заполнить.
//  СведенияОДокументе - см. МЭДОСтруктурыДанных.НовыйСведенияОДокументе.
//  ВерсияМЭДО - ПеречислениеСсылка.ВерсииФорматаМЭДО
//
// Возвращаемое значение:
//  Булево - Истина, если удалось заполнить, Ложь, если на вход пришел объект без данных.
Функция ЗаполнитьDocumentReference(documentReference, СведенияОДокументе, ВерсияМЭДО);
	
	Если documentReference = Неопределено Тогда
		documentReference = НовыйОбъектСообщения("documentReference", ВерсияМЭДО);
	КонецЕсли;
	
	ЕстьДанные = Ложь;
	Если ЗаполнитьQualifiedValue(documentReference.organization, СведенияОДокументе.Юрлицо, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЗаполнитьQualifiedValue(documentReference.person, СведенияОДокументе.Персона, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЗаполнитьQualifiedValue(documentReference.department, СведенияОДокументе.Подразделение, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЗаполнитьQualifiedValue(documentReference.post, СведенияОДокументе.Должность, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЗаполнитьDocumentNumber(documentReference.num, СведенияОДокументе.РегистрационныеДанные, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(documentReference.comment, СведенияОДокументе.Комментарий) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	
	Если Не ЕстьДанные Тогда
		ЕстьДанные = ПрисвоитьЗаполненное(documentReference.comment, СведенияОДокументе.ПолноеПредставление);
	КонецЕсли;
	
	Возврат ЕстьДанные;
	
КонецФункции

// Заполнить объект qualifiedValue. 
// 
// Параметры:
//  qualifiedValue - ОбъектXDTO, Неопределено - если Неопределено, то создается внутри. Объект, который нужно заполнить.
//  ОграниченноеЗначение - см. МЭДОСтруктурыДанных.НовыйОграниченноеЗначение.
//  ВерсияМЭДО - ПеречислениеСсылка.ВерсииФорматаМЭДО
// 
// Возвращаемое значение:
//  Булево - Истина, если удалось заполнить, Ложь, если на вход пришел объект без данных.
Функция ЗаполнитьQualifiedValue(qualifiedValue, ОграниченноеЗначение, ВерсияМЭДО)
	
	Если Не ЗначениеЗаполнено(ОграниченноеЗначение.Наименование) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если qualifiedValue = Неопределено Тогда
		qualifiedValue = НовыйОбъектСообщения("qualifiedValue", ВерсияМЭДО);
	КонецЕсли;
	
	qualifiedValue.__content = ОграниченноеЗначение.Наименование;
	ПрисвоитьЗаполненное(qualifiedValue.id, ОграниченноеЗначение.Идентификатор);
	
	Возврат Истина;
	
КонецФункции

// Заполнить объект documentNumber. 
// 
// Параметры:
//  documentNumber - ОбъектXDTO, Неопределено - если Неопределено, то создается внутри. Объект, который нужно заполнить.
//  РегистрационныеДанные - см. МЭДОСтруктурыДанных.НовыйРегистрация
//  ВерсияМЭДО - ПеречислениеСсылка.ВерсииФорматаМЭДО
// 
// Возвращаемое значение:
//  Булево - Истина, если удалось заполнить, Ложь, если на вход пришел объект без данных.
Функция ЗаполнитьDocumentNumber(documentNumber, РегистрационныеДанные, ВерсияМЭДО)
	
	Если Не ЗначениеЗаполнено(РегистрационныеДанные.РегистрационныйНомер)
		И Не ЗначениеЗаполнено(РегистрационныеДанные.ДатаРегистрации) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если documentNumber = Неопределено Тогда
		documentNumber = НовыйОбъектСообщения("documentNumber", ВерсияМЭДО);
	КонецЕсли;
	
	documentNumber.number = РегистрационныеДанные.РегистрационныйНомер;
	ПрисвоитьЗаполненное(documentNumber.date, РегистрационныеДанные.ДатаРегистрации);
	
	Возврат Истина;
	
КонецФункции

// Заполнить объект documentClause.
// 
// Параметры:
//  clause - ОбъектXDTO, Неопределено - если Неопределено, то создается внутри. Объект, который нужно заполнить.
//  Пункт - см. МЭДОСтруктурыДанных.НовыйПунктДокумента.
//  ВерсияМЭДО - ПеречислениеСсылка.ВерсииФорматаМЭДО
//
// Возвращаемое значение:
//  Булево - Истина, если удалось заполнить, Ложь, если на вход пришел объект без данных.
Функция ЗаполнитьDocumentClause(clause, Пункт, ВерсияМЭДО)
	
	Если clause = Неопределено Тогда
		clause = НовыйОбъектСообщения("documentClause", ВерсияМЭДО);
	КонецЕсли;
	
	ЕстьДанные = Ложь;
	Если ПрисвоитьЗаполненное(clause.localId, Пункт.НомерПоПорядку) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(clause.id, Пункт.ИдентификаторПункта) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(clause.designation, Пункт.Наименование) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(clause.text, Пункт.ТекстПункта) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(clause.deadline, Пункт.СрокИсполнения) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	
	ЕстьPrincipal = Ложь;
	principal = НовыйОбъектСообщения("addressee", ВерсияМЭДО);
	Если ЗаполнитьAnyone(principal, Пункт.Ответственный, ВерсияМЭДО) Тогда
		ЕстьPrincipal = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(principal.comment, Пункт.Комментарий) Тогда
		ЕстьPrincipal = Истина;
	КонецЕсли;
	
	Если ЕстьДанные И ЕстьPrincipal Тогда
		clause.principal = principal;
		Возврат Истина;
	КонецЕсли;
	
	Возврат ЕстьДанные;
	
КонецФункции

// Заполнить объект anyone. Объект типа anyone подается на вход и возвращается заполненный, это может быть
// как непосредственно anyone, так и объект с базовым типом anyone - (например addressee)
// 
// Параметры:
//  anyone - ОбъектXDTO, Неопределено - если Неопределено, то создается внутри. Объект, который нужно заполнить.
//  ОтветственнаяСтруктурнаяЕдиница - см. МЭДОСтруктурыДанных.НовыйОтветственнаяСтруктурнаяЕдиница.
//  ВерсияМЭДО - ПеречислениеСсылка.ВерсииФорматаМЭДО
//
// Возвращаемое значение:
//  Булево - Истина, если удалось заполнить, Ложь, если на вход пришел объект без данных.
Функция ЗаполнитьAnyone(anyone, ОтветственнаяСтруктурнаяЕдиница, ВерсияМЭДО)
	
	Если anyone = Неопределено Тогда
		anyone = НовыйОбъектСообщения("anyone", ВерсияМЭДО);
	КонецЕсли;
	
	ЕстьДанные = Ложь;
	Если ЗаполнитьQualifiedValue(anyone.region, ОтветственнаяСтруктурнаяЕдиница.Регион, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЗаполнитьQualifiedValue(anyone.organization, ОтветственнаяСтруктурнаяЕдиница.Юрлицо, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЗаполнитьQualifiedValue(anyone.person, ОтветственнаяСтруктурнаяЕдиница.Персона, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЗаполнитьQualifiedValue(anyone.department, ОтветственнаяСтруктурнаяЕдиница.Подразделение, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЗаполнитьQualifiedValue(anyone.post, ОтветственнаяСтруктурнаяЕдиница.Должность, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(anyone.contactInfo, ОтветственнаяСтруктурнаяЕдиница.КонтактнаяИнформацияПредставление) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	
	Возврат ЕстьДанные;
	
КонецФункции

// Отказ в регистрации, если не валидный файл.
// 
// Параметры:
//  ВерсияМЭДО - ПеречислениеСсылка.ВерсииФорматаМЭДО -
//  Контрагент - ОпределяемыйТип.КонтрагентМЭДО -
// 
// Возвращаемое значение:
//  См. МЭДОСтруктурыДанных.НовыйОтказВРегистрации
Функция ОтказВРегистрацииЕслиНеВалидныйФайл(ВерсияМЭДО, Контрагент)

	Причина = Неопределено;
	Если ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
		Причина = Справочники.ПричиныОтказаВРегистрацииМЭДО.ФорматСообщенияНеСоответствуетТребованиям;
	ИначеЕсли ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия27 Тогда
		Причина = Справочники.ПричиныОтказаВРегистрацииМЭДО.НесоответствиеСодержимогоТранспортногоКонтейнераУтвержденнымТребованиям;
	Иначе
		// перестраховка, если версия МЭДО у контрагента здесь неправильная (2.5):
		Текст = СтрШаблон(
			НСтр("ru = 'У контрагента неподдерживаемая версия формата %1 для отправки уведомления'"), ВерсияМЭДО);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Контрагент,
			НСтр("ru = 'Не поддерживаемая версия'"),
			Текст,
			МЭДОСтруктурыДанных.НовыйЛегкийОтвет());
		Возврат Неопределено; // Признак, что уведомление делать не надо.
	КонецЕсли;
	
	Возврат МЭДОСтруктурыДанных.НовыйОтказВРегистрации("" + Причина, Причина);

КонецФункции

#КонецОбласти

// Заполнить ответственную структурную единицу. Заполняет структуру, поданную на вход.
// 
// Параметры:
//  ОтветственнаяСтруктурнаяЕдиница - см. МЭДОСтруктурыДанных.НовыйОтветственнаяСтруктурнаяЕдиница
//  ЮрлицоСсылка - ОпределяемыйТип.ЮрлицоМЭДО
//  КонтактноеЛицоСсылка - ОпределяемыйТип.КонтактноеЛицоМЭДО
//  ДатаСведений - Дата
//  Настройки - См. РегистрыСведений.НастройкиОрганизацийМЭДО.НовыйНастройки
Процедура ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
	ОтветственнаяСтруктурнаяЕдиница,
	ЮрлицоСсылка,
	КонтактноеЛицоСсылка,
	ДатаСведений,
	Настройки)
	
	Если ЭтоОрганизация(ЮрлицоСсылка) Тогда
		Если ЮрлицоСсылка = Настройки.Организация Тогда
			ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Наименование = Настройки.НаименованиеМЭДО;
			ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Идентификатор = Настройки.ИдентификаторМЭДО;
		Иначе
			// Другая организация в нашей базе:
			НастройкиЮрлица = РегистрыСведений.НастройкиОрганизацийМЭДО.НастройкиОрганизации(
				ЮрлицоСсылка, МЭДОСтруктурыДанных.НовыйЛегкийОтвет(), "НаименованиеМЭДО, ИдентификаторМЭДО", Ложь);
			Если ЗначениеЗаполнено(НастройкиЮрлица.ИдентификаторМЭДО) Тогда
				// Она подключена к МЭДО:
				ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Наименование = НастройкиЮрлица.НаименованиеМЭДО;
				ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Идентификатор = НастройкиЮрлица.ИдентификаторМЭДО;
			Иначе
				// Она не подключена к МЭДО:
				ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Наименование = МЭДОПереопределяемый.НаименованиеЮрлицаНаДату(
					ЮрлицоСсылка, ДатаСведений);
				ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Идентификатор = "" + ЮрлицоСсылка.УникальныйИдентификатор();
			КонецЕсли
		КонецЕсли;
	ИначеЕсли ЭтоКонтрагент(ЮрлицоСсылка) Тогда
		ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Наименование
			= МЭДОПереопределяемый.НаименованиеЮрлицаНаДату(ЮрлицоСсылка, ДатаСведений);
		ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Идентификатор = МЭДОПереопределяемый.ИдентификаторВнешнегоОбъекта(
			ЮрлицоСсылка, Обозначение_ВнешнийКонтрагент());
	КонецЕсли;
	
	ОтветственнаяСтруктурнаяЕдиница.ЮрлицоСсылка = ЮрлицоСсылка;
	
	Если ЗначениеЗаполнено(КонтактноеЛицоСсылка) Тогда
		ПоляКЛ = МЭДОПереопределяемый.ПоляКонтактногоЛица(КонтактноеЛицоСсылка, ДатаСведений);
		ОтветственнаяСтруктурнаяЕдиница.Персона.Наименование = ПоляКЛ.ФИО;
		// Если идентификатор контактного лица не найден в связях с другими системами, то отправим свой:
		ОтветственнаяСтруктурнаяЕдиница.Персона.Идентификатор = ЗаполненноеЗначение(
			ПоляКЛ.Идентификатор, "" + КонтактноеЛицоСсылка.УникальныйИдентификатор());
		ЗаполнитьЗначенияСвойств(
			ОтветственнаяСтруктурнаяЕдиница.Подразделение, ПоляКЛ.Подразделение);
		ЗаполнитьЗначенияСвойств(
			ОтветственнаяСтруктурнаяЕдиница.Должность, ПоляКЛ.Должность);
		
		ОтветственнаяСтруктурнаяЕдиница.КонтактнаяИнформацияПредставление
			= ПоляКЛ.КонтактнаяИнформацияПредставление;
			
		ОтветственнаяСтруктурнаяЕдиница.КонтактноеЛицоСсылка = КонтактноеЛицоСсылка;
	КонецЕсли;
	
	ОтветственнаяСтруктурнаяЕдиница.ПолноеПредставление
		= ПредставлениеОтветственнойСтруктурнойЕдиницы(ОтветственнаяСтруктурнаяЕдиница);
	
КонецПроцедуры

// Получить представление ответственной структурной единицы с предварительно заполненными остальными полями.
// 
// Параметры:
//  ОтветственнаяСтруктурнаяЕдиница - см. МЭДОСтруктурыДанных.НовыйОтветственнаяСтруктурнаяЕдиница.
// 
// Возвращаемое значение:
//  Строка
Функция ПредставлениеОтветственнойСтруктурнойЕдиницы(ОтветственнаяСтруктурнаяЕдиница)
	
	Возврат ЗаполненноеЗначениеСтрокой(
		НСтр("ru = 'Регион:'"),
		ОтветственнаяСтруктурнаяЕдиница.Регион.Наименование,
		Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Организация/Учреждение:'"),
			ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Наименование,
			Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'ФИО:'"),
			ОтветственнаяСтруктурнаяЕдиница.Персона.Наименование,
			Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Подразделение:'"),
			ОтветственнаяСтруктурнаяЕдиница.Подразделение.Наименование,
			Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Должность:'"),
			ОтветственнаяСтруктурнаяЕдиница.Должность.Наименование,
			Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Контактная информация:'"),
			ОтветственнаяСтруктурнаяЕдиница.КонтактнаяИнформацияПредставление,
			Символы.ПС, "");
	
КонецФункции

// Заполнить переданную структуру СведенияОДокументе.
// 
// Параметры:
//  СведенияОДокументе - см. МЭДОСтруктурыДанных.НовыйСведенияОДокументе
//  ЮрлицоСсылка - ОпределяемыйТип.ЮрлицоМЭДО
//  КонтактноеЛицоСсылка - ОпределяемыйТип.КонтактноеЛицоМЭДО
//  ДатаСведений - Дата -
//  РегистрационныеДанные - См. МЭДОСтруктурыДанных.НовыйРегистрация
//  Комментарий - Строка -
//  Настройки - См. РегистрыСведений.НастройкиОрганизацийМЭДО.НовыйНастройки
Процедура ЗаполнитьСведенияОДокументе(
	СведенияОДокументе,
	ЮрлицоСсылка,
	КонтактноеЛицоСсылка,
	ДатаСведений,
	РегистрационныеДанные,
	Комментарий,
	Настройки)
	
	Если ЭтоОрганизация(ЮрлицоСсылка) Тогда
		// Если это наша организация, то у нее уже будут настройки:
		Если ЮрлицоСсылка = Настройки.Организация Тогда
			СведенияОДокументе.Юрлицо.Наименование = Настройки.НаименованиеМЭДО;
			СведенияОДокументе.Юрлицо.Идентификатор = Настройки.ИдентификаторМЭДО;
		Иначе 
			// Другая организация в нашей базе:
			НастройкиЮрлица = РегистрыСведений.НастройкиОрганизацийМЭДО.НастройкиОрганизации(
				ЮрлицоСсылка, МЭДОСтруктурыДанных.НовыйЛегкийОтвет(), "НаименованиеМЭДО, ИдентификаторМЭДО", Ложь);
			Если ЗначениеЗаполнено(НастройкиЮрлица.ИдентификаторМЭДО) Тогда
				// Она подключена к МЭДО:
				СведенияОДокументе.Юрлицо.Наименование = НастройкиЮрлица.НаименованиеМЭДО;
				СведенияОДокументе.Юрлицо.Идентификатор = НастройкиЮрлица.ИдентификаторМЭДО;
			Иначе
				// Она не подключена к МЭДО:
				СведенияОДокументе.Юрлицо.Наименование = МЭДОПереопределяемый.НаименованиеЮрлицаНаДату(
					ЮрлицоСсылка, ДатаСведений);
				СведенияОДокументе.Юрлицо.Идентификатор = "" + ЮрлицоСсылка.УникальныйИдентификатор();
			КонецЕсли
		КонецЕсли;
	ИначеЕсли ЭтоКонтрагент(ЮрлицоСсылка) Тогда
		СведенияОДокументе.Юрлицо.Наименование = МЭДОПереопределяемый.НаименованиеЮрлицаНаДату(ЮрлицоСсылка, ДатаСведений);
		СведенияОДокументе.Юрлицо.Идентификатор = МЭДОПереопределяемый.ИдентификаторВнешнегоОбъекта(
			ЮрлицоСсылка, Обозначение_ВнешнийКонтрагент());
	КонецЕсли;
	
	СведенияОДокументе.ЮрлицоСсылка = ЮрлицоСсылка;
	
	Если ЗначениеЗаполнено(КонтактноеЛицоСсылка) Тогда
		ПоляКЛ = МЭДОПереопределяемый.ПоляКонтактногоЛица(КонтактноеЛицоСсылка, ДатаСведений);
		СведенияОДокументе.Персона.Наименование = ПоляКЛ.ФИО;
		// Если идентификатор контактного лица не найден в связях с другими системами, то отправим свой:
		СведенияОДокументе.Персона.Идентификатор = ЗаполненноеЗначение(
			ПоляКЛ.Идентификатор, "" + КонтактноеЛицоСсылка.УникальныйИдентификатор());
		ЗаполнитьЗначенияСвойств(
			СведенияОДокументе.Подразделение, ПоляКЛ.Подразделение);
		ЗаполнитьЗначенияСвойств(
			СведенияОДокументе.Должность, ПоляКЛ.Должность);
		
		СведенияОДокументе.КонтактноеЛицоСсылка = КонтактноеЛицоСсылка;
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(СведенияОДокументе.РегистрационныеДанные, РегистрационныеДанные);
	
	СведенияОДокументе.Комментарий = Комментарий;
	
	СведенияОДокументе.ПолноеПредставление = ПолучитьПредставлениеСведенийОДокументе(СведенияОДокументе);
	
КонецПроцедуры

Функция ПолучитьПредставлениеСведенийОДокументе(СведенияОДокументе)
	
	ТекстРегДанные = СтрШаблон(
		НСтр("ru = '%1 от %2'"),
		СведенияОДокументе.РегистрационныеДанные.РегистрационныйНомер,
		Формат(СведенияОДокументе.РегистрационныеДанные.ДатаРегистрации, "ДЛФ=D;"));
	
	Возврат ЗаполненноеЗначениеСтрокой(
		НСтр("ru = 'Регион:'"), СведенияОДокументе.Регион.Наименование, Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Организация/Учреждение:'"), СведенияОДокументе.Юрлицо.Наименование, Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'ФИО ответственного:'"), СведенияОДокументе.Персона.Наименование, Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Подразделение:'"), СведенияОДокументе.Подразделение.Наименование, Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Должность:'"), СведенияОДокументе.Должность.Наименование, Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Рег № доклада:'"), ТекстРегДанные, Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Комментарий:'"), СведенияОДокументе.Комментарий, Символы.ПС, "");
	
КонецФункции

// Создает каталог, если его еще не существует.
// 
// Параметры:
//  Путь - Строка - Путь к каталогу
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
// 
// Возвращаемое значение:
//  Булево - Истина - удалось, Ложь - нет.
Функция СоздатьКаталогЕслиНет(Путь, ДанныеОтвета = Неопределено)
	
	ВсеНормально = Истина;
	
	ПутьКаталог = Новый Файл(Путь);
	Если Не ПутьКаталог.Существует() Тогда
		Попытка
			СоздатьКаталог(Путь);
		Исключение
			ТекстОшибкиПодробно = СтрШаблон(НСтр("ru = 'Не удалось создать каталог: ""%1""
				|%2'"),
				Путь,
				ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				Путь,
				НСтр("ru = 'Ошибка создания каталога'"), 
				ТекстОшибкиПодробно,
				ДанныеОтвета);
			ВсеНормально = Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Возврат ВсеНормально;
	
КонецФункции

Функция ЭтоОрганизация(ЮрлицоСсылка)
	
	Возврат ЗначениеЗаполнено(ЮрлицоСсылка)
		И Метаданные.ОпределяемыеТипы.Организация.Тип.СодержитТип(ТипЗнч(ЮрлицоСсылка));
	
КонецФункции

Функция ЭтоКонтрагент(ЮрлицоСсылка)
	
	Возврат ЗначениеЗаполнено(ЮрлицоСсылка)
		И Метаданные.ОпределяемыеТипы.КонтрагентМЭДО.Тип.СодержитТип(ТипЗнч(ЮрлицоСсылка));
	
КонецФункции

// Вспомогательная процедура - Создать запись об ошибке в регистре - журнале ошибок.
// Вызывается как напрямую, так и в виде фонового задания, чтобы произвести запись даже в случае отмены транзакции.
// Вызывается только из процедуры ЗаписьВЖурналСобытий.
//
// Параметры:
//  СтруктураЗаписи - Структура:
//   * Идентификатор - Строка - Уникальный идентификатор
//   * Уровень - ПеречислениеСсылка.УровниСобытийМЭДО
//   * ДатаСобытия - Дата
//   * Объект - ОпределяемыйТип.ОбъектСОшибкойМЭДО
//   * ТекстОшибкиКратко - Строка
//   * ТекстОшибкиПодробно - Строка
//   * ЭтоФоновоеЗадание - Булево
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет
Процедура ЗаписьВЖурналСобытий_ВФонеИлиНепосредственно(СтруктураЗаписи, ДанныеОтвета) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запись = РегистрыСведений.ЖурналСобытийМЭДО.СоздатьМенеджерЗаписи();
	ЗаполнитьЗначенияСвойств(Запись, СтруктураЗаписи);
	
	Если ДанныеОтвета <> Неопределено
		И ДанныеОтвета.Свойство("Файл") И ЗначениеЗаполнено(ДанныеОтвета.Файл.ЛокальноеИмя) 
		И ТипЗнч(ДанныеОтвета.Файл.ДвоичныеДанные) = Тип("ДвоичныеДанные") Тогда
		Запись.АрхивЭСД	= Новый ХранилищеЗначения(ДанныеОтвета.Файл.ДвоичныеДанные);
		Запись.ИмяАрхиваЭСД = ДанныеОтвета.Файл.ЛокальноеИмя;
	КонецЕсли;
	
	Запись.Записать();
	
	
	// Дублируем в журнал регистрации:
	Если СтруктураЗаписи.Уровень = Перечисления.УровниСобытийМЭДО.Ошибка И СтруктураЗаписи.ЭтоФоновоеЗадание Тогда
		Объект = Неопределено;	МетаданныеОбъекта = Неопределено;
		Если ОбщегоНазначения.ЭтоСсылка(ТипЗнч(СтруктураЗаписи.Объект)) Тогда
			Объект = СтруктураЗаписи.Объект;
			МетаданныеОбъекта = Объект.Метаданные();
		КонецЕсли;
		
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Ошибка работы с МЭДО'"),
			УровеньЖурналаРегистрации.Ошибка,
			МетаданныеОбъекта,
			Объект,
			СтрШаблон(НСтр("ru = 'См. регистр ""СостоянияДокументовМЭДО"": %1'"), СтруктураЗаписи.ТекстОшибкиПодробно));
	КонецЕсли;
	
КонецПроцедуры

// Очистить старые записи журнала, согласно настройкам организации. Записи журнала также удаляются порциями.
// Записи удаляются, начиная с самых старых.
// 
// Параметры:
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ОчиститьСтарыеЗаписиЖурнала(ДанныеОтвета)
	
	ВремяХранения = МЭДОПовтИсп.ВремяХраненияЖурналаСобытий();
	Если ВремяХранения = 0 Тогда
		Возврат; // Настройка не задана, никакой обрезки не надо делать.
	КонецЕсли;
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 9999
		|	Журнал.Идентификатор,
		|	Журнал.Уровень,
		|	Журнал.ДатаСобытия КАК ДатаСобытия,
		|	Журнал.Объект
		|ИЗ
		|	РегистрСведений.ЖурналСобытийМЭДО КАК Журнал
		|ГДЕ
		|	Журнал.ДатаСобытия <= &ДатаОбрезки
		|
		|УПОРЯДОЧИТЬ ПО
		|	ДатаСобытия");
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "9999", Формат(МЭДОПовтИсп.РазмерПорцииОбработки(), "ЧГ=0;"));
	Запрос.УстановитьПараметр("ДатаОбрезки", ТекущаяДатаСеанса() - ВремяХранения * 86400);
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Набор = РегистрыСведений.ЖурналСобытийМЭДО.СоздатьНаборЗаписей();
		Набор.Отбор.Идентификатор.Установить(Выборка.Идентификатор);
		Набор.Отбор.Уровень.Установить(Выборка.Уровень);
		Набор.Отбор.ДатаСобытия.Установить(Выборка.ДатаСобытия);
		Набор.Отбор.Объект.Установить(Выборка.Объект);
		Набор.Записать();
	КонецЦикла;
	
КонецПроцедуры

// Из всех символов имени файла оставляем только разрешенные - английские буквы, цифры
// В расширении файла допустимо только 3 или 4 символа, если не хватает - дополняем "_"
// 
// Параметры:
//  ИмяФайла - Строка - Имя файла
// 
// Возвращаемое значение:
//  Строка - Заменить неподходящие символы
Функция ЗаменитьНеподходящиеСимволы(Знач ИмяФайла)
	
	ИмяФайла = СтроковыеФункции.СтрокаЛатиницей(ИмяФайла);
	
	ИмяФайлаНовое = "";
	ДлинаСтроки = СтрДлина(ИмяФайла);
	
	Для Счетчик = 1 По ДлинаСтроки Цикл
		Символ = Сред(ИмяФайла, Счетчик, 1);
		КодСимвола = КодСимвола(Символ);
		
		Если КодСимвола >= КодСимвола("a") И КодСимвола <= КодСимвола("z") Тогда
			ИмяФайлаНовое = ИмяФайлаНовое + Символ;
		ИначеЕсли КодСимвола >= КодСимвола("A") И КодСимвола <= КодСимвола("Z") Тогда 
			ИмяФайлаНовое = ИмяФайлаНовое + Символ;
		ИначеЕсли КодСимвола >= КодСимвола("0") И КодСимвола <= КодСимвола("9" ) Тогда 
			ИмяФайлаНовое = ИмяФайлаНовое + Символ;
		ИначеЕсли ДлинаСтроки > 4 Тогда
			// любой другой символа - на "_", в короткой строке или расширении не ставим даже "_".
			ИмяФайлаНовое = ИмяФайлаНовое + "_";
		КонецЕсли;
	КонецЦикла;
	
	Возврат ИмяФайлаНовое;
	
КонецФункции

// Преобразованная маска файлов linux. Для Windows как есть, для Linux нужен регистрозависимый поиск.
// 
// Параметры:
//  МаскаПоискаФайлов - Строка -
// 
// Возвращаемое значение:
//  Строка -
Функция ПреобразованнаяМаскаФайловLinux(МаскаПоискаФайлов)

	Маска = "";
	Если ОбщегоНазначения.ЭтоWindowsСервер() Тогда
		Маска = МаскаПоискаФайлов;
		Возврат Маска;
	КонецЕсли;
	
	// Для Linux регистрозависимый поиск:
	Для Позиция = 1 По СтрДлина(МаскаПоискаФайлов) Цикл
		Символ = Сред(МаскаПоискаФайлов, Позиция, 1);
		ВерхнийРегистр = ВРег(Символ);
		НижнийРегистр  = НРег(Символ);
		Если ВерхнийРегистр = НижнийРегистр Тогда
			Маска = Маска + Символ;
		Иначе
			Маска = Маска + "[" + ВерхнийРегистр + НижнийРегистр + "]";
		КонецЕсли;
	КонецЦикла;
	
	Возврат Маска;

КонецФункции

#Область ЧтениеЗаписьСредствамиXDTO

Функция НовыйОбъектКонтейнера(Тип, ВерсияМЭДО)
	
	Возврат ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИменДляКонтейнера(ВерсияМЭДО), Тип));
	
КонецФункции

// Новый вложенный объект XDTO сообщения.
// 
// Параметры:
//  Тип - Строка - Тип
//  ВерсияМЭДО - ПеречислениеСсылка.ВерсииФорматаМЭДО - Версия МЭДО
// 
// Возвращаемое значение:
//  ЗначениеXDTO, ОбъектXDTO - Новый объект сообщения
Функция НовыйОбъектСообщения(Тип, ВерсияМЭДО)
	
	Возврат ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИменДляСообщения(ВерсияМЭДО), Тип));
	
КонецФункции

Функция ПакетXDTOСообщенияПоВерсииМЭДО(ВерсияМЭДО)
	
	Возврат ФабрикаXDTO.Пакеты.Получить(ПространствоИменДляСообщения(ВерсияМЭДО));
	
КонецФункции

Функция ПакетXDTOКонтейнераПоВерсииМЭДО(ВерсияМЭДО)
	
	Возврат ФабрикаXDTO.Пакеты.Получить(ПространствоИменДляКонтейнера(ВерсияМЭДО));
	
КонецФункции

Функция ПространствоИменДляКонтейнера(ВерсияМЭДО)
	
	Если ВерсияМЭДО = "2.7.1" Или ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
		Возврат "urn:IEDMS:CONTAINER";
	КонецЕсли;
	
	Возврат "http://minsvyaz.ru/container";
	
КонецФункции

Функция ПространствоИменДляСообщения(ВерсияМЭДО)
	
	Если ВерсияМЭДО = "2.7.1" Или ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
		Возврат "urn:IEDMS:MESSAGE";
	КонецЕсли;
	
	Возврат "http://www.infpres.com/IEDMS";  // 2.5, 2.7
	
КонецФункции

// Версия паспорта может не совпадать с версией формата, есть исключения
Функция ВерсияПаспортаПоВерсииМЭДО(ВерсияМЭДО)
	
	Если ВерсияМЭДО = "2.7.1" Или ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
		Возврат "2.7.1";
	КонецЕсли;
	
	Возврат "1.0";
	
КонецФункции

// Прочитать XML фабрикой XDTO.
// ПРИМЕЧАНИЕ: 
// Для пакета XDTO для 2.7.1 IEDMSMessageМЭДО_2_7_1 сделаны некоторые "послабления", по сравнению с требованиями приказа.
// В частности для globalUniqueIdentifier шаблон убран
// в то время, как требуется: [a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}.
// Это нужно для того, чтобы загружать даже некорректные входящие пакеты. Некоторые гос.учреждения, в том числе и
// высокопоставленные могут присылать такие пакеты, из-за несоответствия xsd-схемы положению Приказа на стороне
// отправителя. Также в пакете могут быть получатели вообще без uid (пустой uid="").
// Но в исходящих сообщениях идентификаторы отправляются маленькими буквами, как положено.
// 
// Параметры:
//  ИмяФайла - Строка - Имя файла
//  ТипXDTO - ТипОбъектаXDTO, ТипЗначенияXDTO - Тип XDTO
//  ДанныеОтвета - См. МЭДОСтруктурыДанных.НовыйОтвет
// 
// Возвращаемое значение:
//  Неопределено
//  ОбъектXDTO
Функция ПрочитатьXMLФабрикой(ИмяФайла, ТипXDTO, ДанныеОтвета)

	ОбъектXDTOИзXML = Неопределено;

	ЧтениеXML = Новый ЧтениеXML();
	ЧтениеXML.ОткрытьФайл(ИмяФайла);
	Попытка
		ОбъектXDTOИзXML = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML, ТипXDTO);
		ЧтениеXML.Закрыть();
	Исключение
		ЧтениеXML.Закрыть();
		
		ТекстОшибкиПодробно = СтрШаблон(
			"%1: %2", Текст_ОшибкаЧтенияXml(), ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			ИмяФайла,
			Текст_ОшибкаЧтенияXml(),
			ТекстОшибкиПодробно,
			ДанныеОтвета);
	КонецПопытки;
	
	Возврат ОбъектXDTOИзXML;
	
КонецФункции

// Без помощи фабрики типов XDTO пытается вынуть нужные данные из файла.
// 
// Параметры:
//  ИмяФайла - Строка - Файл, который читаем.
//  ИмяТега - Строка - Имя тега, который ищем.
//  ИмяАтрибута - Строка - Имя атрибута, который ищем.
//  ДанныеОтвета - См. МЭДОСтруктурыДанных.НовыйОтвет
// 
// Возвращаемое значение:
//  Строка - Значение тега, или пустая строка, если нет такого тега (невалидный xml файл).
Функция ПрочитатьАтрибутИзXml(ИмяФайла, ИмяТега, ИмяАтрибута, ДанныеОтвета)
	
	ЗначениеАтрибута = "";
	
	#Если Не ВнешнееСоединение Тогда
	
	ЧтениеXml = Новый ЧтениеXML();
	ЧтениеXml.ОткрытьФайл(ИмяФайла);
	Попытка
		Пока ЧтениеXml.Прочитать() Цикл
			Если ЧтениеXml.ТипУзла = ТипУзлаXML.НачалоЭлемента И СтрНайти(ЧтениеXml.Имя, ИмяТега) > 0 Тогда
				Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
					Если СтрНайти(ЧтениеXml.Имя, ИмяАтрибута) > 0 Тогда 
						ЗначениеАтрибута = ЧтениеXml.Значение;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				Если ЗначениеЗаполнено(ЗначениеАтрибута) Тогда
					Прервать;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		ЧтениеXml.Закрыть();
	Исключение
		ЧтениеXml.Закрыть();
		ТекстПодробно = СтрШаблон(
				"%1 %2: %3", 
				Текст_ОшибкаЧтенияXml(), ИмяФайла, ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			ИмяФайла,
			Текст_ОшибкаЧтенияXml(),
			ТекстПодробно,
			ДанныеОтвета);
	КонецПопытки;
	
	#КонецЕсли
	
	Возврат ЗначениеАтрибута;
	
КонецФункции

Функция ЗначениеВМассивеXDTO(ПолеXDTO)
	
	Возврат ?(ТипЗнч(ПолеXDTO) = Тип("СписокXDTO"),
		ПолеXDTO,
		ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПолеXDTO));
	
КонецФункции

// Проверяет, есть ли свойство у объекта XDTO и оно заполнено.
// 
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - Объект XDTO
//  ИмяСвойства - Строка - Имя свойства
// 
// Возвращаемое значение:
//  Булево - Есть свойство объекта
Функция ЕстьСвойствоXDTO(ОбъектXDTO, ИмяСвойства)
	
	Возврат ОбъектXDTO.Свойства().Получить(ИмяСвойства) <> Неопределено И ОбъектXDTO[ИмяСвойства] <> Неопределено
	
КонецФункции

Функция СвойствоXDTOЕслиЕсть(ОбъектXDTO, ИмяСвойства, ЗначениеЕслиНет)
	
	Возврат ?(ЕстьСвойствоXDTO(ОбъектXDTO, ИмяСвойства), ОбъектXDTO[ИмяСвойства], ЗначениеЕслиНет);
	
КонецФункции

// Прочесть ограниченное значение. Если этого значения нет в сообщении xml, то возвращается пустая структура
// 
// Параметры:
//  ОбъектXDTOРодитель - ОбъектXDTO,Неопределено - Объект XDTO, свойство которого нужно прочесть
//  ИмяСвойства - Строка - Свойство должно иметь тип qualifiedValue, или по крайней мере иметь поля __content и id.
// 
// Возвращаемое значение:
//  Структура - см. МЭДОСтруктурыДанных.НовыйОграниченноеЗначение.
Функция ПрочитатьQualifiedValue(ОбъектXDTOРодитель, ИмяСвойства)
	
	Данные = МЭДОСтруктурыДанных.НовыйОграниченноеЗначение();
	ОбъектXDTO = СвойствоXDTOЕслиЕсть(ОбъектXDTOРодитель, ИмяСвойства, Неопределено);
	Если ОбъектXDTO <> Неопределено Тогда
		Данные.Идентификатор = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "id", "");
		Данные.Наименование = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "__content", "");
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

Функция ДатаФорматаDateTimeZone(Дата)
	
	Если Не ЗначениеЗаполнено(Дата) Тогда
		Возврат "";
	КонецЕсли;
		
	Возврат СтрШаблон(
		"%1+%2",
		Формат(Дата, "ДФ=гггг-ММ-дд'T'ЧЧ:мм:сс"),
		Формат((ТекущаяДатаСеанса() - ТекущаяУниверсальнаяДата()) / 3600, "ЧЦ=4; ЧДЦ=2; ЧРД=:; ЧВН=;") );
	
КонецФункции

// Возвращает дату из XML сообщения, которая в зависимости от версии может считываться средствами фабрики XDTO
// либо строкой либо непосредственно датой.
// 
// Параметры:
//  ДатаСтрокой - Строка,Дата - Дата строкой или датой, если сразу передана датой, то она и возвращается.
// 
// Возвращаемое значение:
//  Дата
Функция ЗначениеВДату(ДатаСтрокой)
	
	Если ТипЗнч(ДатаСтрокой) = Тип("Дата") Тогда
		Возврат ДатаСтрокой;// для 2.7 сразу дата.
	ИначеЕсли Не ЗначениеЗаполнено(ДатаСтрокой) Тогда
		Возврат '00010101';
	ИначеЕсли СтрНайти(Лев(ДатаСтрокой, 4), "-") = 0 Тогда
		Возврат XMLЗначение(Тип("Дата"), ДатаСтрокой);
	Иначе
		Возврат Дата(Сред(ДатаСтрокой, 7, 4) + Сред(ДатаСтрокой, 4, 2) + Лев(ДатаСтрокой, 2));
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область ТекстовыеКонстанты

Функция ИмяФайлаPassportXml()
	
	Возврат "passport.xml";
	
КонецФункции

Функция Текст_ВерсияНеПоддерживается(ВерсияМЭДО)
	
	Возврат СтрШаблон(
		НСтр("ru = 'Реализована только поддержка формата МЭДО 2.2, 2.5, 2.7, 2.7.1
		|Формат МЭДО ""%1"" не поддерживается'"), ВерсияМЭДО);
	
КонецФункции

Функция Текст_НеУдалосьНайтиСоздатьКонтрагента(Наименование, Идентификатор)
	
	Возврат СтрШаблон(
		НСтр("ru = 'Не удалось найти/создать контрагента: %1 - id=%2'"),
		Наименование,
		Идентификатор);
	
КонецФункции

Функция Текст_ОбъектПолученУспешно()
	
	Возврат НСтр("ru = 'Объект получен успешно'");
	
КонецФункции

Функция Текст_ОбъектОтправленУспешно()
	
	Возврат НСтр("ru = 'Объект отправлен успешно'");
	
КонецФункции

Функция Текст_ОшибкаЧтенияXml()
	
	Возврат НСтр("ru = 'Ошибка чтения/разбора файла XML'");
	
КонецФункции

Функция Текст_ОшибкаВКонтрагенте()
	
	Возврат НСтр("ru = 'Ошибка в контрагенте'");
	
КонецФункции

Функция Текст_ОшибкаВРегистреСостояний()
	
	Возврат НСтр("ru = 'Ошибка в регистре состояний'");
	
КонецФункции

Функция Текст_ОшибкаЗагрузкиВходящегоУведомления()
	
	Возврат НСтр("ru = 'Ошибка загрузки входящего уведомления'");
	
КонецФункции

Функция Текст_ОшибкаЗаписиКвитанции()
	
	Возврат НСтр("ru = 'Ошибка записи квитанции'");
	
КонецФункции

Функция ТекстПодробно_ОшибкаВУведомленииПоТипу(ТипУведомления)
	
	Возврат СтрШаблон(НСтр("ru = 'В уведомлении типа %1 не заполнен соответствующий раздел'"), ТипУведомления);
	
КонецФункции

Функция Текст_ОшибкаВУведомлении()
	
	Возврат НСтр("ru = 'Ошибка в исходящем уведомлении'")
	
КонецФункции

Функция Текст_КаталогНеСуществует()
	
	Возврат НСтр("ru = 'Каталог не существует или недоступен'");
	
КонецФункции

Функция Текст_ПроАвтоУведомлениеОбОтказе(Уведомление)
	
	Возврат ?(
		МЭДОПовтИсп.НужноСоздаватьУведомления(),
		СтрШаблон(НСтр("ru = 'Автоматически создано исходящее уведомление об отказе в регистрации %1'"), Уведомление),
		НСтр("ru = 'Автоматическое создание уведомлений отключено. Возможно, надо создать и отправить уведомление об отказе в регистрации'")
	);
	
КонецФункции

#КонецОбласти

#КонецОбласти
