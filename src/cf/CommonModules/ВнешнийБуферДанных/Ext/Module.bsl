////////////////////////////////////////////////////////////////////////////////
// Подсистема "Внешний буфер данных" (сервер).
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Записывает строку текста во внешний буфер (служебный файл на диске).
//
// Параметры:
//  Ключ - Строка - путь к файлу без указания корневой папки и расширения.
//  	Например, "Mail\CheckingBackgroundJobStatus\Thread_1".
// 		Примечание: запрещено использование символов квадратных скобок "[" и "]" в ключе.
//  Строка - Строка - произвольный текст, который будет записан в файл.
//
Процедура Записать(Ключ, Строка) Экспорт
	
	ПроверитьКлюч(Ключ);
	ПолноеИмяФайла = ИмяФайлаПоКлючу(Ключ);
	Попытка
		ЗаписьДанных = ВнешнийБуферДанныхПовтИсп.ЗаписьДанных(ПолноеИмяФайла);
		ЗаписьДанных.ЗаписатьСтроку(Строка);
	Исключение
		ПозицияПоследнегоРазделителя = СтрНайти(
			ПолноеИмяФайла, ПолучитьРазделительПути(), НаправлениеПоиска.СКонца);
		ИмяКаталога = Лев(ПолноеИмяФайла, ПозицияПоследнегоРазделителя - 1);
		Каталог = Новый Файл(ИмяКаталога);
		Если Не Каталог.Существует() Тогда
			// Создание каталога и повторная запись.
			СоздатьКаталогПоКлючу(Ключ);
			Если Каталог.Существует() Тогда
				Записать(Ключ, Строка);
			КонецЕсли;
		Иначе
			ТекстОшибки = СтрШаблон(
				НСтр("ru = 'Ошибка при попытке записи строки во внешний буфер данных.
					|%1
					|
					|Ключ: %2
					|Строка текста: %3'"),
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), Ключ, Строка);
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
	КонецПопытки;
	
КонецПроцедуры

// Возвращает весь текст, полученный по переданному ключу.
// Если файл по ключу не найден, возвращается Неопределено.
//
// Параметры:
//  Ключ - Строка - путь к файлу без указания корневой папки и расширения.
//
// Возвращаемое значение:
//  Строка, Неопределено - весь текст из файла, найденного по ключу. Если файл не найден, то Неопределено.
//
Функция Прочитать(Ключ) Экспорт
	
	Возврат ПрочитатьСлужебный(Ключ);
	
КонецФункции

// Удаляет файл.
//
// Параметры:
//  Ключ - Строка - путь к файлу без указания корневой папки и расширения.
//
// Возвращаемое значение:
//  Булево - Истина, если файл удален успешно, либо ключ (группа ключей) отсутствует,
//  	Ложь, если при попытке удаления возникла ошибка.
//
Функция Удалить(Ключ) Экспорт
	
	ВыполненоУспешно = Ложь;
	ПолноеИмяФайла = ИмяФайлаПоКлючу(Ключ);
	Попытка
		
		Файл = Новый Файл(ПолноеИмяФайла);
		ФайлыДляЗакрытияЗаписи = Новый Массив;
		Если Не Файл.Существует() Тогда
			Возврат Истина;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(Файл.Расширение) Тогда
			ФайлыДляЗакрытияЗаписи.Добавить(Файл);
		Иначе // Это каталог.
			ФайлыДляЗакрытияЗаписи = НайтиФайлы(Файл.ПолноеИмя, "*", Истина);
		КонецЕсли;
		
		ЛимитКоличестваФайловДляОбработки = 100;
		Если ФайлыДляЗакрытияЗаписи.Количество() > ЛимитКоличестваФайловДляОбработки Тогда
			// Очистка кэша повт. исп. закроет все файлы.
			ОбновитьПовторноИспользуемыеЗначения();
		Иначе
			// Закрытие файлов без очистки кэша.
			Для Каждого ФайлДляЗакрытия Из ФайлыДляЗакрытияЗаписи Цикл
				Если ЗначениеЗаполнено(ФайлДляЗакрытия.Расширение) Тогда
					ЗаписьДанных = ВнешнийБуферДанныхПовтИсп.ЗаписьДанных(ФайлДляЗакрытия.ПолноеИмя);
					ЗаписьДанных.Закрыть();
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		УдалитьФайлы(ПолноеИмяФайла);
		ВыполненоУспешно = Истина;
		
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗаписьЖурналаРегистрации(
			ИмяСобытияЖурналаРегистрации(),
			УровеньЖурналаРегистрации.Предупреждение,,,
			СтрШаблон(НСтр("ru = 'Ошибка при удалении по ключу ""%1"":
				|%2'"), Ключ, ТекстОшибки));
	КонецПопытки;
	
	Возврат ВыполненоУспешно;
	
КонецФункции

// Перемещает информацию из одного ключа в другой (через перемещение служебного файла).
//
// Параметры:
//  СтарыйКлюч - Строка - старый путь к файлу без указания корневой папки и расширения.
//  НовыйКлюч - Строка - новый путь к файлу без указания корневой папки и расширения.
//
// Возвращаемое значение:
//  Булево - Истина, если файл перемещен успешно, Ложь, если возникла ошибка.
//
Функция Переместить(СтарыйКлюч, НовыйКлюч) Экспорт
	
	ВыполненоУспешно = Ложь;
	ПолноеИмяФайлаСтарое = ИмяФайлаПоКлючу(СтарыйКлюч);
	ПолноеИмяФайлаНовое = ИмяФайлаПоКлючу(НовыйКлюч);
	Попытка
		Файл = Новый Файл(ПолноеИмяФайлаСтарое);
		Если Не Файл.Существует() Тогда
			ВызватьИсключение СтрШаблон(
				НСтр("ru = 'Ключ ""%1"" не найден во внешнем буфере'"), ПолноеИмяФайлаСтарое);
		КонецЕсли;
		ПереместитьФайл(ПолноеИмяФайлаСтарое, ПолноеИмяФайлаНовое);
		ВыполненоУспешно = Истина;
	Исключение
		ПозицияПоследнегоРазделителя = СтрНайти(
			ПолноеИмяФайлаНовое, ПолучитьРазделительПути(), НаправлениеПоиска.СКонца);
		ИмяКаталога = Лев(ПолноеИмяФайлаНовое, ПозицияПоследнегоРазделителя - 1);
		Каталог = Новый Файл(ИмяКаталога);
		Если Не Каталог.Существует() Тогда
			// Создание каталога и повторное перемещение.
			СоздатьКаталогПоКлючу(НовыйКлюч);
			Если Каталог.Существует() Тогда
				ВыполненоУспешно = Переместить(СтарыйКлюч, НовыйКлюч);
			КонецЕсли;
		Иначе
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ЗаписьЖурналаРегистрации(
				ИмяСобытияЖурналаРегистрации(),
				УровеньЖурналаРегистрации.Предупреждение,,,
				СтрШаблон(НСтр("ru = 'Не удалось переместить ""%1"" в ""%2"":
					|%3'"), СтарыйКлюч, НовыйКлюч, ТекстОшибки));
		КонецЕсли;
	КонецПопытки;
	
	Возврат ВыполненоУспешно;
	
КонецФункции

// Ищет ключи по переданной маске.
// 
// Параметры:
//  Маска - Строка - маска поиска. Можно использовать спец. символы:
//			"*" - произвольная последовательность любых символов,
//			"?" - один произвольный символ.
// 		Примечание: запрещено использование символов квадратных скобок "[" и "]" в маске.
// 
// Возвращаемое значение:
//  Массив - массив строк с найденными ключами.
//  	Пример найденной строки: "Folder1\SubFolder2\Thread_10"
// 
// Примеры вызова:
// 	НайтиКлючи("Folder*")
// 	НайтиКлючи("Folder1\Thread_*")
// 	НайтиКлючи("Folder1\Thread_???")
// 	НайтиКлючи("Folder1\SubFolder*\Thread_*")
// 
Функция НайтиКлючи(Знач Маска) Экспорт
	
	Ключи = Новый Массив;
	
	ПроверитьМаску(Маска);
	РасширениеФайлов = РасширениеФайлов();
	Маска = Маска + РасширениеФайлов;
	
	// Разбор маски на фрагменты.
	// Часть из них будет использоваться как путь, другая - как маска поиска.
	Путь = "";
	ЕстьСпецСимвол = Ложь;
	МаскаДляПоискаФайлов = "";
	РазделительПути = ПолучитьРазделительПути();
	ПодстрокиПоиска = СтрРазделить(Маска, РазделительПути);
	КоличествоПодстрок = ПодстрокиПоиска.Количество();
	Для Сч = 1 По КоличествоПодстрок Цикл
		ПодстрокаПоиска = ПодстрокиПоиска[Сч-1];
		ПозицияПервогоСпецСимвола = СтрНайти(ПодстрокаПоиска, "*");
		ПозицияВопросительногоЗнака = СтрНайти(ПодстрокаПоиска, "?");
		Если ПозицияВопросительногоЗнака > 0
			И (ПозицияПервогоСпецСимвола = 0 Или ПозицияВопросительногоЗнака < ПозицияПервогоСпецСимвола) Тогда
			ПозицияПервогоСпецСимвола = ПозицияВопросительногоЗнака;
		КонецЕсли;
		Если ПозицияПервогоСпецСимвола > 0 Тогда
			МаскаДляПоискаФайлов = Лев(ПодстрокаПоиска, ПозицияПервогоСпецСимвола - 1) + "*";
			ЕстьСпецСимвол = Истина;
			Прервать;
		ИначеЕсли Сч = КоличествоПодстрок Тогда // Последняя подстрока
			МаскаДляПоискаФайлов = ПодстрокаПоиска;
		Иначе
			Путь = Путь + ?(Путь = "", "", РазделительПути) + ПодстрокаПоиска;
		КонецЕсли;
	КонецЦикла;
	
	// Поиск файлов в каталоге.
	КорневойКаталог = ВнешнийБуферДанныхПовтИсп.КорневойКаталог();
	НайденныеФайлы = НайтиФайлы(КорневойКаталог + Путь, МаскаДляПоискаФайлов, Ложь);
	ВсеПретенденты = Новый Массив;
	Для Каждого Файл Из НайденныеФайлы Цикл
		Если ЗначениеЗаполнено(Файл.Расширение) Тогда // Файл.
			ВсеПретенденты.Добавить(Файл.ПолноеИмя);
		ИначеЕсли ЕстьСпецСимвол Тогда // Каталог
			НайденныеФайлыВПодкаталоге = НайтиФайлы(Файл.ПолноеИмя, "*", Истина);
			Для Каждого ФайлВПодкаталоге Из НайденныеФайлыВПодкаталоге Цикл
				Если ЗначениеЗаполнено(ФайлВПодкаталоге.Расширение) Тогда
					ВсеПретенденты.Добавить(ФайлВПодкаталоге.ПолноеИмя);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	// Проверка на соответствие полной маске.
	ИменаОтобранныхФайлов = ВсеПретенденты;
	Если ЕстьСпецСимвол Тогда
		Запрос = Новый Запрос(
			"ВЫБРАТЬ
			|	ТаблицаПретендентов.Имя КАК Имя
			|ПОМЕСТИТЬ ТаблицаПретендентов
			|ИЗ
			|	&ТаблицаПретендентов КАК ТаблицаПретендентов
			|ГДЕ
			|	ТаблицаПретендентов.Имя ПОДОБНО &Маска
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ
			|	Имя КАК Имя
			|ИЗ
			|	ТаблицаПретендентов КАК ТаблицаПретендентов");
		МаскаДляЗапроса = КорневойКаталог + СтрЗаменить(Маска, "*", "%");
		МаскаДляЗапроса = СтрЗаменить(МаскаДляЗапроса, "?", "_");
		ТаблицаПретендентов = Новый ТаблицаЗначений;
		ТаблицаПретендентов.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
		Для Сч = 1 По ВсеПретенденты.Количество() Цикл
			ТаблицаПретендентов.Добавить();
		КонецЦикла;
		ТаблицаПретендентов.ЗагрузитьКолонку(ВсеПретенденты, "Имя");
		Запрос.УстановитьПараметр("Маска", МаскаДляЗапроса);
		Запрос.УстановитьПараметр("ТаблицаПретендентов", ТаблицаПретендентов);
		ИменаОтобранныхФайлов = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Имя");
	КонецЕсли;
	
	// Отбрасывание имени корневого каталога и расширения файла.
	ДлинаИмениКорневогоКаталога = СтрДлина(КорневойКаталог);
	Для Каждого ИмяФайла Из ИменаОтобранныхФайлов Цикл
		Ключи.Добавить(СтрЗаменить(Сред(ИмяФайла, ДлинаИмениКорневогоКаталога + 1), РасширениеФайлов, ""));
	КонецЦикла;
	
	Возврат Ключи;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция РасширениеФайлов()
	
	Возврат ".txt";
	
КонецФункции

Функция ИмяФайлаПоКлючу(Ключ)
	
	ИмяФайла = ВнешнийБуферДанныхПовтИсп.КорневойКаталог() + Ключ + РасширениеФайлов();
	Возврат ИмяФайла;
	
КонецФункции

Функция ИмяСобытияЖурналаРегистрации()
	
	Возврат "Внешний буфер данных";
	
КонецФункции

Процедура ПроверитьКлюч(Ключ)
	
	ЕстьНедопустимыеСимволы = СтрНайти(Ключ, "[") > 0 Или СтрНайти(Ключ, "]") > 0;
	Если ЕстьНедопустимыеСимволы Тогда
		ТекстОшибки = НСтр("ru = 'Ключ не должен содержать следующие символы: [ ]'");
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
КонецПроцедуры

Процедура ПроверитьМаску(Маска)
	
	ЕстьНедопустимыеСимволы = СтрНайти(Маска, "[") > 0 Или СтрНайти(Маска, "]") > 0;
	Если ЕстьНедопустимыеСимволы Тогда
		ТекстОшибки = НСтр("ru = 'Маска не должна содержать следующие символы: [ ]'");
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
КонецПроцедуры

Процедура СоздатьКаталогПоКлючу(Ключ)
	
	РазделительПути = ПолучитьРазделительПути();
	ИмяТекущейПапки = ВнешнийБуферДанныхПовтИсп.КорневойКаталог();
	ИменаПодпапок = СтрРазделить(Ключ, РазделительПути, Ложь);
	ИменаПодпапок.Удалить(ИменаПодпапок.Количество() - 1);
	Для Каждого ИмяПодпапки Из ИменаПодпапок Цикл
		ИмяТекущейПапки = ИмяТекущейПапки + ИмяПодпапки + РазделительПути;
		СоздатьКаталог(ИмяТекущейПапки);
	КонецЦикла;
	
КонецПроцедуры

Функция ПрочитатьСлужебный(Ключ, НомерПопытки = 1)
	
	Текст = Неопределено;
	ПолноеИмяФайла = ИмяФайлаПоКлючу(Ключ);
	Попытка
		ЧтениеДанных = Новый ЧтениеДанных(ПолноеИмяФайла,,,, "");
		Текст = СокрЛП(ЧтениеДанных.ПрочитатьСимволы());
		ЧтениеДанных.Закрыть();
	Исключение
		// Если файла нет, возвращается значение по умолчанию.
		Файл = Новый Файл(ПолноеИмяФайла);
		Если Файл.Существует() Тогда
			ЛимитПопыток = 3;
			Если НомерПопытки < ЛимитПопыток Тогда
				// Повторная попытка на случай, если ошибка временная.
				// Например, файл мог удаляться в момент чтения, из-за чего возникла ошибка совместного доступа.
				Текст = ПрочитатьСлужебный(Ключ, НомерПопытки + 1);
			Иначе
				ВызватьИсключение;
			КонецЕсли;
		КонецЕсли;
	КонецПопытки;
	
	Возврат Текст;
	
КонецФункции

#КонецОбласти
