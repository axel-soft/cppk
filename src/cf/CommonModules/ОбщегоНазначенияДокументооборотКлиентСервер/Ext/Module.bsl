////////////////////////////////////////////////////////////////////////////////
// Общего назначения документооборот клиент сервер:
//  
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

#Область СрокиИсполнения

// Возвращает формат даты для сроков в зависимости от использования
// времени в сроках.
//
// Параметры:
//  ИспользоватьДатуИВремяВСроках - Булево
//
// Возвращаемое значение:
//  Строка
//
Функция ФорматДатыСроков(ИспользоватьДатуИВремяВСроках) Экспорт
	
	Если ИспользоватьДатуИВремяВСроках Тогда
		Шаблон = "ДФ='dd.MM.yy HH:mm'; ДП='%1'";
	Иначе
		Шаблон = "ДФ='dd.MM.yy'; ДП='%1'";
	КонецЕсли;
	
	Возврат СтрШаблон(Шаблон, НСтр("ru = 'не определен'"));
	
КонецФункции

// Возвращает варианты установки срока исполнения
//
// Возвращаемое значение:
//  Структура:
//   * ТочныйСрок - ПеречислениеСсылка.ВариантыУстановкиСрокаИсполнения
//   * ОтносительныйСрок - ПеречислениеСсылка.ВариантыУстановкиСрокаИсполнения
//
Функция ВариантыУстановкиСрокаИсполнения() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТочныйСрок",
		ПредопределенноеЗначение("Перечисление.ВариантыУстановкиСрокаИсполнения.ТочныйСрок"));
	Результат.Вставить("ОтносительныйСрок",
		ПредопределенноеЗначение("Перечисление.ВариантыУстановкиСрокаИсполнения.ОтносительныйСрок"));
		
	Возврат Результат;
		
КонецФункции

// Возвращает представление длительности.
//
// Параметры:
//  Дни - Число - длительность, дней.
//  Часы - Число - длительность, часов.
//  Минуты - Число - длительность, минут.
//
// Возвращаемое значение:
//  Строка - представление длительности строкой.
//
Функция ПредставлениеДлительности(Дни, Часы, Минуты) Экспорт
	
	Если Дни = 0 И Часы = 0 И Минуты = 0 Тогда
		Возврат НСтр("ru = 'не определен'");
	КонецЕсли;
	
	ПредставлениеДни = "";
	ПредставлениеЧасы = "";
	ПредставлениеМинуты = "";
	
	ЕстьДни = ЗначениеЗаполнено(Дни);
	ЕстьЧасы = ЗначениеЗаполнено(Часы);
	ЕстьМинуты = ЗначениеЗаполнено(Минуты);
	
	Если ЕстьДни Тогда
		
		Если ЕстьЧасы И ЕстьМинуты Тогда 
			ШаблонПредставления = НСтр("ru = '%1 дн.'");
		Иначе
			ШаблонПредставления = "%1 "
				+ ОбщегоНазначенияДокументооборотКлиентСервер.ПредметИсчисленияПрописью(
					Дни, НСтр("ru = 'день, дня, дней'"));
		КонецЕсли;
		
		ПредставлениеДни = СтрШаблон(ШаблонПредставления, Дни);
	КонецЕсли;
	
	Если ЕстьЧасы Тогда
		
		Если ЕстьДни И ЕстьМинуты Тогда
			ШаблонПредставления = НСтр("ru = ' %1 ч.'");
		Иначе
			ШаблонПредставления = " %1 "
				+ ОбщегоНазначенияДокументооборотКлиентСервер.ПредметИсчисленияПрописью(
					Часы, НСтр("ru = 'час, часа, часов'"));
		КонецЕсли;
		
		ПредставлениеЧасы = СтрШаблон(ШаблонПредставления, Часы);
	КонецЕсли;
	
	Если ЕстьМинуты Тогда
		
		Если ЕстьДни И ЕстьЧасы Тогда
			ШаблонПредставления = НСтр("ru = ' %1 мин.'");
		Иначе
			ШаблонПредставления = " %1 "
				+ ОбщегоНазначенияДокументооборотКлиентСервер.ПредметИсчисленияПрописью(
					Минуты, НСтр("ru = 'минута, минуты, минут'"));
		КонецЕсли;
		
		ПредставлениеМинуты = СтрШаблон(ШаблонПредставления, Минуты);
	КонецЕсли;
	
	Представление = ПредставлениеДни + ПредставлениеЧасы + ПредставлениеМинуты;
	
	Представление = СокрЛП(Представление);
	
	Возврат Представление;
	
КонецФункции

// Возвращает представление срока исполнения в виде
// дата (длительность) или длительность (дата).
//
// Параметры:
//  Дата - Дата - срок исполнения датой.
//  Дни - Число - длительность, дней.
//  Часы - Число - длительность, часов.
//  Минуты - Число - длительность, минут.
//  ИспользоватьДатуИВремяВСроках - Булево - признак использования даты и времени в сроках.
//  ВариантУстановкиСрока - ПеречислениеСсылка.ВариантыУстановкиСрокаИсполнения - вариант
//                          установки срока исполнения.
//
// Возвращаемое значение:
//  Строка
//
Функция ПредставлениеСрокаИсполнения(Дата, Дни, Часы, Минуты,
	ИспользоватьДатуИВремяВСроках, ВариантУстановкиСрока) Экспорт
	
	Представление = "";
	
	ЗаполненТочныйСрок = ЗначениеЗаполнено(Дата);
	
	ЗаполненОтносительныйСрок = Дни > 0
		Или (ИспользоватьДатуИВремяВСроках И (Часы > 0 Или Минуты > 0));
	
	Если Не ЗаполненТочныйСрок И Не ЗаполненОтносительныйСрок Тогда
		Возврат Представление;
	КонецЕсли;
	
	ФормаДаты = ФорматДатыСроков(ИспользоватьДатуИВремяВСроках);
	
	Если ЗаполненТочныйСрок И ЗаполненОтносительныйСрок Тогда
		
		ВариантыУстановкиСрока = ВариантыУстановкиСрокаИсполнения();
		
		Если ВариантУстановкиСрока = ВариантыУстановкиСрока.ТочныйСрок Тогда
			ПерваяЧастьПредставления = Формат(Дата, ФормаДаты);
			Если ИспользоватьДатуИВремяВСроках Тогда
				ВтораяЧастьПердставления = ПредставлениеДлительности(Дни, Часы, Минуты);
			Иначе
				ВтораяЧастьПердставления = ПредставлениеДлительности(Дни, 0, 0);
			КонецЕсли;
		Иначе
			ВтораяЧастьПердставления = Формат(Дата, ФормаДаты);
			Если ИспользоватьДатуИВремяВСроках Тогда
				ПерваяЧастьПредставления = ПредставлениеДлительности(Дни, Часы, Минуты);
			Иначе
				ПерваяЧастьПредставления = ПредставлениеДлительности(Дни, 0, 0);
			КонецЕсли;
		КонецЕсли;
		
		Представление = СтрШаблон("%1 (%2)",
			ПерваяЧастьПредставления,
			ВтораяЧастьПердставления);
		
	ИначеЕсли ЗаполненТочныйСрок Тогда
		Представление = Формат(Дата, ФормаДаты);
	Иначе
		Представление = ПредставлениеДлительности(Дни, Часы, Минуты);
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции

// Меняет относительный срок (дни, часы, минуты), добавляя переданную длительность.
// Если заполнены минуты, то меняются только минуты.
// Если минут нет и заполнены часы, то меняются только часы.
// Если заполнены только дни, то меняются только они.
//
// Параметры:
//  Дни - Число - длительность, дней.
//  Часы - Число - длительность, часов.
//  Минуты - Число - длительность, минут.
//  Длительность - Число - добавляемая длительность (1 или -1).
//                 Для уменьшения срока используется "-1", для увеличения "1".
//
Процедура ИзменитьОтносительныйСрок(Дни, Часы, Минуты, Длительность) Экспорт
	
	Если ЗначениеЗаполнено(Минуты) Тогда
		Минуты = Минуты + Длительность;
	ИначеЕсли ЗначениеЗаполнено(Часы) Тогда
		Часы = Часы + Длительность;
	Иначе
		Дни = Дни + Длительность;
	КонецЕсли;
	
	Если Минуты > 59 Тогда
		Минуты = Минуты - 60;
		Часы = Часы + 1;
	КонецЕсли;
	
	Если Часы > 23 Тогда
		Часы = Часы - 23;
		Дни = Дни + 1;
	КонецЕсли;
	
	Если Дни > 999 Тогда
		Дни = 999;
	КонецЕсли;
	
КонецПроцедуры

// Возвращает дату по представлению
//
// Параметры:
//   ПредставлениеДаты - Строка - дата в виде строки
//
// Возвращаемое значение:
//   Дата, Неопределено - если по представлению не удалось определить дату, то возвращается Неопределено.
//
Функция ДатаПоПредставлению(ПредставлениеДаты) Экспорт
	
	Результат = Неопределено;
	
	Если Не ЗначениеЗаполнено(ПредставлениеДаты) Тогда
		Возврат Результат;
	КонецЕсли;
	
	День = 0;
	Месяц = 0;
	Год = 0;
	Часы = 0;
	Минуты = 0;
	
	РазделительДатыВремени = НСтр("ru = ' '");
	РазделительВоВремени1 = НСтр("ru = ':'");
	РазделительВоВремени2 = НСтр("ru = '.'");
	РазделительВоВремени3 = НСтр("ru = ','");
	РазделительДаты1 = НСтр("ru = '.'");
	РазделительДаты2 = НСтр("ru = ','");
	
	СтрДатаИВремя = СтрРазделить(ПредставлениеДаты, РазделительДатыВремени);
	КолСтрДатаИВремя = СтрДатаИВремя.Количество();
	
	Если КолСтрДатаИВремя > 2 Тогда
		Возврат Результат;
	КонецЕсли;
	
	СтрДатаИВремя[0] = СтрЗаменить(СтрДатаИВремя[0], РазделительДаты2, РазделительДаты1);
	
	СтрДата = СтрРазделить(СтрДатаИВремя[0], РазделительДаты1);
	КолСтрДата = СтрДата.Количество();
	
	Если КолСтрДата <> 3 Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если ЭтоЧисло(СтрДата[0]) Тогда
		День = Число(СтрДата[0]);
	Иначе
		Возврат Результат;
	КонецЕсли;
	
	Если ЭтоЧисло(СтрДата[1]) Тогда
		Месяц = Число(СтрДата[1]);
	Иначе
		Возврат Результат;
	КонецЕсли;
	
	Если ЭтоЧисло(СтрДата[2]) Тогда
		Год = Число(СтрДата[2]);
	Иначе
		Возврат Результат;
	КонецЕсли;
	
	Если День > 31 Тогда
		ЗначениеГод = День;
		День = Год;
		Год = ЗначениеГод;
	КонецЕсли;
	
	Если Год < 100 Тогда
		Год = Год + 2000;
	КонецЕсли;
	
	Если КолСтрДатаИВремя = 2 Тогда
		
		СтрДатаИВремя[1] = СтрЗаменить(СтрДатаИВремя[1], РазделительВоВремени2, РазделительВоВремени1);
		СтрДатаИВремя[1] = СтрЗаменить(СтрДатаИВремя[1], РазделительВоВремени3, РазделительВоВремени1);
		
		СтрВремя = СтрРазделить(СтрДатаИВремя[1], РазделительВоВремени1);
		КолСтрВремя = СтрВремя.Количество();
		
		Если КолСтрВремя = 1 Или КолСтрВремя > 2 Тогда
			Возврат Результат;
		Иначе
			
			Если ЭтоЧисло(СтрВремя[0]) Тогда
				Часы = Число(СтрВремя[0]);
			Иначе
				Возврат Результат;
			КонецЕсли;
			
			Если ЭтоЧисло(СтрВремя[1]) Тогда
				Минуты = Число(СтрВремя[1]);
			Иначе
				Возврат Результат;
			КонецЕсли;
			
		КонецЕсли;
		
	Иначе
		#Если Сервер Тогда
			ТекущаяДата = ТекущаяДатаСеанса();
		#Иначе
			ТекущаяДата = ТекущаяДата();
		#КонецЕсли
		Часы = Час(ТекущаяДата);
		Минуты = Минута(ТекущаяДата);
	КонецЕсли;
	
	Попытка
		Результат = Дата(Год, Месяц, День, Часы, Минуты, 0);
	Исключение
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Возвращает длительность по представлению
//
// Параметры:
//   ПредставлениеДлительности - Строка - представление длительности
//
// Возвращаемое значение:
//   Структура
//     * Дни - Число
//     * Часы - Число
//     * Минуты - Число
//
Функция ДлительностьПоПредставлению(ПредставлениеДлительности) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Дни", 0);
	Результат.Вставить("Часы", 0);
	Результат.Вставить("Минуты", 0);
	
	// Если передана пустая строка, то возвращает нулевая длительность.
	Если Не ЗначениеЗаполнено(ПредставлениеДлительности) Тогда
		Возврат Результат;
	КонецЕсли;
	
	СтрокаДляОбработки = СокрЛ(ПредставлениеДлительности);
	
	// Если представление длительности содержит только число, то
	// возвращается длительность с указанным количеством дней.
	Если ЭтоЧисло(СтрокаДляОбработки) Тогда
		Результат.Дни = Число(СтрокаДляОбработки);
		Возврат Результат;
	КонецЕсли;
	
	// Если в строке указаны спец. символы, то возвращается
	// Неопределено, т.е. ошибка.
	Если СтрНайти(СтрокаДляОбработки, "@")
		Или СтрНайти(СтрокаДляОбработки, "#")
		Или СтрНайти(СтрокаДляОбработки, "$") Тогда
		
		Возврат Неопределено;
	КонецЕсли;
	
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'дней'"), " @ ");
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'день'"), " @ ");
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'дня'"), " @ ");
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'дн.'"), " @ ");
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'д.'"), " @ ");
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'д'"), " @ ");
	
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'часов'"), " # ");
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'часа'"), " # ");
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'час'"), " # ");
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'ч.'"), " # ");
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'ч'"), " # ");
	
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'минуты'"), " $ ");
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'минута'"), " $ ");
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'минут'"), " $ ");
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'мин.'"), " $ ");
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'мин'"), " $ ");
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'м.'"), " $ ");
	СтрокаДляОбработки = СтрЗаменить(СтрокаДляОбработки, НСтр("ru = 'м'"), " $ ");
	
	ЧислоОбозначенийДн = СтрЧислоВхождений(СтрокаДляОбработки, "@");
	ЧислоОбозначенийЧ = СтрЧислоВхождений(СтрокаДляОбработки, "#");
	ЧислоОбозначенийМин = СтрЧислоВхождений(СтрокаДляОбработки, "$");
	
	// Если в строке указано несколько обозначений дней, часов или минут, то возвращается
	// Неопределено, т.е. ошибка.
	Если ЧислоОбозначенийДн > 1 Или ЧислоОбозначенийЧ > 1 Или ЧислоОбозначенийМин > 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ЧислоОбозначенийДн > 0 Тогда
		СтрокиДляОбработки = СтрРазделить(СтрокаДляОбработки, "@");
		Если ЭтоЧисло(СокрЛП(СтрокиДляОбработки[0])) Тогда
			Дни = Число(СтрокиДляОбработки[0]);
			Результат.Дни = Окр(Дни, 0, 1);
		КонецЕсли;
		
		Если СтрокиДляОбработки.Количество() > 1 Тогда
			СтрокаДляОбработки = СтрокиДляОбработки[1];
		КонецЕсли;
	КонецЕсли;
	
	Если ЧислоОбозначенийЧ > 0 Тогда
		СтрокиДляОбработки = СтрРазделить(СтрокаДляОбработки, "#");
		Если ЭтоЧисло(СокрЛП(СтрокиДляОбработки[0])) Тогда
			Часы = Число(СтрокиДляОбработки[0]);
			Результат.Часы = Окр(Часы, 0, 1);
		КонецЕсли;
		
		Если СтрокиДляОбработки.Количество() > 1 Тогда
			СтрокаДляОбработки = СтрокиДляОбработки[1];
		КонецЕсли;
	КонецЕсли;
	
	Если ЧислоОбозначенийМин > 0 Тогда
		СтрокиДляОбработки = СтрРазделить(СтрокаДляОбработки, "$");
		Если ЭтоЧисло(СокрЛП(СтрокиДляОбработки[0])) Тогда
			Минуты = Число(СтрокиДляОбработки[0]);
			Результат.Минуты = Окр(Минуты, 0, 1);
		КонецЕсли;
	КонецЕсли;
	
	// Корректировка значений
	Если Результат.Дни > 999 Тогда
		Результат.Дни = 999;
	КонецЕсли;
	Если Результат.Часы > 23 Тогда
		Результат.Часы = 23;
	КонецЕсли;
	Если Результат.Минуты > 59 Тогда
		Результат.Минуты = 59;
	КонецЕсли;
	
	Если Результат.Дни = 0 И Результат.Часы = 0 И Результат.Минуты = 0 Тогда
		Возврат Неопределено;
	Иначе
		Возврат Результат;
	КонецЕсли;
	
КонецФункции

#КонецОбласти

// Удаляет из массив вытесняемое значение, при наличии в массиве вытесняющего значения.
//
// Параметры:
//  ОбрабатываемыйМассив - Массив       - Массив, из которого происходит вытеснение.
//  ВытесняющееЗначение  - Произвольный - Значение, наличие которого приводит к вытеснению.
//  ВытесняемоеЗначение  - Произвольный - Значение, вытеснение которого производится.
//
Процедура ВытеснитьИзМассива(ОбрабатываемыйМассив, ВытесняющееЗначение, ВытесняемоеЗначение) Экспорт
	
	ИндексВытесняющегоЗначения = ОбрабатываемыйМассив.Найти(ВытесняющееЗначение);
	
	// Вытесняющего значения нет в обрабатываемом массиве - вытеснение не требуется.
	Если ИндексВытесняющегоЗначения = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	// Удалим все вытесняемые значения в массиве.
	ИндексВытесняемогоЗначения = ОбрабатываемыйМассив.Найти(ВытесняемоеЗначение);
	Пока ИндексВытесняемогоЗначения <> Неопределено Цикл
		ОбрабатываемыйМассив.Удалить(ИндексВытесняемогоЗначения);
		ИндексВытесняемогоЗначения = ОбрабатываемыйМассив.Найти(ВытесняемоеЗначение);
	КонецЦикла;
	
КонецПроцедуры

// Формирует пересечение массивов.
//
// Параметры:
//  Массив1 - Массив.
//  Массив2 - Массив.
// 
// Возвращаемое значение:
//  Массив - Пересечение массив. 
//
Функция ПересечениеМассивов(Массив1, Массив2) Экспорт
	
	ПересечениеМассивов = Новый Массив;
	
	Для Каждого Элемент Из Массив2 Цикл
		
		Индекс = Массив1.Найти(Элемент);
		Если Индекс <> Неопределено Тогда
			ПересечениеМассивов.Добавить(Элемент);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ПересечениеМассивов;
	
КонецФункции

// Возвращает текстовое представление единицы измерения в правильном склонении и числе
//
// Параметры
//  Число - Число - любое целое число.
//	ПараметрыПредметаИсчисления - Строка - варианты написания единицы измерения в родительном
//										   падеже для одной, для двух и для пяти единиц, разделитель
//										   - запятая. Пример: "минуту,минуты,минут".
//
// Возвращаемое значение
//  Строка - текстовое представление единицы измерения.
//
Функция ПредметИсчисленияПрописью(Знач Число, Знач ПараметрыПредметаИсчисления) Экспорт

	Результат = "";
	
	МассивПредставлений = Новый Массив;
	
	Позиция = Найти(ПараметрыПредметаИсчисления, ",");
	Пока Позиция > 0 Цикл
		Значение = СокрЛП(Лев(ПараметрыПредметаИсчисления, Позиция-1));
		ПараметрыПредметаИсчисления = Сред(ПараметрыПредметаИсчисления, Позиция + 1);
		МассивПредставлений.Добавить(Значение);
		Позиция = Найти(ПараметрыПредметаИсчисления, ",");
	КонецЦикла;
	
	Если СтрДлина(ПараметрыПредметаИсчисления) > 0 Тогда
		Значение = СокрЛП(ПараметрыПредметаИсчисления);
		МассивПредставлений.Добавить(Значение);
	КонецЕсли;	
	
	Если Число >= 100 Тогда
		Число = Число - Цел(Число / 100)*100;
	КонецЕсли;
	
	Если Число > 20 Тогда
		Число = Число - Цел(Число/10)*10;
	КонецЕсли;
	
	Если Число = 1 Тогда
		Результат = МассивПредставлений[0];
	ИначеЕсли Число > 1 И Число < 5 Тогда
		Результат = МассивПредставлений[1];
	Иначе
		Результат = МассивПредставлений[2];
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Разделяет переданный массив на нескольков массивов указанного размера.
// Если размер части меньше 1, то будет вызвано исключение.
//
// Параметры:
//  РазделяемыйМассив - Массив - Массив, который следует разделить.
//  РазмерЧасти - Число - Размер части, на которую следует разделить массив.
// 
// Возвращаемое значение:
//  Массив - Разделенные массивы.
//
Функция РазделитьМассив(РазделяемыйМассив, РазмерЧасти) Экспорт
	
	Если РазмерЧасти < 1 Тогда
		ТекстОшибки = СтрШаблон(
			НСтр("ru = 'Некорректный размер части массива для разеления: %1'"),
			Формат(РазмерЧасти, "ЧН=0; ЧГ="));
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	РазделенныеМассивы = Новый Массив;
	
	МассивТекущейЧасти = Новый Массив;
	Для Каждого ЭлементМассив Из РазделяемыйМассив Цикл
		
		МассивТекущейЧасти.Добавить(ЭлементМассив);
		
		Если МассивТекущейЧасти.Количество() >= РазмерЧасти Тогда
			РазделенныеМассивы.Добавить(МассивТекущейЧасти);
			МассивТекущейЧасти = Новый Массив;
		КонецЕсли;
		
	КонецЦикла;
	
	Если МассивТекущейЧасти.Количество() > 0 Тогда
		РазделенныеМассивы.Добавить(МассивТекущейЧасти);
	КонецЕсли;
	
	Возврат РазделенныеМассивы;
	
КонецФункции

// Возвращает случайное число из указанного диапазона
// Параметры:
//  Минимум - Число - начало диапазона
//  Максимум - Число - конец диапазона
//  СчетчикГСЧ - Число - числовая переменная, которая сохраняет свое значение
//   между вызовами функции в случае, если интервал между вызовами небольшой (0-1 мс)
//  ВспомогательныйВызов - Булево - служебный параметр, заполнять не нужно
//  
Функция СлучайноеЧислоБезИспользованияГенератора(
		Минимум, Максимум, СчетчикГСЧ = 0, ВспомогательныйВызов = Ложь) Экспорт
	
	Результат = Минимум;
	
	Если Минимум < Максимум Тогда
		
		Делитель = 1;
		Если Не ВспомогательныйВызов Тогда
			Делители = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("2,3,5,7,11");
			Делитель = Делители[СлучайноеЧислоБезИспользованияГенератора(0, 4, СчетчикГСЧ, Истина)];
		КонецЕсли;
		
		Результат = Цел((ТекущаяУниверсальнаяДатаВМиллисекундах() + СчетчикГСЧ) / Делитель) % Максимум;
		
		Если Результат < Минимум Тогда
			Шаг = (Максимум - Минимум + 1);
			Результат = Результат + Шаг * Цел((Максимум - Результат) / Шаг);
		КонецЕсли;
		
	КонецЕсли;
	
	СчетчикГСЧ = СчетчикГСЧ + 13;
	
	Возврат Результат;
	
КонецФункции

// Сортирует переданный массив.
//
// Параметры:
//  МассивДляСортировки   - Массив                - Массив для сортировки.
//  НаправлениеСортировки - НаправлениеСортировки - Направление сортировки. Значение по умолчанию: Возр.
//
// Возвращаемое значение:
//  Массив - Отсортированный массив.
//
Функция СортироватьМассив(МассивДляСортировки, НаправлениеСортировки = Неопределено) Экспорт
	
	СписокДляСортировки = Новый СписокЗначений;
	СписокДляСортировки.ЗагрузитьЗначения(МассивДляСортировки);
	СписокДляСортировки.СортироватьПоЗначению(НаправлениеСортировки);
	ОтсортированныйМассив = СписокДляСортировки.ВыгрузитьЗначения();
	
	Возврат ОтсортированныйМассив;
	
КонецФункции

// Показывает/скрывает кнопку очистки, если значение отбора заполнено/не заполнено.
//
// Параметры:
//   Поле     - ПолеФормы - элемент формы, в котором будет включена/выключена кнопка очистки.
//   Значение - ЛюбаяСсылка - значение отбора.
//   ЗначениеПоУмолчанию - ЛюбаяСсылка - значение по умолчанию, на которое не нужно накладывать оформление.
//
Процедура ПоказатьСкрытьКнопкуОчисткиОтбора(Поле, Значение, ЗначениеПоУмолчанию = "") Экспорт
	
	Если ТипЗнч(Поле) <> Тип("ПолеФормы") Тогда 
		Возврат;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Значение) Тогда 
		Если Не ЗначениеЗаполнено(ЗначениеПоУмолчанию)
			Или (ЗначениеЗаполнено(ЗначениеПоУмолчанию) И Значение <> ЗначениеПоУмолчанию) Тогда 
			Поле.КнопкаОчистки = Истина;
			#Если Клиент Тогда
				Поле.ЦветФона = ОбщегоНазначенияКлиент.ЦветСтиля("ФонУправляющегоПоля");
			#Иначе
				Поле.ЦветФона = ЦветаСтиля["ФонУправляющегоПоля"];
			#КонецЕсли
		Иначе 
			Поле.КнопкаОчистки = Ложь;
			Поле.ЦветФона = Новый Цвет();
		КонецЕсли;
	Иначе 
		Поле.КнопкаОчистки = Ложь;
		Поле.ЦветФона = Новый Цвет();
	КонецЕсли;
	
КонецПроцедуры

// Выделяет из имени файла его имя (набор символов до последней точки).
//
// Параметры:
//  ИмяФайла - Строка - имя файла с именем каталога или без.
//
// Возвращаемое значение:
//   Строка - имя файла.
//
Функция ПолучитьТолькоИмяИмениФайла(Знач ИмяФайла) Экспорт
	
	ТолькоИмя = "";
	
	ПозицияСимвола = СтрДлина(ИмяФайла);
	Пока ПозицияСимвола >= 1 Цикл
		
		Если Сред(ИмяФайла, ПозицияСимвола, 1) = "." Тогда
			
			ТолькоИмя = Лев(ИмяФайла, ПозицияСимвола - 1);
			Прервать;
		КонецЕсли;
		
		ПозицияСимвола = ПозицияСимвола - 1;
	КонецЦикла;

	Возврат ТолькоИмя;
	
КонецФункции

// Присвоить, если значение отличается, чтобы не возникала модифицированность, если не нужно.
// 
// Параметры:
//  ЧтоПрисвоить - Произвольный - Что присвоить.
//  ЧемуРавно - Произвольный - Чему присвоить.
//
// Возвращаемое значение:
//  Булево - Истина, если удалось присвоить, Ложь, если на вход пришло пустое значение.
Функция ПрисвоитьОтличающееся(ЧтоПрисвоить, ЧемуРавно) Экспорт
	
	Если ЧтоПрисвоить <> ЧемуРавно Тогда
		ЧтоПрисвоить = ЧемуРавно;
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Возвращает тип объекта. Если тип объекта неизвестен, то вызывает исключение.
// 
// Параметры:
//  ТипЗначения - Тип, ЛюбаяСсылка.
// 
// Возвращаемое значение:
//  ПеречислениеСсылка.ТипыОбъектов - Тип объекта.
//  
Функция ТипОбъекта(ТипИлиСсылка) Экспорт
	
	Если ТипЗнч(ТипИлиСсылка) = Тип("Тип") Тогда
		Тип = ТипИлиСсылка
	Иначе
		Тип = ТипЗнч(ТипИлиСсылка);
	КонецЕсли;
	
	Если Тип = Тип("СправочникСсылка.ДокументыПредприятия") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.ДокументыПредприятия");
		
	ИначеЕсли Тип = Тип("СправочникСсылка.Контрагенты") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.Контрагенты");
		
	ИначеЕсли Тип = Тип("СправочникСсылка.Мероприятия") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.Мероприятия");
		
	ИначеЕсли Тип = Тип("СправочникСсылка.Пользователи") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.Пользователи");
		
	ИначеЕсли Тип = Тип("СправочникСсылка.ПроектныеЗадачи") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.ПроектныеЗадачи");
		
	ИначеЕсли Тип = Тип("СправочникСсылка.Проекты") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.Проекты");
		
	ИначеЕсли Тип = Тип("СправочникСсылка.Файлы") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.Файлы");
		
	Иначе
		
		ВызватьИсключение СтрШаблон(
			НСтр("ru = 'Неизвестен тип объекта для типа %1.'"),
			Тип);
		
	КонецЕсли;
	
	Возврат ТипОбъекта;
	
КонецФункции

// Возвращает тип объекта по виду объекта. Если тип объекта неизвестен, то вызывает исключение.
// 
// Параметры:
//  ТипИлиСсылкаВидаОбъекта - Тип, ЛюбаяСсылка.
// 
// Возвращаемое значение:
//  ПеречислениеСсылка.ТипыОбъектов - Тип объекта.
//  
Функция ТипОбъектаПоТипуВидаОбъекта(ТипИлиСсылкаВидаОбъекта) Экспорт
	
	Если ТипЗнч(ТипИлиСсылкаВидаОбъекта) = Тип("Тип") Тогда
		ТипВидаОбъекта = ТипИлиСсылкаВидаОбъекта
	Иначе
		ТипВидаОбъекта = ТипЗнч(ТипИлиСсылкаВидаОбъекта);
	КонецЕсли;
	
	Если ТипВидаОбъекта = Тип("СправочникСсылка.ВидыДокументов") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.ДокументыПредприятия");
		
	ИначеЕсли ТипВидаОбъекта = Тип("СправочникСсылка.ВидыМероприятий") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.Мероприятия");
		
	ИначеЕсли ТипВидаОбъекта = Тип("СправочникСсылка.ВидыПроектов") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.Проекты");
		
	Иначе
		
		ВызватьИсключение СтрШаблон(
			НСтр("ru = 'Неизвестен тип объекта для типа вида объекта %1.'"),
			ТипВидаОбъекта);
		
	КонецЕсли;
	
	Возврат ТипОбъекта;
	
КонецФункции

// Устанавливает или отключает быстрый отбор списка,
// выполняет все необходимые действия с элементом формы, отображающим значение быстрого отбора.
// 
// Параметры:
//   Список - ДинамическийСписок - Список, в котором требуется изменить отбор.
//   ИмяПоляСписка - Строка - Поле, по которому необходимо изменить отбор.
//   ЗначениеОтбора - Произвольный - Значение отбора.
//   ПолеОтбора - ЭлементФормы - элемент формы, который отображает значение отбора.
// 
Процедура ИзменитьБыстрыйОтборСписка(Список, ИмяПоляСписка, ЗначениеОтбора, ПолеОтбора) Экспорт
	
	Если ЗначениеЗаполнено(ЗначениеОтбора) Тогда
		ОбщегоНазначенияКлиентСервер.УдалитьЭлементыГруппыОтбораДинамическогоСписка(Список, ИмяПоляСписка);
		ОбщегоНазначенияКлиентСервер.УстановитьЭлементОтбораДинамическогоСписка(
			Список, ИмяПоляСписка, ЗначениеОтбора,,, Истина,
			РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Обычный);
	Иначе
		ОбщегоНазначенияКлиентСервер.УдалитьЭлементыГруппыОтбораДинамическогоСписка(Список, ИмяПоляСписка);
	КонецЕсли;
	
	ПоказатьСкрытьКнопкуОчисткиОтбора(ПолеОтбора, ЗначениеОтбора);
	
КонецПроцедуры

// Устанавливает отбор списка.
//
// Параметры:
//  Список - ДинамическийСписок - Список, для которого нужно установить отбор.
//  ИмяПараметра - Строка - Имя параметра списка.
//  ЗначениеОтбора - Произвольный - Значение отбора.
//  ПолеОтбора - ПолеФормы - Элемент формы, соответствующий отбору.
//
Процедура УстановитьОтборСписка(Список, ИмяПараметра, ЗначениеОтбора, ПолеОтбора) Экспорт
	
	Параметр = Список.Параметры.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных(ИмяПараметра));
	Параметр.Использование = Ложь;
	Если ЗначениеЗаполнено(ЗначениеОтбора) Тогда
		Список.Параметры.УстановитьЗначениеПараметра(ИмяПараметра, ЗначениеОтбора);
	КонецЕсли;
	
	ПоказатьСкрытьКнопкуОчисткиОтбора(ПолеОтбора, ЗначениеОтбора);
	
КонецПроцедуры

// Устанавливает отбор показа удаленных.
//
// Параметры:
//  Список - ДинамическийСписок - Список, для которого нужно установить отбор.
//  ПоказыватьУдаленные - Булево - Параметр показывать удаленные.
//  Кнопка - КнопкаФормы - Кнопка "Показывать удаленные".
//
Процедура УстановитьОтборПоказыватьУдаленные(Список, ПоказыватьУдаленные, Кнопка) Экспорт
	
	#Если Не ВнешнееСоединение Тогда
	
	ИмяПоляСписка = "ПометкаУдаления";
	Если ПоказыватьУдаленные Тогда
		ОбщегоНазначенияКлиентСервер.УдалитьЭлементыГруппыОтбораДинамическогоСписка(Список, ИмяПоляСписка);
	Иначе
		ОбщегоНазначенияКлиентСервер.УстановитьЭлементОтбораДинамическогоСписка(
			Список,
			ИмяПоляСписка,
			Ложь,,,
			Истина,
			РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Обычный);
	КонецЕсли;
	
	Кнопка.Пометка = ПоказыватьУдаленные;
	
	#КонецЕсли
	
КонецПроцедуры

// Устанавливает отбор показа недействительных.
//
// Параметры:
//  Список - ДинамическийСписок.
//  ПоказыватьНедействительные.
//  Команда - КомандаФормы - Команда "Показывать удаленные".
//
Процедура УстановитьОтборПоказыватьНедействительные(Список, ПоказыватьНедействительные, Команда) Экспорт
	
	ИмяПоляСписка = "Недействителен";
	Если ПоказыватьНедействительные Тогда
		ОбщегоНазначенияКлиентСервер.УдалитьЭлементыГруппыОтбораДинамическогоСписка(Список, ИмяПоляСписка);
	Иначе
		ОбщегоНазначенияКлиентСервер.УстановитьЭлементОтбораДинамическогоСписка(
			Список,
			ИмяПоляСписка,
			Ложь,,,
			Истина,
			РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Обычный);
	КонецЕсли;
	
	Команда.Пометка = ПоказыватьНедействительные;
	
КонецПроцедуры

// Определяет, есть ли какие-то отличия в таблицах, выполняя поэлементное сравнение.
// 
// Параметры:
//  Таблица1 - Коллекция.
//  Таблица2 - Коллекция.
//  ПоляДляСравнения - Строка - список полей, разделенных запятыми.
// 
// Возвращаемое значение:
//  Булево - признак того, что коллекции отличаются.
//
Функция ЕстьОтличияВТаблицах(Таблица1, Таблица2, ПоляДляСравнения) Экспорт
	
	КоличествоЗаписей = Таблица1.Количество();
	ЕстьОтличия = КоличествоЗаписей <> Таблица2.Количество();
	
	Если Не ЕстьОтличия Тогда
		
		ПоляДляСравнения = СтрРазделить(ПоляДляСравнения, ",");
		Для Сч = 0 По КоличествоЗаписей - 1 Цикл
			Для Каждого Эл Из ПоляДляСравнения Цикл
				ИмяПоля = СокрЛП(Эл);
				Если Таблица1[Сч][ИмяПоля] <> Таблица2[Сч][ИмяПоля] Тогда
					Возврат Истина;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ЕстьОтличия;
 	
КонецФункции

// Определяет, есть ли какие-то отличия в массива, выполняя поэлементное сравнение.
// 
// Параметры:
//  Массив1 - Коллекция.
//  Массив2 - Коллекция.
// 
// Возвращаемое значение:
//  Булево - признак того, что коллекции отличаются.
//
Функция ЕстьОтличияВМассивах(Массив1, Массив2) Экспорт
	
	КоличествоЗаписей = Массив1.Количество();
	ЕстьОтличия = КоличествоЗаписей <> Массив2.Количество();
	
	Если Не ЕстьОтличия Тогда
		
		Для Сч = 0 По КоличествоЗаписей - 1 Цикл
			Если Массив1[Сч] <> Массив2[Сч] Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ЕстьОтличия;
 	
КонецФункции

// Выгружает значения соответствия.
//
// Параметры:
//  Соответствие - Соответствие - Соответствие.
// 
// Возвращаемое значение:
//  Массив - Значения соответствия.
//
Функция ЗначенияСоответствия(Соответствие) Экспорт
	
	ЗначенияСоответствия = Новый Массив;
	Для Каждого КлючИЗначение Из Соответствие Цикл
		ЗначенияСоответствия.Добавить(КлючИЗначение.Значение);
	КонецЦикла;
	
	Возврат ЗначенияСоответствия;
	
КонецФункции

// Распределяет массив в соответствие по типам.
//
// Параметры:
//  ОбарабатываемыйМассив - Массив - Обарабатываемый массив
// 
// Возвращаемое значение:
//  Соответствие - Массив, распределенный по типам.
//   Ключ - Тип - Тип значения массив.
//   Значение - Массив - Значения массива указанного типа.
//
Функция СоответствиеПоТипам(ОбарабатываемыйМассив) Экспорт
	
	СоответствиеПоТипам = Новый Соответствие;
	Для Каждого ЭлементМассива Из ОбарабатываемыйМассив Цикл
		
		ТипЭлементаМассива = ТипЗнч(ЭлементМассива);
		
		МассивТипа = СоответствиеПоТипам[ТипЭлементаМассива];
		Если МассивТипа = Неопределено Тогда
			СоответствиеПоТипам.Вставить(ТипЭлементаМассива, Новый Массив);
			МассивТипа = СоответствиеПоТипам[ТипЭлементаМассива];
		КонецЕсли;
		МассивТипа.Добавить(ЭлементМассива);
		
	КонецЦикла;
	
	Возврат СоответствиеПоТипам;
	
КонецФункции

// Возвращает текст о необходимости записи данных.
//
// Параметры:
//  НазваниеКоманды - Строка - название выполняемой команды.
// 
// Возвращаемое значение:
//  Строка - Текст о необходимости записи данных.
//
Функция ТекстВопросаНезаписанныхДанных(НазваниеКоманды) Экспорт 
	
	Возврат СтрШаблон(
		НСтр("ru = 'Данные еще не записаны.
              |Выполнение действия ""%1"" возможно только после записи данных.
              |Данные будут записаны.'"),
		НазваниеКоманды);
	
КонецФункции

// Возвращает копию простого массива, не обходя его элементы рекурсивно, в отличие от ОбщегоНазначенияКлиентСервер.
// СкопироватьМассив().
//
// Параметры:
//   Массив - Массив - копируемый массив.
//
// Возвращаемое значение:
//   Массив - копия исходного массива.
//
Функция КопияПростогоМассива(Массив) Экспорт
	
	Копия = Новый Массив;
	Для Каждого Элемент Из Массив Цикл
		Копия.Добавить(Элемент);
	КонецЦикла;
	
	Возврат Копия;
	
КонецФункции

#Область РаботаСДеревом

// Выполняет поиск строк дерева в соответствии с переданным отбором.
//
// Параметры:
//  Ветка - ДанныеФормыДерево, ДанныеФормыЭлементДерева - дерево или его элемент, 
//          в рамках которых выполняется поиск.
//  СтруктураОтбора - Структура - структура, по значениям которой будет выполняться поиск.
//
// Возвращаемое значение:
//   Массив - массив найденных строк.
//
Функция НайтиСтрокиДерева(Ветка, СтруктураОтбора) Экспорт
	
	Возврат НайтиСтрокиВеткиДереваПоОтбору(Ветка, СтруктураОтбора, Ложь);
	
КонецФункции

// Выполняет поиск первой строки дерева в соответствии с переданным отбором.
//
// Параметры:
//  Ветка - ДанныеФормыДерево, ДанныеФормыЭлементДерева - дерево или его элемент, 
//          в рамках которых выполняется поиск.
//  СтруктураОтбора - Структура - структура, по значениям которой будет выполняться поиск.
//
// Возвращаемое значение:
//   ДанныеФормыЭлементДерева - найденная строка.
//
Функция НайтиСтрокуДерева(Ветка, СтруктураОтбора) Экспорт
	
	Результат = Неопределено;
	
	НайденныеСтроки = НайтиСтрокиВеткиДереваПоОтбору(Ветка, СтруктураОтбора, Истина);
	Если НайденныеСтроки.Количество() > 0 Тогда
		Результат = НайденныеСтроки[0];
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает массив всех строк дерева или его ветки.
//
// Параметры:
//  Ветка - ДанныеФормыДерево, ДанныеФормыЭлементДерева - дерево или его элемент,
//    строки которого нужно получить.
//
// Возвращаемое значение:
//   Массив - массив строк дерева.
//
Функция ВсеСтрокиДерева(Ветка) Экспорт
	
	Результат = Новый Массив;
	
	СтрокиКОбработке = Новый Массив;
	Для Каждого Строка Из Ветка.ПолучитьЭлементы() Цикл
		СтрокиКОбработке.Добавить(Строка);
	КонецЦикла;
	
	ПрерватьОбработку = Ложь;
	Пока СтрокиКОбработке.Количество() > 0 И Не ПрерватьОбработку Цикл
		
		ТекущаяСтрока = СтрокиКОбработке[0];
		СтрокиКОбработке.Удалить(0);
		
		Результат.Добавить(ТекущаяСтрока);
		
		Для Каждого Строка Из ТекущаяСтрока.ПолучитьЭлементы() Цикл
			СтрокиКОбработке.Добавить(Строка);
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Заполняет колонки всех строк дерева или его ветки переданными значениями.
//
// Параметры:
//  Ветка - ДанныеФормыДерево, ДанныеФормыЭлементДерева - дерево или его элемент.
//  ЗначенияДляЗаполнения - Структура - значения, которыми нужно заполнить колонки дерева.
//
Процедура ЗаполнитьКолонкиДерева(Ветка, ЗначенияДляЗаполнения) Экспорт
	
	СтрокиКОбработке = Новый Массив;
	Для Каждого Строка Из Ветка.ПолучитьЭлементы() Цикл
		СтрокиКОбработке.Добавить(Строка);
	КонецЦикла;
	
	ПрерватьОбработку = Ложь;
	Пока СтрокиКОбработке.Количество() > 0 И Не ПрерватьОбработку Цикл
		
		ТекущаяСтрока = СтрокиКОбработке[0];
		СтрокиКОбработке.Удалить(0);
		
		ЗаполнитьЗначенияСвойств(ТекущаяСтрока, ЗначенияДляЗаполнения);
		
		Для Каждого Строка Из ТекущаяСтрока.ПолучитьЭлементы() Цикл
			СтрокиКОбработке.Добавить(Строка);
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

// Возвращает копию массива, не обходя его элементы рекурсивно, в отличие от
// ОбщегоНазначенияКлиентСервер.СкопироватьМассив().
// Поэтому функцию следует использовать для копирования массивов без слоных вложенных конструкций
// (вложенные массивы, таблицы значений, соотвествия, струкутры, списки значений и т.д.).
//
// Параметры:
//   Массив - Массив - копируемый массив.
//
// Возвращаемое значение:
//   Массив - копия исходного массива.
//
Функция ПростаяКопияМассива(Массив) Экспорт
	
	Копия = Новый Массив;
	Для Каждого Элемент Из Массив Цикл
		Копия.Добавить(Элемент);
	КонецЦикла;
	
	Возврат Копия;
	
КонецФункции

// Возвращает пустой уникальный идентификатор - тот, который соответствует пустой ссылке.
// 
Функция ПустойУникальныйИдентификатор() Экспорт
	
	Возврат Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000");
	
КонецФункции

// Маскирует спецсимволы в тексте для его использования в оператора запроса ПОДОБНО,
// чтобы текст использовался как есть.
// Символы "%", "~", "_", "[", "]", "^", "/" в исходной строке предваряются символом маскировки.
//
// Параметры:
//  Текст - Строка
//  СимволМаскировки - Строка - строка с одним символом.
//
// Возвращаемое значение:
//  Строка - измененная строка
//
Функция ЗамаскироватьСпецсимволыДляОператораЗапросаПОДОБНО(Текст, СимволМаскировки = "/") Экспорт
	
	Строки = СтрРазделить(Текст, "%~_[]^/", Истина);
	
	Если Строки.Количество() > 1 Тогда
		Дл = СтрДлина(Строки[0]) + 1;
		Для Ин = 1 По Строки.ВГраница() Цикл
			Строки[Ин] = Сред(Текст, Дл, 1) + Строки[Ин];
			Дл = Дл + СтрДлина(Строки[Ин]);
		КонецЦикла;
		Возврат СтрСоединить(Строки, СимволМаскировки);
		
	Иначе
		Возврат Текст;
		
	КонецЕсли;
	
КонецФункции

// Копирует строку в другое дерево или в другую ветку дерева вместе с подстроками.
//
// Параметры:
//  СтрокаДерева - СтрокаДереваЗначений - строка, которую нужно скопировать.
//  ВеткаПриемник - ДанныеФормыДерево, ДанныеФормыЭлементДерева, ДеревоЗначений - дерево или его элемент,
//		куда будет добавлена скопированная строка.
//
Процедура СкопироватьСтрокуДерева(СтрокаДерева, ВеткаПриемник) Экспорт
	
	ПарыСтрокКОбработке = Новый Массив;
	
	ЭтоДеревоФормы = ТипЗнч(ВеткаПриемник) = Тип("ДанныеФормыДерево") 
		Или ТипЗнч(ВеткаПриемник) = Тип("ДанныеФормыЭлементДерева");
		
	СтрокиДерева = Неопределено;
	Если ЭтоДеревоФормы Тогда
		СтрокиДерева = ВеткаПриемник.ПолучитьЭлементы();
	Иначе
		СтрокиДерева = ВеткаПриемник.Строки;
	КонецЕсли;
	
	ПарыСтрокКОбработке.Добавить(Новый Структура("Источник, Приемник",
		СтрокаДерева, СтрокиДерева.Добавить()));
	
	Пока ПарыСтрокКОбработке.Количество() > 0 Цикл
		
		Источник = ПарыСтрокКОбработке[0].Источник;
		Приемник = ПарыСтрокКОбработке[0].Приемник;
		ПарыСтрокКОбработке.Удалить(0);
		
		ЗаполнитьЗначенияСвойств(Приемник, Источник);
		
		Для Каждого ПодчиненнаяСтрока Из Источник.Строки Цикл
			
			ПарыСтрокКОбработке.Добавить(Новый Структура("Источник, Приемник",
				ПодчиненнаяСтрока, СтрокиДерева.Добавить()));
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает представление по строковому наименованию переменной, объекта, параметра и т.д.
// 
// Например, для строки "ОбщегоНазначенияДокументооборотКлиентСервер" будет возвращено представление
// "Общего назначения документооборот клиент сервер".
// 
// Параметры:
//  Наименование - Строка
// 
// Возвращаемое значение:
//  Строка
//  
Функция ПредставлениеПоНаименованию(Наименование) Экспорт
	
	Наименование_ВР = ВРег(Наименование);
	
	Если Наименование = Наименование_ВР Тогда
		Возврат Наименование;
	КонецЕсли; 
	
	Результат = Новый Массив;
	
	Для НомерСимвола = 1 По СтрДлина(Наименование) Цикл
					
		Если НомерСимвола = 1 Тогда
			
			Результат.Добавить(Сред(Наименование, НомерСимвола, 1));
		
		ИначеЕсли КодСимвола(Наименование, НомерСимвола) = 
			КодСимвола(Наименование_ВР, НомерСимвола) Тогда
			 
			Результат.Добавить(" ");
			Результат.Добавить(НРег(Сред(Наименование_ВР, НомерСимвола, 1)));
			
		Иначе
			
			Результат.Добавить(Сред(Наименование, НомерСимвола, 1));
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат СтрСоединить(Результат, "");
	
КонецФункции

// Удаляет пустые значения из массива.
// 
// Параметры:
//  Массив - Массив.
//
Процедура УдалитьПустыеЗначения(Массив) Экспорт
	
	КоличествоЭлементов = Массив.Количество();
	Для Индекс = 1 По КоличествоЭлементов Цикл
		
		ОбратныйИндекс = КоличествоЭлементов - Индекс;
		ЭлементМассива = Массив[ОбратныйИндекс];
		Если ЗначениеЗаполнено(ЭлементМассива) Тогда
			Продолжить;
		КонецЕсли;
		
		Массив.Удалить(ОбратныйИндекс);
		
	КонецЦикла;
	
КонецПроцедуры

// Удаляет строки переданной таблицы формы, в которых проверяемый реквизит не заполнен.
//
// Параметры:
//  Таблица	- ТаблицаЗначений, ТабличнаяЧасть - в которой осуществляется удаление не заполненых строк.
//  ИмяРеквизитаПроверки - Строка - имя реквизита, заполненность которого проверяется.
//
Процедура УдалитьПустыеСтрокиТаблицы(Таблица, ИмяРеквизитаПроверки) Экспорт
	
	КоличествоСтрок = Таблица.Количество();
	Для Инд = 1 По КоличествоСтрок Цикл
		Строка = Таблица[КоличествоСтрок - Инд];
		
		Если Не ЗначениеЗаполнено(Строка[ИмяРеквизитаПроверки]) Тогда 
			Таблица.Удалить(Строка);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Определяет, доступно ли интерактивное изменение файлов.
// 
// Параметры:
//  ПриложениеЗадачи - ОпределяемыйТип.ПриложениеЗадач.
// 
// Возвращаемое значение:
//  Булево - Доступно интерактивное изменение файлов.
//  
Функция ДоступноИнтерактивноеИзменениеФайлов(ПриложениеЗадачи) Экспорт
	
	ТипПриложенияЗадачи = ТипЗнч(ПриложениеЗадачи);
	
	ДоступноИнтерактивноеИзменениеФайлов =
		ТипПриложенияЗадачи = Тип("СправочникСсылка.Контрагенты")
		Или ТипПриложенияЗадачи = Тип("ДокументСсылка.ИсходящееПисьмо")
		Или ТипПриложенияЗадачи = Тип("СправочникСсылка.ДокументыПредприятия")
		Или ТипПриложенияЗадачи = Тип("СправочникСсылка.СообщенияОбсуждений")
		Или ТипПриложенияЗадачи = Тип("СправочникСсылка.Мероприятия");
	
	Возврат ДоступноИнтерактивноеИзменениеФайлов;
	
КонецФункции

// Определяет вид контрагента для подсистемы СПАРКРиски по виду контрагента
// 
// Параметры:
//  ВидКонтрагента - ПеречислениеСсылка.ЮрФизЛицо - вид контрагента ДО 
// 
// Возвращаемое значение:
//  ПеречислениеСсылка.ВидыКонтрагентовСПАРКРиски, Неопределено - соответствующий вид контрагента СПАРК
Функция ВидКонтрагентаСпаркПоВидуКонтрагента(ВидКонтрагента) Экспорт
	
	ВидКонтрагентаСПАРК = Неопределено;
	Если ВидКонтрагента = ПредопределенноеЗначение("Перечисление.ЮрФизЛицо.ИндивидуальныйПредприниматель") Тогда
		ВидКонтрагентаСПАРК = 
			ПредопределенноеЗначение("Перечисление.ВидыКонтрагентовСПАРКРиски.ИндивидуальныйПредприниматель");
	ИначеЕсли ВидКонтрагента = ПредопределенноеЗначение("Перечисление.ЮрФизЛицо.ЮрЛицо") Тогда
		ВидКонтрагентаСПАРК = 
			ПредопределенноеЗначение("Перечисление.ВидыКонтрагентовСПАРКРиски.ЮридическоеЛицо");
	КонецЕсли;
	
	Возврат ВидКонтрагентаСпарк;
	
КонецФункции

// Определяет вид контрагента для подсистемы СПАРКРиски
// 
// Параметры:
//  Контрагент - СправочникСсылка.Контрагенты
// 
// Возвращаемое значение:
//  ПеречислениеСсылка.ВидыКонтрагентовСПАРКРиски, Неопределено - соответствующий вид контрагента СПАРК
Функция ВидКонтрагентаСПАРК(Контрагент) Экспорт
	
	ВидКонтрагентаСПАРК = Неопределено;
	
	Если Не ЗначениеЗаполнено(Контрагент)
		Или ТипЗнч(Контрагент) <> Тип("СправочникСсылка.Контрагенты") Тогда
		Возврат ВидКонтрагентаСПАРК;
	КонецЕсли;
	
	ЮрФизЛицо = ОбщегоНазначенияДокументооборотВызовСервера.ЮрФизЛицоКонтрагентаВПривилегированномРежиме(Контрагент);
	Возврат ВидКонтрагентаСпаркПоВидуКонтрагента(ЮрФизЛицо);
	
КонецФункции

// Отбор элементов массива по типу.
// 
// Параметры:
//  Массив - Массив - Массив, из которого нужно отобрать элементы переданного типа
//  ТипДляОтбора - Тип - Тип, по которому нужно отобрать элементы из переданного массива
// 
// Возвращаемое значение:
//  Массив - Отбор элементов массива по типу
Функция ЭлементыМассиваЗаданногоТипа(Массив, ТипДляОтбора) Экспорт
	
	Результат = Новый Массив;
	
	Для Каждого Элемент Из Массив Цикл
		Если ТипЗнч(Элемент) = ТипДляОтбора Тогда
			Результат.Добавить(Элемент);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ПредставлениеЗначения(ОбрабатываемоеЗначение, Разделитель1 = "", Разделитель2 = "", Знач Уровень = 0) Экспорт

	Результат = "";

	ТипЧисло                     = Тип("Число");
	ТипСтрока                    = Тип("Строка");
	ТипДата                      = Тип("Дата");
	ТипБулево                    = Тип("Булево");
	ТипСписокЗначений            = Тип("СписокЗначений");
	ТипМассив                    = Тип("Массив");
	ТипФиксированныйМассив       = Тип("ФиксированныйМассив");
	ТипСтруктура                 = Тип("Структура");
	ТипФиксированнаяСтруктура    = Тип("ФиксированнаяСтруктура");
	ТипСоответствие              = Тип("Соответствие");
	ТипФиксированноеСоответствие = Тип("ФиксированноеСоответствие");

	Если ТипЗнч(Уровень) <> ТипЧисло
			ИЛИ Уровень < 0 Тогда
		Уровень = 0;
	КонецЕсли;

	Если ТипЗнч(ОбрабатываемоеЗначение) = ТипСтрока Тогда
		Результат = СтроковыеФункцииКлиентСервер.СформироватьСтрокуСимволов("  ", Уровень) + ОбрабатываемоеЗначение;
	ИначеЕсли ТипЗнч(ОбрабатываемоеЗначение) = ТипДата Тогда
		Результат = СтроковыеФункцииКлиентСервер.СформироватьСтрокуСимволов("  ", Уровень) + Формат(ОбрабатываемоеЗначение, "ДЛФ=DT");
	ИначеЕсли ТипЗнч(ОбрабатываемоеЗначение) = ТипЧисло Тогда
		Результат = СтроковыеФункцииКлиентСервер.СформироватьСтрокуСимволов("  ", Уровень) + Формат(ОбрабатываемоеЗначение, "ЧЦ=15; ЧДЦ=4; ЧРД=,; ЧРГ=' '; ЧН=0,0000; ЧГ=3,0");
	ИначеЕсли ТипЗнч(ОбрабатываемоеЗначение) = ТипБулево Тогда
		Результат = СтроковыеФункцииКлиентСервер.СформироватьСтрокуСимволов("  ", Уровень) + Формат(ОбрабатываемоеЗначение, "БЛ=Ложь; БИ=Истина");
	ИначеЕсли ТипЗнч(ОбрабатываемоеЗначение) = ТипСписокЗначений Тогда
		Счетчик = 1;
		Для Каждого ТекущееЗначение Из ОбрабатываемоеЗначение Цикл
			Если Счетчик = ОбрабатываемоеЗначение.Количество() Тогда
				Результат = Результат
					+ СтроковыеФункцииКлиентСервер.СформироватьСтрокуСимволов("  ", Уровень)
					+ ПредставлениеЗначения(ТекущееЗначение.Значение, Разделитель1, Разделитель2, Уровень);
			Иначе
				Результат = Результат
					+ СтроковыеФункцииКлиентСервер.СформироватьСтрокуСимволов("  ", Уровень)
					+ ПредставлениеЗначения(ТекущееЗначение.Значение, Разделитель1, Разделитель2, Уровень) + Разделитель1;
			КонецЕсли;
			Счетчик = Счетчик + 1;
		КонецЦикла;
	ИначеЕсли (ТипЗнч(ОбрабатываемоеЗначение) = ТипМассив) ИЛИ (ТипЗнч(ОбрабатываемоеЗначение) = ТипФиксированныйМассив) Тогда
		Счетчик = 1;
		Для Каждого ТекущееЗначение Из ОбрабатываемоеЗначение Цикл
			Если Счетчик = ОбрабатываемоеЗначение.Количество() Тогда
				Результат = Результат
					+ СтроковыеФункцииКлиентСервер.СформироватьСтрокуСимволов("  ", Уровень)
					+ ПредставлениеЗначения(ТекущееЗначение, Разделитель1, Разделитель2, Уровень);
			Иначе
				Результат = Результат
					+ СтроковыеФункцииКлиентСервер.СформироватьСтрокуСимволов("  ", Уровень)
					+ ПредставлениеЗначения(ТекущееЗначение, Разделитель1, Разделитель2, Уровень) + Разделитель1;
			КонецЕсли;
			Счетчик = Счетчик + 1;
		КонецЦикла;
	ИначеЕсли (ТипЗнч(ОбрабатываемоеЗначение) = ТипСтруктура)
			ИЛИ (ТипЗнч(ОбрабатываемоеЗначение) = ТипФиксированнаяСтруктура) Тогда
		Для Каждого КлючЗначение Из ОбрабатываемоеЗначение Цикл
			Если (ТипЗнч(КлючЗначение.Значение) = ТипСтруктура)
					ИЛИ (ТипЗнч(КлючЗначение.Значение) = ТипФиксированнаяСтруктура) Тогда
				// Перед структурой вставить еще один разделитель.
				Результат =
					Результат
					+ СтроковыеФункцииКлиентСервер.СформироватьСтрокуСимволов("  ", Уровень)
					+ КлючЗначение.Ключ
					+ Разделитель1
					+ Символы.ПС
					+ ПредставлениеЗначения(КлючЗначение.Значение, Разделитель1, Разделитель2, Уровень + 1) // С отступом
					+ Разделитель2;
			Иначе
				Результат =
					Результат
					+ СтроковыеФункцииКлиентСервер.СформироватьСтрокуСимволов("  ", Уровень)
					+ КлючЗначение.Ключ
					+ Разделитель1
					+ ПредставлениеЗначения(КлючЗначение.Значение, Разделитель1, Разделитель2, 0) // Без отступа
					+ Разделитель2;
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли (ТипЗнч(ОбрабатываемоеЗначение) = ТипСоответствие) ИЛИ (ТипЗнч(ОбрабатываемоеЗначение) = ТипФиксированноеСоответствие) Тогда
		Для Каждого КлючЗначение Из ОбрабатываемоеЗначение Цикл
			Если (ТипЗнч(КлючЗначение.Значение) = ТипСтруктура)
					ИЛИ (ТипЗнч(КлючЗначение.Значение) = ТипФиксированнаяСтруктура) Тогда
				// Перед структурой вставить еще один разделитель.
				Результат =
					Результат
					+ СтроковыеФункцииКлиентСервер.СформироватьСтрокуСимволов("  ", Уровень)
					+ ПредставлениеЗначения(КлючЗначение.Ключ, Разделитель1, Разделитель2, Уровень + 1)
					+ Разделитель1
					+ Символы.ПС
					+ ПредставлениеЗначения(КлючЗначение.Значение, Разделитель1, Разделитель2, Уровень + 1) // С отступом
					+ Разделитель2;
			Иначе
				Результат =
					Результат
					+ СтроковыеФункцииКлиентСервер.СформироватьСтрокуСимволов("  ", Уровень)
					+ ПредставлениеЗначения(КлючЗначение.Ключ, Разделитель1, Разделитель2, Уровень + 1)
					+ Разделитель1
					+ ПредставлениеЗначения(КлючЗначение.Значение, Разделитель1, Разделитель2, 0) // Без отступа
					+ Разделитель2;
			КонецЕсли;
		КонецЦикла;
	Иначе
		// Значения других типов, например таблицы значений или элементы справочников - НЕ выводятся.
	КонецЕсли;

	Возврат Результат;

КонецФункции

// Безопасно преобразует строку в число, если не смог (строка скажем  "ффф") - вернет 0.
// 
// Параметры:
//  СтрокаЧислом - Строка - например "500"
// 
// Возвращаемое значение:
//  Число
// 
Функция СтрокаВЧисло(СтрокаЧислом) Экспорт
	
	КодВозврата = СтроковыеФункцииКлиентСервер.СтрокаВЧисло(СтрокаЧислом);
	Если КодВозврата = Неопределено Тогда
		Возврат 0;
	КонецЕсли;	
	
	Возврат КодВозврата;
	
КонецФункции	

// Возвращает дату без секунд.
// 
// Параметры:
//  Дата - Дата
// 
// Возвращаемое значение:
//  Дата
// 
Функция ДатаБезСекунд(Дата) Экспорт
	
	ДатаБезСекунд = Дата - Секунда(Дата);
	
	Возврат ДатаБезСекунд;
	
КонецФункции

// Удаляет дубли строк переданной таблицы формы, в которых проверяемые реквизиты совпадают.
//
// Параметры:
//  ТаблицаФормы            - ТаблицаФормы - Таблица формы, в которой осуществляется удаление не дублей строк.
//  ИменаРеквизитовПроверки - Строка       - Имена реквизитов, по которым определяются дубли, разделенные запятой.
//
Процедура УдалитьДублиСтрокТаблицы(ТаблицаФормы, ИменаРеквизитовПроверки = "") Экспорт
	
	ДублиСтрок = Новый Массив;
	УникальныеСтроки = Новый Соответствие;
	
	МассивИменаРеквизитовПроверки = СтрРазделить(ИменаРеквизитовПроверки, ",");
	ВсегоРеквизитовПроверки = МассивИменаРеквизитовПроверки.Количество();
	
	Для Каждого Строка Из ТаблицаФормы Цикл
		
		НомерРеквизитаПроверки = 1;
		
		ТекущиеУникальныеСтроки = УникальныеСтроки;
		Для Каждого ИмяРеквизитаПроверки Из МассивИменаРеквизитовПроверки Цикл
			
			ЗначениеРеквизитаПроверки = Строка[СокрЛП(ИмяРеквизитаПроверки)];
			
			ЭтоПоследнийРевизитПроверки = (НомерРеквизитаПроверки = ВсегоРеквизитовПроверки);
			
			Если Не ЭтоПоследнийРевизитПроверки Тогда
				
				Если ТекущиеУникальныеСтроки[ЗначениеРеквизитаПроверки] = Неопределено Тогда
					ТекущиеУникальныеСтроки[ЗначениеРеквизитаПроверки] = Новый Соответствие;
				КонецЕсли;
				ТекущиеУникальныеСтроки = ТекущиеУникальныеСтроки[ЗначениеРеквизитаПроверки];
				
				НомерРеквизитаПроверки = НомерРеквизитаПроверки + 1;
				
			Иначе
				
				Если ТекущиеУникальныеСтроки[ЗначениеРеквизитаПроверки] = Неопределено Тогда
					ТекущиеУникальныеСтроки[ЗначениеРеквизитаПроверки] = Истина;
				Иначе
					ДублиСтрок.Добавить(Строка);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Для Каждого Строка Из ДублиСтрок Цикл
		
		ТаблицаФормы.Удалить(Строка);
		
	КонецЦикла;
	
КонецПроцедуры

// Формирует максимальную дату.
// Может быть полезно для сортировки по возрастанию, когда пустая дата должна быть последней, а не первой.
// 
// Возвращаемое значение:
//  Дата
// 
Функция МаксимальнаяДата() Экспорт
	
	МаксимальныйГод = 3999;
	МаксимальныйМесяц = 12;
	МаксимальныйДень = 31;
	МаксимальнаяДата = Дата(МаксимальныйГод, МаксимальныйМесяц, МаксимальныйДень);
	
	Возврат МаксимальнаяДата;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область СрокиИсполнения

// Определяет, является ли переданная строка числом
//
// Параметры:
//   СтрокаСимволов - Строка - строка символов
//
// Возвращаемое значение:
//   Булево - возвращает Истина, если строка является числом
//
Функция ЭтоЧисло(СтрокаСимволов)
	
	СтрокаСимволов = СокрЛП(СтрокаСимволов);
	
	Если Не ЗначениеЗаполнено(СтрокаСимволов) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ДлинаСтроки = СтрДлина(СтрокаСимволов);
	
	Для ТекущийСимвол = 1 По ДлинаСтроки Цикл
		
		КодСимвола = КодСимвола(СтрокаСимволов, ТекущийСимвол);
		
		Если КодСимвола < 48 Или КодСимвола > 57 Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти

Функция НайтиСтрокиВеткиДереваПоОтбору(Ветка, СтруктураОтбора, ТолькоПерваяСтрока)
	
	Результат = Новый Массив;
	
	СтрокиКОбработке = Новый Массив;
	Для Каждого Строка Из Ветка.ПолучитьЭлементы() Цикл
		СтрокиКОбработке.Добавить(Строка);
	КонецЦикла;
	
	Пока СтрокиКОбработке.Количество() > 0 Цикл
		
		ТекущаяСтрока = СтрокиКОбработке[0];
		СтрокиКОбработке.Удалить(0);
		
		ЕстьОтличия = Ложь;
		Для Каждого КлючИЗначение Из СтруктураОтбора Цикл
			Если ТекущаяСтрока[КлючИЗначение.Ключ] <> КлючИЗначение.Значение Тогда
				ЕстьОтличия = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если Не ЕстьОтличия Тогда
			Результат.Добавить(ТекущаяСтрока);
			Если ТолькоПерваяСтрока Тогда
				Прервать;
			КонецЕсли;
		КонецЕсли;
		
		Для Каждого Строка Из ТекущаяСтрока.ПолучитьЭлементы() Цикл
			СтрокиКОбработке.Добавить(Строка);
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

//Определяет по расширению является ли файл видеофайлом или нет
// Параметры:
//  Расширение - Строка - Расширение файла с точкой
// Возвращаемое значение:
//  Булево - результат проверки
//
Функция ЭтоВидеоКонтент(Расширение) Экспорт
	
	возврат СтрНайти(".mp4;.avi;.mkv;.m4v;", Расширение) <> 0
	
КонецФункции

//Определяет по расширению является ли файл аудиофайлом или нет
// Параметры:
//  Расширение - Строка - Расширение файла с точкой
// Возвращаемое значение:
//  Булево - результат проверки
//
Функция ЭтоАудиоКонтент(Расширение) Экспорт

	возврат СтрНайти(".mp3;.m4a;.wav;.ogg;", Расширение) <> 0

КонецФункции

#КонецОбласти
