#Область ПрограммныйИнтерфейс

// проверяет применимость алгоритма проверки к объекту
//
//Параметры:
//	Предмет - ссылка на документ
//	СсылкаНаАлгоритм - ссылка на алгоритм проверки
//Возвращает:
//	Истина, если Алгоритм применим
//	Ложь, если Алгоритм неприменим или указаны пустые ссылки
Функция ПроверитьПрименимостьАлгоритмаПроверкиКОбъекту(Знач Предмет, СсылкаНаАлгоритм) Экспорт
	
	Результат = Ложь;
	
	//Условия нет - возвращается Истина
	Если НЕ ЗначениеЗаполнено(СсылкаНаАлгоритм) Тогда
		Возврат Истина;
	КонецЕсли;
	
	ИндексЗначенияПеречисления = Перечисления.ТипыОбъектов.Индекс(СсылкаНаАлгоритм.ТипОбъекта);
	ИмяЗначенияПеречисления = Метаданные.Перечисления.ТипыОбъектов.ЗначенияПеречисления[ИндексЗначенияПеречисления].Имя;
	
	//Если Предмет не указан, в алгоритм проверки передается пустая ссылка того типа, который записан в условии маршрутизации 
	Если НЕ ЗначениеЗаполнено(Предмет) Тогда
		Предмет = Справочники[ИмяЗначенияПеречисления].ПустаяСсылка();
	КонецЕсли;
	
	//Если Предмет имеет другой тип по сравнению с тем, который указан в условии
	Если ИмяЗначенияПеречисления <> Предмет.Метаданные().Имя Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СпособЗаданияУсловия = СсылкаНаАлгоритм.СпособЗаданияУсловия;
	Если СпособЗаданияУсловия = Перечисления.СпособыЗаданияУсловия.НаВстроенномЯзыке Тогда
		
		Результат = ПроверитьАлгоритмНаВстроенномЯзыке(Предмет, СсылкаНаАлгоритм);
		
	ИначеЕсли СпособЗаданияУсловия = Перечисления.СпособыЗаданияУсловия.ВРежимеКонструктора Тогда
				
		Результат = ПроверитьАлгоритмВРежимеКонструктора(Предмет, 
			СсылкаНаАлгоритм.НастройкаУсловия.Получить(),
			ИмяЗначенияПеречисления);
	
	ИначеЕсли СпособЗаданияУсловия = Перечисления.СпособыЗаданияУсловия.КомбинацияИзДругихУсловий Тогда
		
		Настройки = СсылкаНаАлгоритм.НастройкаКомбинацииУсловий.Получить();
		ЗаполнитьКомбинациюПравил(Предмет, Настройки.Отбор.Элементы);
		Результат = ПроверитьАлгоритмВРежимеКонструктора(Предмет, 
			Настройки,
			"Условия",
			Ложь);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает Истину, елси Алгоритм выполнен положительно. 
// 
// Параметры:
// 	ПредметДействияОбъект - ОпределяемыйТип.ПредметДействияОбъект.
// 	СсылкаНаАлгоритм - СправочникСсылка.АлгоритмыПроверки - ссылка на Алгоритм.
// 	
// Возвращаемое значение:
// 	Булево - Истина, если Алгоритм выполнен успешно
//
Функция АлгоритмПоПредметуВыполняется(ПредметДействияОбъект, СсылкаНаАлгоритм) Экспорт
	
	Результат = Ложь;
	
	// Условия нет - возвращается Истина
	Если Не ЗначениеЗаполнено(СсылкаНаАлгоритм) Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Если Предмет не указан - возвращается Ложь.
	Если ПредметДействияОбъект = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;

	РеквизитыУсловия = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(СсылкаНаАлгоритм, 
		"СпособЗаданияУсловия, ТипОбъекта, НастройкаУсловия, НастройкаКомбинацииУсловий, Наименование, ВыражениеУсловия, Параметры");
	РеквизитыУсловия.Параметры = РеквизитыУсловия.Параметры.Выгрузить();
			
	СпособЗаданияУсловия = РеквизитыУсловия.СпособЗаданияУсловия;
	Если СпособЗаданияУсловия = Перечисления.СпособыЗаданияУсловия.НаВстроенномЯзыке Тогда
		
		Результат = ПроверитьАлгоритмНаВстроенномЯзыке(ПредметДействияОбъект, СсылкаНаАлгоритм, РеквизитыУсловия);
		
	ИначеЕсли СпособЗаданияУсловия = Перечисления.СпособыЗаданияУсловия.ВРежимеКонструктора Тогда
		
		ИндексЗначенияПеречисления = Перечисления.ТипыОбъектов.Индекс(РеквизитыУсловия.ТипОбъекта);
		ИмяЗначенияПеречисления = Метаданные.Перечисления.ТипыОбъектов.ЗначенияПеречисления[ИндексЗначенияПеречисления].Имя;
		Результат = ПроверитьАлгоритмВРежимеКонструктора(ПредметДействияОбъект.Ссылка, 
			РеквизитыУсловия.НастройкаУсловия.Получить(),
			ИмяЗначенияПеречисления);
	
	ИначеЕсли СпособЗаданияУсловия = Перечисления.СпособыЗаданияУсловия.КомбинацияИзДругихУсловий Тогда
		
		Настройки = РеквизитыУсловия.НастройкаКомбинацииУсловий.Получить();
		ЗаполнитьКомбинациюПравил(ПредметДействияОбъект.Ссылка, Настройки.Отбор.Элементы);
		Результат = ПроверитьАлгоритмВРежимеКонструктора(ПредметДействияОбъект.Ссылка, 
			Настройки,
			"Условия",
			Ложь);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает данные выбора из справочника Алгоритмы проверки по переданной строке.
// 
// Параметры:
//  Текст - Строка - текст поиска условия. 
//  ТипОбъекта - ПеречислениеСсылка.ТипыОбъектов, Неопределено - Тип объекта поиска
// 
// Возвращаемое значение:
//  СписокЗначений - Данные выбора
//
Функция ДанныеВыбора(Текст, ТипОбъекта = Неопределено) Экспорт
	
	ДанныеВыбора = Новый СписокЗначений();

	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	АлгоритмыПроверки.Ссылка
		|ИЗ
		|	Справочник.АлгоритмыПроверки КАК АлгоритмыПроверки
		|ГДЕ
		|	НЕ АлгоритмыПроверки.ПометкаУдаления
		|	И АлгоритмыПроверки.Наименование ПОДОБНО &СтрокаПоиска";
	
	Если ЗначениеЗаполнено(ТипОбъекта) Тогда
		Запрос.Текст = Запрос.Текст + "
		|	И АлгоритмыПроверки.ТипОбъекта = &ТипОбъекта";
		Запрос.Параметры.Вставить("ТипОбъекта", ТипОбъекта);
	КонецЕсли;
	
	Запрос.Параметры.Вставить("СтрокаПоиска", Текст + "%");
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		ДанныеВыбора.Добавить(Выборка.Ссылка);
	КонецЦикла;
	
	Возврат ДанныеВыбора;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПроверитьАлгоритмНаВстроенномЯзыке(Предмет, СсылкаНаАлгоритм, РеквизитыУсловия = Неопределено)
	
	Результат = Истина;
	
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		Для Каждого ИмяРазделителя Из РаботаВМоделиСервиса.РазделителиКонфигурации() Цикл
			УстановитьБезопасныйРежимРазделенияДанных(ИмяРазделителя, Истина);
		КонецЦикла;
	КонецЕсли;
	
	Если РеквизитыУсловия = Неопределено Тогда
		НаименованиеУсловия = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(
			СсылкаНаАлгоритм, "Наименование");
	Иначе
		НаименованиеУсловия = РеквизитыУсловия.Наименование;
	КонецЕсли;
	
	ПолноеВыражение = Справочники.АлгоритмыПроверки.ПолноеВыражениеУсловия(СсылкаНаАлгоритм, РеквизитыУсловия);	
	
	Попытка
		УстановитьБезопасныйРежим(Истина);
		Выполнить(ПолноеВыражение);
		УстановитьБезопасныйРежим(Ложь);
	Исключение
		Инфо = ИнформацияОбОшибке();
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Проверка алгоритма проверки'", ОбщегоНазначения.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,
			СсылкаНаАлгоритм.Метаданные(),
			СсылкаНаАлгоритм,
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(Инфо));
		ТекстИсключения = СтрШаблон(
			НСтр("ru = 'При проверке алгоритма проверки ""%1"" возникла ошибка:
				|%2
				|Обратитесь к администратору.'"),
			НаименованиеУсловия, 
			Инфо.Описание);
		ВызватьИсключение ТекстИсключения;
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

Функция ПроверитьАлгоритмВРежимеКонструктора(Предмет, Настройки, ИмяМакета, ЕстьПараметры = Истина)
	
	СхемаКомпоновкиДанных = Справочники.АлгоритмыПроверки.ПолучитьМакет(ИмяМакета);
	
	Компоновщик = Новый КомпоновщикНастроекКомпоновкиДанных;
	URLСхемы = ПоместитьВоВременноеХранилище(СхемаКомпоновкиДанных, Новый УникальныйИдентификатор());
	ИсточникНастроек = Новый ИсточникДоступныхНастроекКомпоновкиДанных(URLСхемы);
	Компоновщик.Инициализировать(ИсточникНастроек);
	Компоновщик.ЗагрузитьНастройки(Настройки);
	
	Если ЕстьПараметры Тогда
		ПараметрПредмет = Компоновщик.Настройки.ПараметрыДанных.Элементы[0];
		ПараметрПредмет.Значение = Предмет;
		ПараметрПредмет.Использование = Истина;
	КонецЕсли;
	
	//дополнительная обработка групп пользователей - разворачивание их в пользователей
	РазвернутьГруппыВУсловияхОтбора(Компоновщик.Настройки.Отбор.Элементы);
	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	
	МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, 
		Компоновщик.ПолучитьНастройки()
		,
		,
		, Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
    ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновки.Инициализировать(МакетКомпоновки);
    ТаблицаРезультата = Новый ТаблицаЗначений;
    ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
    ПроцессорВывода.УстановитьОбъект(ТаблицаРезультата);
	ПроцессорВывода.Вывести(ПроцессорКомпоновки);
	
	Результат = ТаблицаРезультата.Количество() > 0;
	
	Возврат Результат;
		
КонецФункции

Процедура ЗаполнитьКомбинациюПравил(Предмет, ЭлементыКомбинации)
	
	Для Каждого ЭлементОтбора Из ЭлементыКомбинации Цикл
		Если ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			ЗаполнитьКомбинациюПравил(Предмет, ЭлементОтбора.Элементы);		
		Иначе
			СпособЗаданияУсловия = ЭлементОтбора.ПравоеЗначение.СпособЗаданияУсловия;
			Если СпособЗаданияУсловия = Перечисления.СпособыЗаданияУсловия.НаВстроенномЯзыке Тогда
				Результат = ПроверитьАлгоритмНаВстроенномЯзыке(Предмет, ЭлементОтбора.ПравоеЗначение);
			ИначеЕсли СпособЗаданияУсловия = Перечисления.СпособыЗаданияУсловия.ВРежимеКонструктора Тогда
				ИндексЗначенияПеречисления = Перечисления.ТипыОбъектов.Индекс(ЭлементОтбора.ПравоеЗначение.ТипОбъекта);
				ИмяЗначенияПеречисления = Метаданные.Перечисления.ТипыОбъектов.ЗначенияПеречисления[ИндексЗначенияПеречисления].Имя;
				Результат = ПроверитьАлгоритмВРежимеКонструктора(Предмет, 
					ЭлементОтбора.ПравоеЗначение.НастройкаУсловия.Получить(),
					ИмяЗначенияПеречисления);
			ИначеЕсли СпособЗаданияУсловия = Перечисления.СпособыЗаданияУсловия.КомбинацияИзДругихУсловий Тогда
				НастройкиВложенногоПравила = ЭлементОтбора.ПравоеЗначение.НастройкаКомбинацииУсловий.Получить();
				ЗаполнитьКомбинациюПравил(Предмет, НастройкиВложенногоПравила.Отбор.Элементы);
				Результат = ПроверитьАлгоритмВРежимеКонструктора(Предмет, 
					НастройкиВложенногоПравила,
					"Условия",
					Ложь);
			КонецЕсли;
			
			ПолеОтбора = Новый ПолеКомпоновкиДанных("ПолеДляПроверки");
    		ЭлементОтбора.ЛевоеЗначение = ПолеОтбора;
    		ЭлементОтбора.Использование = Истина;
    		ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
			ЭлементОтбора.ПравоеЗначение = Результат;
		КонецЕсли;	
	КонецЦикла;
	
КонецПроцедуры

Процедура РазвернутьГруппыВУсловияхОтбора(ЭлементыОдногоУровня)
	
	Для Каждого ЭлементОтбора Из ЭлементыОдногоУровня Цикл
		Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
			Если ТипЗнч(ЭлементОтбора.ПравоеЗначение) = Тип("СправочникСсылка.РабочиеГруппы") Тогда
				
				СотрудникиГруппы = Справочники.РабочиеГруппы.СоставКонтейнераСотрудников(
					ЭлементОтбора.ПравоеЗначение);
				
				ЭлементОтбора.ПравоеЗначение = Новый СписокЗначений();
				ЭлементОтбора.ПравоеЗначение.ТипЗначения = Новый ОписаниеТипов("СправочникСсылка.Сотрудники");
				ЭлементОтбора.ПравоеЗначение.ЗагрузитьЗначения(СотрудникиГруппы);
				
				Если ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВИерархии Тогда
					ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке;
				ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеВИерархии Тогда
					ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеВСписке;
				КонецЕсли;
				
			ИначеЕсли ТипЗнч(ЭлементОтбора.ПравоеЗначение) = Тип("СписокЗначений") 
				И ЭлементОтбора.ПравоеЗначение.Количество() > 0
				И ТипЗнч(ЭлементОтбора.ПравоеЗначение[0].Значение) = Тип("СправочникСсылка.РабочиеГруппы") Тогда
				
				СписокСотрудниковГрупп = Новый Массив;
				Для Каждого РабочаяГруппа Из ЭлементОтбора.ПравоеЗначение Цикл
					
					СотрудникиГруппы = Справочники.РабочиеГруппы.СоставКонтейнераСотрудников(
						РабочаяГруппа.Значение);
					
					ЭлементОтбора.ПравоеЗначение = Новый СписокЗначений();
					ЭлементОтбора.ПравоеЗначение.ТипЗначения = Новый ОписаниеТипов("СправочникСсылка.Сотрудники");
					
					Для Каждого Сотрудник Из СотрудникиГруппы Цикл
						СписокСотрудниковГрупп.Добавить(Сотрудник);
					КонецЦикла;
				КонецЦикла;
				
				ЭлементОтбора.ПравоеЗначение = Новый СписокЗначений();
				ЭлементОтбора.ПравоеЗначение.ТипЗначения = Новый ОписаниеТипов("СправочникСсылка.Сотрудники");
				ЭлементОтбора.ПравоеЗначение.ЗагрузитьЗначения(СписокСотрудниковГрупп);
				Если ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСпискеПоИерархии Тогда
					ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке;				
				ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеВСпискеПоИерархии Тогда
					ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеВСписке;					
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			РазвернутьГруппыВУсловияхОтбора(ЭлементОтбора.Элементы);
		КонецЕсли;
	КонецЦикла;	
	
КонецПроцедуры

#КонецОбласти
