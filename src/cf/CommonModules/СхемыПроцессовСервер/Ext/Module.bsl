////////////////////////////////////////////////////////////////////////////////
// Серверные процедуры и функции по работе со схемами процессов.
//  
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

#Область ПроверкаКорректностиСхемы

// Выполняет проверку корректности графической схемы и возвращает результат проверки.
//
// Параметры:
//  Схема - ГрафическаяСхема
// 
// Возвращаемое значение:
//  Структура - см. СхемыПроцессовКлиентСервер.СтруктуруРезультатаПроверкиСхемы
//
Функция СхемаКорректна(Схема) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	РезультатПроверки = СхемыПроцессовКлиентСервер.СтруктуруРезультатаПроверкиСхемы();
	
	СтруктураДляПроверки = СтруктураДляПроверкиСхемы();
	ЗаполнитьКэшЭлементовВСтруктуреДляПроверки(СтруктураДляПроверки, Схема);
	ПроверитьЗаполнениеПредшественниковУЭлементов(СтруктураДляПроверки);
	СформироватьПутиПоСхеме(СтруктураДляПроверки);
	ПроверитьЗацикливаниеСхемы(СтруктураДляПроверки);
	ПроверитьКорректностьРазделенийИСлияний(СтруктураДляПроверки);
	
	ЭлементыГрафическойСхемы = СтруктураДляПроверки.ГрафическаяСхема.ЭлементыГрафическойСхемы;
	
	
	Если ЗначениеЗаполнено(СтруктураДляПроверки.ИмяНеприсоединеннойСоединительнойЛинии) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Соединительная линия ""%1"" не присоединена ни к одному элементу схемы.'"),
			СтруктураДляПроверки.ИмяНеприсоединеннойСоединительнойЛинии);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ИмяНеприсоединеннойСоединительнойЛинии;
		
		// IDS_NOT_CONNECTED_TO_ANY_POINT
	
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ИмяНедопустимогоЭлемента) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(СтруктураДляПроверки.ИмяНедопустимогоЭлемента);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Схема содержит недопустимый элемент: ""%1"".'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ИмяНедопустимогоЭлемента;
	
	ИначеЕсли СтруктураДляПроверки.КоличествоЭлементовСтарта > 1 Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Элемент старта может быть только один.'");
		
	ИначеЕсли СтруктураДляПроверки.КоличествоЭлементовСтарта = 0 Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Нет ни одного элемента старта.'");
		
		// IDS_NO_START_POINT
		
	ИначеЕсли СтруктураДляПроверки.КоличествоЭлементовЗавершения > 1 Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Элемент завершения может быть только один.'");
		
	ИначеЕсли СтруктураДляПроверки.КоличествоЭлементовЗавершения = 0 Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Нет ни одного элемента завершения.'");
			
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ИмяЭлементаБезВходящихСоединительныхЛиний) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.ИмяЭлементаБезВходящихСоединительныхЛиний);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Элемент ""%1"" не имеет ни одной входящей линии.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ИмяЭлементаБезВходящихСоединительныхЛиний;
		
		// IDS_STR_HAS_NO_START
		
	ИначеЕсли СтруктураДляПроверки.СложнаяКарта Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Проверка карты схемы процесса не выполнена, т.к. она слишком сложная.'");
		
		// IDS_TOO_COMPLEX_MAP
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ИмяЭлементаОбрыва) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.ИмяЭлементаОбрыва);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Элемент ""%1"" не имеет пути к завершению схемы.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ИмяЭлементаОбрыва;
		
		// IDS_HAS_NO_PATH
		
	ИначеЕсли СтруктураДляПроверки.НетЗавершенныхПутей Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'В схеме нет ни одного завершенного пути.'");
		
		// IDS_STR_NO_ROUTE
		
	ИначеЕсли СтруктураДляПроверки.ЕстьЦиклыБезБлоковВыполнения Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = 
			НСтр("ru = 'Есть циклы не имеющие ни одного блока выполнения.'");
		
		// IDS_STR_HAS_CYCLES_WITHOUT_ROUTE_POINTS
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ИмяЭлементаВКоторыйНевозможноПопасть) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.ИмяЭлементаВКоторыйНевозможноПопасть);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'В элемент ""%1"" невозможно попасть.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ИмяЭлементаВКоторыйНевозможноПопасть;
		
		// IDS_STR_UNREACHABLE_CODE
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ЦиклИзКоторогоНедоступноЗавершение) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'В схеме есть зацикливание: %1'"),
			СтруктураДляПроверки.ЦиклИзКоторогоНедоступноЗавершение);
		
		// IDS_FOUND_CYCLING
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.РазделениеСОднойИсходящейЛинией) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.РазделениеСОднойИсходящейЛинией);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'У разделения ""%1"" есть только одна исходящая линия.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.РазделениеСОднойИсходящейЛинией;
		
		// IDS_STR_ONLY_ONE_OUTGOING_LINE_FROM_BRANCHING
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.РазделениеСНесколькимиИсходящимиЛиниямиВОдинЭлемент) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.РазделениеСНесколькимиИсходящимиЛиниямиВОдинЭлемент);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Нельзя из разделения ""%1"" нескольким исходящим линиями входить в один и тот же элемент.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.РазделениеСНесколькимиИсходящимиЛиниямиВОдинЭлемент;
		
		// IDS_STR_BRANCHING_SAME_NEXT_POINT
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.СлияниеСОднойВходящейЛинией) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.СлияниеСОднойВходящейЛинией);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'У слияния ""%1"" есть только одна входящая линия.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.СлияниеСОднойВходящейЛинией;
		
		// IDS_STR_ONLY_ONE_INCOMING_LINE_INTO_GATHERING
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.СлияниеБезРазделения) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.СлияниеБезРазделения);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Не все линии, вошедшие слияние ""%1"" вышли из разделения.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.СлияниеБезРазделения;
		
		// IDS_STR_GATHERING_MISMATCH
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.СлияниеСразуПослеРазделения) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.СлияниеСразуПослеРазделения);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Нельзя сразу из разделения ""%1"" попадать в слияние.'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.СлияниеСразуПослеРазделения;
		
		// IDS_STR_BRANCHING_IMMEDIATELY_AFTER_GATHERING
		
	ИначеЕсли ЗначениеЗаполнено(СтруктураДляПроверки.ЭлементПересеченияРазделений) Тогда
		
		РезультатПроверки.НетОшибок = Ложь;
		
		ЭлементСхемы = ЭлементыГрафическойСхемы.Найти(
			СтруктураДляПроверки.ЭлементПересеченияРазделений);
		НаименованиеЭлемента = НаименованиеЭлемента(ЭлементСхемы);
		РезультатПроверки.ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Запрещено распараллеленным веткам входить в один и то же элемент ""%1"".'"),
			НаименованиеЭлемента);
		
		РезультатПроверки.ИмяЭлемента = СтруктураДляПроверки.ЭлементПересеченияРазделений;
		
		// IDS_STR_BRANCHING_MERGE
		
	КонецЕсли;
	
	Возврат РезультатПроверки
	
КонецФункции

#КонецОбласти

#Область РаботаСДаннымиСхемы

// Возвращает данные схемы по умолчанию.
// 
// Возвращаемое значение:
//  Структура - см. Справочники.СхемыПроцессов.СтруктураДанныхСхемыПроцесса
// 
Функция ДанныеСхемыПоУмолчанию() Экспорт
	
	ОписаниеСхемы = Новый Массив();
		
	ЭлементСтарт = Справочники.СхемыПроцессов.ОписаниеЭлементаСтарт();
	ЭлементСтарт.Лево = 60;
	ЭлементСтарт.Верх = 20;
	ЭлементСтарт.ИмяПоследователя = "Обработка1";
	ОписаниеСхемы.Добавить(ЭлементСтарт);
	
	ЭлементДействие = Справочники.СхемыПроцессов.ОписаниеЭлементаДействие();
	ЭлементДействие.Имя = "Обработка1";
	ЭлементДействие.Наименование = НСтр("ru = 'Действие 1'");
	ЭлементДействие.Лево = 20;
	ЭлементДействие.Верх = 80;
	ЭлементДействие.ИмяПоследователя = "Обработка2";
	ОписаниеСхемы.Добавить(ЭлементДействие);
	
	ЭлементДействие = Справочники.СхемыПроцессов.ОписаниеЭлементаДействие();
	ЭлементДействие.Имя = "Обработка2";
	ЭлементДействие.Наименование = НСтр("ru = 'Действие 2'");
	ЭлементДействие.Лево = 20;
	ЭлементДействие.Верх = 160;
	ЭлементДействие.ИмяПоследователя = "Завершение";
	ОписаниеСхемы.Добавить(ЭлементДействие);
	
	ЭлементЗавершение = Справочники.СхемыПроцессов.ОписаниеЭлементаЗавершение();
	ЭлементЗавершение.Лево = 60;
	ЭлементЗавершение.Верх = 240;
	ОписаниеСхемы.Добавить(ЭлементЗавершение);
	
	ДанныхСхемыПроцесса = 
		Справочники.СхемыПроцессов.ДанныеСхемыПоОписаниюЭлементов(ОписаниеСхемы);
	
	Возврат ДанныхСхемыПроцесса;
	
КонецФункции

// Возвращает таблицу предшественников элементов по схеме.
// 
// Параметры:
// 	ДанныеСхемы - Структура - см. СхемыПроцессовКлиентСервер.СтруктураДанныхСхемыПроцесса() 
// 	
// Возвращаемое значение:
//  Предшественники - ТаблицаЗначений
//    * Имя - Строка
//    * ИмяПредшественника - Строка
//    * РезультатУсловияПерехода - Строка - см. РезультатУсловияПереходаСтрокой()
// 	
Функция ПредшественникиЭлементовПоДаннымСхемы(ДанныеСхемы) Экспорт
	
	Предшественники = Новый ТаблицаЗначений;
	Предшественники.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
	Предшественники.Колонки.Добавить("ИмяПредшественника", Новый ОписаниеТипов("Строка"));
	
	Предшественники.Колонки.Добавить(
		"РезультатУсловияПерехода", Новый ОписаниеТипов("Строка"));
	
	Предшественники.Индексы.Добавить("ИмяПредшественника");
	Предшественники.Индексы.Добавить("ИмяПредшественника, РезультатУсловияПерехода");

	Для Каждого ЭлементСхемы Из ДанныеСхемы.Схема.ЭлементыГрафическойСхемы Цикл
		
		Если ТипЗнч(ЭлементСхемы) <> Тип("ЭлементГрафическойСхемыСоединительнаяЛиния") Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокаТаблицы = Предшественники.Добавить();
		
		Если ЭлементСхемы.НачалоЭлемент <> Неопределено Тогда
			СтрокаТаблицы.ИмяПредшественника = ЭлементСхемы.НачалоЭлемент.Имя;
		КонецЕсли;
		
		Если ЭлементСхемы.КонецЭлемент <> Неопределено Тогда
			СтрокаТаблицы.Имя = ЭлементСхемы.КонецЭлемент.Имя;			
		КонецЕсли;
		
		СтрокаТаблицы.РезультатУсловияПерехода = РезультатУсловияПереходаСтрокой(
			ДанныеСхемы.Настройки.СоединительныеЛинииУсловий[ЭлементСхемы.Имя]);
		
	КонецЦикла;
	
	Возврат Предшественники;
	
КонецФункции

// Возвращает возможные пути схемы процесса по таблице предшественников,
// исключая циклы.
//
// Параметры:
//  ИмяПервогоЭлемента - Строка - имя первого элемента в пути (старт).
//  Предшественники - ТаблицаЗначений - см. ПредшественникиЭлементовПоДаннымСхемы
//
// Возвращаемое значение:
//  Массив - список путей.
//   * Массив - каждый путь это массив имен элементов в этом пути.
//
Функция ПутиСхемыПроцесса(ИмяПервогоЭлемента, Предшественники) Экспорт
	
	ВсеПути = Новый Массив;
	
	Если ЗначениеЗаполнено(ИмяПервогоЭлемента) Тогда
		// Добавим первый путь в массив всех путей.
		ВсеПути.Добавить(Новый Массив);
		
		ДобавитьПоследователейЭлементаСхемыВПуть(
			ВсеПути, 0, Предшественники, ИмяПервогоЭлемента);
	КонецЕсли;
	
	Возврат ВсеПути;
	
КонецФункции

// Выделяем из в путях схемы последовательности действий,
// удаляя лишние элементы.
//
// Параметры:
//  Пути - Массив - см. ПутиСхемыПроцесса
//  ДанныеСхемы - Структура - СхемыПроцессовКлиентСервер.СтруктураДанныхСхемыПроцесса
//  ТипыЭлементов - Соответствие - допустимые типы элементов в путях.
//   * Ключ - ПеречислениеСсылка.ТипыЭлементовСхемПроцессов
//   * Значение - Булево - всегда Истина 
//
Процедура ВыделитьПоследовательностиЭлементовВПутях(Пути, ДанныеСхемы, ТипыЭлементов) Экспорт
	
	// Обойдем все пути и удалим все элементы типы которых отсутствуют в ТипыЭлементов.
	// Если в пути не остается элементов, то его тоже удаляем.
	ИндексПути = Пути.Количество() - 1;
	Пока ИндексПути >= 0 Цикл
		
		Путь = Пути[ИндексПути];
		
		ИндексЭлемента = Путь.Количество() - 1;
		
		Пока ИндексЭлемента >= 0 Цикл
			
			ИмяЭлемента = Путь[ИндексЭлемента];
			
			ТипЭлемента = СхемыПроцессовКлиентСервер.ТипЭлементаСхемы(ДанныеСхемы, ИмяЭлемента);
					
			Если ТипыЭлементов[ТипЭлемента] = Неопределено Тогда
				Путь.Удалить(ИндексЭлемента);
			КонецЕсли;
			
			ИндексЭлемента = ИндексЭлемента - 1;
		КонецЦикла;
		
		Если Путь.Количество() = 0 Тогда
			Пути.Удалить(ИндексПути);
		КонецЕсли;
		
		ИндексПути = ИндексПути - 1;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает условие перехода от элемента к элементу в виде строки.
// 
// Параметры:
// 	РезультатУсловия - Булево, Неопределено
// 	
// Возвращаемое значение:
// 	Строка - одно из значений: "ПоложительныйРезультат", "ОтрицательныйРезультат", "НетРезультата"
//
Функция РезультатУсловияПереходаСтрокой(РезультатУсловия) Экспорт
	
	Если РезультатУсловия = Истина Тогда
		Возврат "ПоложительныйРезультат";
	ИначеЕсли РезультатУсловия = Ложь Тогда
		Возврат "ОтрицательныйРезультат";
	Иначе
		Возврат "НетРезультата";
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область РаботаССхемойВФорме

// Читает схему в форму с возможность отображения/редактирования.
// В форме должны быть соответствующие реквизиты и элементы управления.
// 
// Параметры:
// 	Схема - СправочникСсылка.СхемыПроцессов
// 	Форма - ФормаКлиентскогоПриложения.
//
Процедура ПрочитатьСхемуВФорму(СхемаПроцесса, Форма) Экспорт

	УстановитьПривилегированныйРежим(Истина);
	
	Форма.ДанныеСхемы = СхемыПроцессовКлиентСервер.СтруктураДанныхСхемыВФорме();
	
	Если ЗначениеЗаполнено(СхемаПроцесса) Тогда
		
		ДанныхСхемыПроцесса = Справочники.СхемыПроцессов.ДанныеСхемыПроцесса(СхемаПроцесса);
		
		Если Не МК_ПовтИсп.ЭтоМобильныйКлиент() Тогда
			УстановитьГрафическуюСхемуВФорму(ДанныхСхемыПроцесса.Схема, Форма);
			УстановитьНастройкиСхемыВФорму(ДанныхСхемыПроцесса.Настройки, Форма);
		Иначе 
			УстановитьГрафическуюСхемуВФормуМК(ДанныхСхемыПроцесса.Схема, Форма);
		КонецЕсли;
				
		Форма.ДанныеСхемы.Ссылка = СхемаПроцесса;		
		Форма.ДанныеСхемы.Наименование = ДанныхСхемыПроцесса.Наименование;
		Форма.ДанныеСхемы.ВерсияДанных = ДанныхСхемыПроцесса.ВерсияДанных;
		
	Иначе
		
		ДанныхСхемыПроцесса = ДанныеСхемыПоУмолчанию();
		
		Если Не МК_ПовтИсп.ЭтоМобильныйКлиент() Тогда
			
			УстановитьГрафическуюСхемуВФорму(ДанныхСхемыПроцесса.Схема, Форма);
			УстановитьНастройкиСхемыВФорму(ДанныхСхемыПроцесса.Настройки, Форма);
		Иначе 
			УстановитьГрафическуюСхемуВФормуМК(ДанныхСхемыПроцесса.Схема, Форма);
		КонецЕсли;

		Форма.ДанныеСхемы.СхемаИзменена = Истина;
		
	КонецЕсли;
	
	УстановитьПоддерживаемыеТипыЭлементовСхемыВФорму(
		СхемыПроцессовКлиентСервер.ПоддерживаемыеТипыЭлементовСхемыПоУмолчанию(),
		Форма);
	
КонецПроцедуры

// Настраивает доступность редактирования схемы процесса в форме.
// 
// Параметры:
// 	Форма - ФормаКлиентскогоПриложения
// 	Доступность - Булево
//
Процедура НастроитьДоступностьРедактированияСхемы(Форма, Доступность) Экспорт
	
	Форма.Элементы.Схема.ТолькоПросмотр = Не Доступность;
	Форма.Элементы.КомандыСхемы.Доступность = Доступность;
	Форма.Схема.ИспользоватьСетку = Доступность;
		
КонецПроцедуры

// Записывает схему процесса из формы.
// 
// Параметры:
// 	Форма - ФормаКлиентскогоПриложения
//
Процедура ЗаписатьСхемуИзФормы(Форма) Экспорт

	УстановитьПривилегированныйРежим(Истина);
	
	Если Не Форма.ДанныеСхемы.СхемаИзменена Тогда
		Возврат;
	КонецЕсли;
	
	ДанныхСхемыПроцесса = СхемыПроцессовКлиентСервер.ДанныеСхемыПроцессаИзФормы(Форма);
			
	РезультатЗаписи = Справочники.СхемыПроцессов.ЗаписатьДанныеСхемыПроцесса(
		Форма.ДанныеСхемы.Ссылка, ДанныхСхемыПроцесса);
	
	Если Не ЗначениеЗаполнено(Форма.ДанныеСхемы.Ссылка) Тогда
		Форма.ДанныеСхемы.Ссылка = РезультатЗаписи.СхемаПроцесса;
	КонецЕсли;
	 
	Форма.ДанныеСхемы.ВерсияДанных = РезультатЗаписи.ВерсияДанных;
	
	Форма.ДанныеСхемы.СхемаИзменена = Ложь;
	
КонецПроцедуры

// Создает копию данных схемы из формы и возвращает ее в виде структуры.
// 
// Параметры:
//  Форма - ФормаКлиентскогоПриложения - карточка со схемой.
// 
// Возвращаемое значение:
//  Структура
//   * Схема - ХранилищеЗначения - графическая схема в форме упакованная в хранилище значения.
//   * ДанныеСхемы - ХранилищеЗначения - данные схемы в форме.
//
Функция СкопироватьДанныеСхемыПроцессыИзФормы(Форма) Экспорт
		
	КопияДанныхСхемы = Новый Структура;
	
	КопияДанныхСхемы.Вставить("Схема", Новый ХранилищеЗначения(Форма.Схема));
	КопияДанныхСхемы.Вставить("ДанныеСхемы", Новый ХранилищеЗначения(Форма.ДанныеСхемы));
	
	Возврат КопияДанныхСхемы;
	
КонецФункции

// Восстановить схему процесса в форме из копиданных схемы.
// 
// Параметры:
//  Форма - ФормаКлиентскогоПриложения - карточка со схемой.
//  КопияДанныхСхемы - Структура - см. СкопироватьДанныеСхемыПроцессыИзФормы
//
Процедура ВосстановитьСхемуПроцессаИзКопииДанных(Форма, КопияДанныхСхемы) Экспорт
	
	Форма.ДанныеСхемы = КопияДанныхСхемы.ДанныеСхемы.Получить();
	Форма.Схема = КопияДанныхСхемы.Схема.Получить();
	
КонецПроцедуры

// Устанавливает графическую схему в форме.
// 
// Параметры:
// 	Схема - ГрафическаяСхема
// 	Форма - ФормаКлиентскогоПриложения 
//
Процедура УстановитьГрафическуюСхемуВФорму(Схема, Форма) Экспорт
	
	Форма.Схема = Схема;
	Форма.ДанныеСхемы.СхемаИзменена = Истина;
					
КонецПроцедуры

// Устанавливает картинку графической схемы в форму на мобильном.
// 
// Параметры:
// 	Схема - ГрафическаяСхема
// 	Форма - ФормаКлиентскогоПриложения 
//
Процедура УстановитьГрафическуюСхемуВФормуМК(Схема, Форма) Экспорт
	
	Форма.Схема = ПолучитьКартинкуСхемы(Схема);
	Форма.ДанныеСхемы.СхемаИзменена = Истина;
					
КонецПроцедуры

// Возвращает адрес картинки во временном хранилище грфической схемы.
// 
// Возвращаемое значение:
// 	Строка - адрес картинки во временном хранилище
//
Функция ПолучитьКартинкуСхемы(Схема)
	
		АдресКартинки = ПоместитьВоВременноеХранилище(Схема.ПолучитьКартинку());
	
	Возврат АдресКартинки;
	
КонецФункции

// Устанавливает настройки схемы в форму.
//
// Параметры:
// 	Настройки - Структура - см. СхемыПроцессовКлиентСервер.СтруктураНастроекСхемыПроцесса
// 	Форма - ФормаКлиентскогоПриложения
//
Процедура УстановитьНастройкиСхемыВФорму(Настройки, Форма) Экспорт
	
	Форма.ДанныеСхемы.НастройкиСхемы = Настройки;
	Форма.ДанныеСхемы.СхемаИзменена = Истина;
	
КонецПроцедуры

// Устанавливает поддерживаемые типы элементов схемы в форму.
// 
// Параметры:
//  ТипыЭлементов - Соответствие
//   * Ключ - ПеречислениеСсылка.ТипыЭлементовСхемПроцессов
//   * Значение - Булево - всегда Истина.
//  Форма - ФормаКлиентскогоПриложения
//
Процедура УстановитьПоддерживаемыеТипыЭлементовСхемыВФорму(ТипыЭлементов, Форма) Экспорт
	
	Форма.ДанныеСхемы.ПоддерживаемыеТипыЭлементов = ТипыЭлементов;
	
КонецПроцедуры

// Проверить корректность схемы в форме.
// 
// Параметры:
//  Форма - ФормаКлиентскогоПриложения
//
Процедура ПроверитьКорректностьСхемыВФорме(Форма) Экспорт
	
	Форма.ДанныеСхемы.РезультатПроверкиСхемы = СхемаКорректна(Форма.Схема);
	
КонецПроцедуры

#КонецОбласти

// Возвращает доступность настройки скриптов в схемах процессов.
// 
// Возвращаемое значение:
// 	Булево
//
Функция ДоступнаНастройкаСкриптовВСхемахПроцессов() Экспорт
	
	Возврат РольДоступна("ДобавлениеИзменениеНСИ") Или РольДоступна("ПолныеПрава");
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ПроверкаКорректностиСхемы

// Возвращает структуру для проверки схемы.
//
// Возвращаемое значение:
//  Структура
//
Функция СтруктураДляПроверкиСхемы()
	
	СтруктураДляПроверки = Новый Структура;
	
	// Кэш элементов схемы.
	СтруктураДляПроверки.Вставить("ЭлементыСхемы", Новый Соответствие);
	СтруктураДляПроверки.Вставить("СоединительныеЛинииСхемы", Новый Соответствие);
	СтруктураДляПроверки.Вставить("Слияния", Новый Массив);
	СтруктураДляПроверки.Вставить("Разделения", Новый Массив);
	СтруктураДляПроверки.Вставить("ЭлементСтарта", "");
	СтруктураДляПроверки.Вставить("ЭлементЗавершения", "");
	СтруктураДляПроверки.Вставить("ГрафическаяСхема", Неопределено);
	
	// Пути схемы.
	СтруктураДляПроверки.Вставить("ЗавершенныеПути", Новый Массив);
	СтруктураДляПроверки.Вставить("Циклы", Новый Массив);
	
	// Результат проверки.
	СтруктураДляПроверки.Вставить("ПроверкаЗавершена", Ложь);
	СтруктураДляПроверки.Вставить("СложнаяКарта", Ложь);
	СтруктураДляПроверки.Вставить("НетЗавершенныхПутей", Ложь);
	СтруктураДляПроверки.Вставить("ЕстьЦиклыБезБлоковВыполнения", Ложь);
	СтруктураДляПроверки.Вставить("КоличествоЭлементовСтарта", 0);
	СтруктураДляПроверки.Вставить("КоличествоЭлементовЗавершения", 0);
	СтруктураДляПроверки.Вставить("ИмяНедопустимогоЭлемента", "");
	СтруктураДляПроверки.Вставить("ИмяНеприсоединеннойСоединительнойЛинии", "");
	СтруктураДляПроверки.Вставить("ИмяЭлементаБезВходящихСоединительныхЛиний", "");
	СтруктураДляПроверки.Вставить("ИмяЭлементаОбрыва", "");
	СтруктураДляПроверки.Вставить("ИмяЭлементаВКоторыйНевозможноПопасть", "");
	СтруктураДляПроверки.Вставить("ЦиклИзКоторогоНедоступноЗавершение", "");
	СтруктураДляПроверки.Вставить("РазделениеСОднойИсходящейЛинией", "");
	СтруктураДляПроверки.Вставить("РазделениеСНесколькимиИсходящимиЛиниямиВОдинЭлемент", "");
	СтруктураДляПроверки.Вставить("СлияниеСОднойВходящейЛинией", "");
	СтруктураДляПроверки.Вставить("СлияниеБезРазделения", "");
	СтруктураДляПроверки.Вставить("СлияниеСразуПослеРазделения", "");
	СтруктураДляПроверки.Вставить("ЭлементПересеченияРазделений", "");
	
	Возврат СтруктураДляПроверки;
	
КонецФункции

// Заполняет кэш элементов схемы в структуре для проверки.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//  Схема - ГрафическаяСхема
//
Процедура ЗаполнитьКэшЭлементовВСтруктуреДляПроверки(СтруктураДляПроверки, Схема)
	
	СтруктураДляПроверки.ГрафическаяСхема = Схема;
	
	Если СтруктураДляПроверки.ГрафическаяСхема.ЭлементыГрафическойСхемы.Количество() = 0 Тогда
		СтруктураДляПроверки.ПроверкаЗавершена = Истина;
		Возврат;
	КонецЕсли;
	
	НеПоддерживаемыеЭлементы = СхемыПроцессовКлиентСервер.НеПоддерживаемыеЭлементыГрафическойСхемы(); 
	
	// Заполним соотвествия ЭлементыГрафическойСхемы и СоединительныеЛинииГрафическойСхемы
	// и выполним возможные проверки.
	// В случаи ошибок заполнения, прерываем заполнение.
	Для Каждого Элемент Из СтруктураДляПроверки.ГрафическаяСхема.ЭлементыГрафическойСхемы Цикл
		
		ТипЭлемента = ТипЗнч(Элемент);
		
		// Пропуская декоративные линии и декорации.
		Если ТипЭлемента = Тип("ЭлементГрафическойСхемыДекоративнаяЛиния")
			Или ТипЭлемента = Тип("ЭлементГрафическойСхемыДекорация") Тогда
			
			Продолжить;
		КонецЕсли;
		
		// Прерываем проверку, если схема содержит недопустимые элементы.
		Если НеПоддерживаемыеЭлементы[ТипЭлемента] = Истина Тогда
			СтруктураДляПроверки.ИмяНедопустимогоЭлемента = Элемент.Имя;
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			Возврат;
		КонецЕсли;
		
		// Считаем количество элементов старта и если их больше 1го, то прерываем проверку.
		Если ТипЭлемента = Тип("ЭлементГрафическойСхемыСтарт") Тогда
			СтруктураДляПроверки.КоличествоЭлементовСтарта = 
				СтруктураДляПроверки.КоличествоЭлементовСтарта + 1;
			Если СтруктураДляПроверки.КоличествоЭлементовСтарта > 1 Тогда
				СтруктураДляПроверки.ПроверкаЗавершена = Истина;
				Возврат;
			КонецЕсли;
			СтруктураДляПроверки.ЭлементСтарта = Элемент.Имя;
		КонецЕсли;
		
		// Считаем количество элементов завершения и если их больше 1го, то прерываем проверку.
		Если ТипЭлемента = Тип("ЭлементГрафическойСхемыЗавершение") Тогда
			СтруктураДляПроверки.КоличествоЭлементовЗавершения =
				СтруктураДляПроверки.КоличествоЭлементовЗавершения + 1;
			Если СтруктураДляПроверки.КоличествоЭлементовЗавершения > 1 Тогда
				СтруктураДляПроверки.ПроверкаЗавершена = Истина;
				Возврат;
			КонецЕсли;
			СтруктураДляПроверки.ЭлементЗавершения = Элемент.Имя;
		КонецЕсли;
		
		// Помещаем все элементы в соответствие ЭлементыГрафическойСхемы,
		// а соединительные линии в СоединительныеЛинииГрафическойСхемы
		Если ТипЭлемента = Тип("ЭлементГрафическойСхемыСоединительнаяЛиния") Тогда
			
			НачалоЭлемент = Элемент.НачалоЭлемент;
			КонецЭлемент = Элемент.КонецЭлемент;
			
			// Если линия не присоединена, то прерываем проверку.
			Если НачалоЭлемент = Неопределено Или КонецЭлемент = Неопределено Тогда
				СтруктураДляПроверки.ИмяНеприсоединеннойСоединительнойЛинии = Элемент.Имя;
				СтруктураДляПроверки.ПроверкаЗавершена = Истина;
				Возврат;
			КонецЕсли;
			
			СоединительнаяЛинияГрафическойСхемы = СоединительнаяЛинияГрафическойСхемы();
			СоединительнаяЛинияГрафическойСхемы.Предшественник = НачалоЭлемент.Имя;
			СоединительнаяЛинияГрафическойСхемы.Последователь = КонецЭлемент.Имя;
			
			СтруктураДляПроверки.СоединительныеЛинииСхемы.Вставить(
				Элемент.Имя,
				СоединительнаяЛинияГрафическойСхемы);
		Иначе
			
			ЭлементГрафическойСхемы = ЭлементГрафическойСхемы();
			ЭлементГрафическойСхемы.Тип = ТипЭлемента;
			
			СтруктураДляПроверки.ЭлементыСхемы.Вставить(
				Элемент.Имя,
				ЭлементГрафическойСхемы);
		КонецЕсли;
		
		// Поместим имена сляний и разделение в отдельные массивы структуры для проверки.
		Если ТипЭлемента = Тип("ЭлементГрафическойСхемыСлияние") Тогда
			СтруктураДляПроверки.Слияния.Добавить(Элемент.Имя);
		ИначеЕсли ТипЭлемента = Тип("ЭлементГрафическойСхемыРазделение") Тогда
			СтруктураДляПроверки.Разделения.Добавить(Элемент.Имя);
		КонецЕсли;
		
	КонецЦикла;
	
	// Заполним предшественников и последователей элементов в соотвествии ЭлементыСхемы
	// по соединительными линиям (СоединительныеЛинииСхемы)
	Для Каждого Линия Из СтруктураДляПроверки.СоединительныеЛинииСхемы Цикл
		
		ПараметрыЛинии = Линия.Значение;
		
		// Заполняем предшественников
		ЭлементСхемы = СтруктураДляПроверки.ЭлементыСхемы.Получить(ПараметрыЛинии.Последователь);
		ЭлементСхемы.Предшественники.Добавить(ПараметрыЛинии.Предшественник);
		
		// Заполняем последователей
		ЭлементСхемы = СтруктураДляПроверки.ЭлементыСхемы.Получить(ПараметрыЛинии.Предшественник);
		ЭлементСхемы.Последователи.Добавить(ПараметрыЛинии.Последователь);
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает структуру соединительной линии в кэше элементов структуры для проверки.
//
// Возвращаемое значение:
//  Структура
//   * Предшественник - Строка - имя предшествующего элемента.
//   * Последователь - Строка - имя последующего элемента.
//
Функция СоединительнаяЛинияГрафическойСхемы()
	
	СоединительнаяЛиния = Новый Структура;
	СоединительнаяЛиния.Вставить("Предшественник", "");
	СоединительнаяЛиния.Вставить("Последователь", "");
	
	Возврат СоединительнаяЛиния;
	
КонецФункции

// Возвращает структуру графического элемента в кэше элементов структуры для проверки.
//
// Возвращаемое значение:
//  Структура
//   * Тип - ЭлементГрафическойСхемыДействие,
//           ЭлементГрафическойСхемыРазделение,
//           ЭлементГрафическойСхемыУсловие,
//           ЭлементГрафическойСхемыЗавершение,
//           ЭлементГрафическойСхемыСтарт,
//           ЭлементГрафическойСхемыСлияние,
//           ЭлементГрафическойСхемыВложенныйБизнесПроцесс - тип элемента графической схемы.
//   * Предшественники - Массив - имена предшествующих элементов.
//   * Последователи - Массив - имена последующих элементов.
//
Функция ЭлементГрафическойСхемы()
	
	ЭлементГрафическойСхемы = Новый Структура;
	ЭлементГрафическойСхемы.Вставить("Тип", Неопределено);
	ЭлементГрафическойСхемы.Вставить("Предшественники", Новый Массив);
	ЭлементГрафическойСхемы.Вставить("Последователи", Новый Массив);
	
	Возврат ЭлементГрафическойСхемы;
	
КонецФункции

// Проверяет заполнение предшественников у элементов.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//
Процедура ПроверитьЗаполнениеПредшественниковУЭлементов(СтруктураДляПроверки)
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	// Проверяем заполнение предшественников у элементов.
	// Если элемент не Старт и у него нет входящих соединительных линий - прерываем проверку.
	Для Каждого Элемент Из СтруктураДляПроверки.ЭлементыСхемы Цикл
		
		ПараметрыЭлемента = Элемент.Значение;
		
		// Пропускаем элемент Старта.
		Если ПараметрыЭлемента.Тип = Тип("ЭлементГрафическойСхемыСтарт") Тогда
			Продолжить;
		КонецЕсли;
		
		Если ПараметрыЭлемента.Предшественники.Количество() = 0 Тогда
			СтруктураДляПроверки.ИмяЭлементаБезВходящихСоединительныхЛиний = Элемент.Ключ;
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			Возврат;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Формирует список завершенных путей и циклов по схеме процесса.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//
Процедура СформироватьПутиПоСхеме(СтруктураДляПроверки)
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	// Создадим начальный путь с одим элементом старта и поместим его в массив путей для обработки.
	Путь = Новый Массив;
	Путь.Добавить(СтруктураДляПроверки.ЭлементСтарта);
	
	ПутиВОбработке = Новый Массив;
	ПутиВОбработке.Добавить(Путь);
	
	КоличествоЭлементовИЛиний = СтруктураДляПроверки.ЭлементыСхемы.Количество()
		+ СтруктураДляПроверки.СоединительныеЛинииСхемы.Количество();
	
	// Вычислим количество циклов определения путей. Количество должно быть конечно, т.к.
	// использовать бесконечный цикл с условием выхода опасно - из за ошибки можно получить зависание программы.
	КоличествоЦикловОпределенияПути = КоличествоЭлементовИЛиний * 10;
	
	// Определим максимальное количество путей. В случае превышения прерываем проверку.
	// Нужно, чтобы не ожидать очень долго проверки сложной карты маршрута.
	МаксимальноеКоличествоПутей = КоличествоЭлементовИЛиний * 100;
	
	// Выполняем поиск всех путей
	Для НомерЦикла = 0 По КоличествоЦикловОпределенияПути Цикл
		
		НовыеПутиКОбработке = Новый Массив;
		
		Если ПутиВОбработке.Количество() >= МаксимальноеКоличествоПутей Тогда
			СтруктураДляПроверки.СложнаяКарта = Истина;
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			Прервать;
		КонецЕсли;
		
		// Обходим все пути в обработке.
		Для Каждого ОбрабатываемыйПуть Из ПутиВОбработке Цикл
			
			// Продвигаемся по пути схемы.
			РезультатПродвижения = ПродвинутьсяПоПутиСхемы(
				СтруктураДляПроверки, ОбрабатываемыйПуть, НовыеПутиКОбработке);
			
			// Выполняем проверку результата продвижения и помещаем путь в соответствующий список структуры для проверки.
			// В случае обрыва прерываем обработку.
			Если РезультатПродвижения = "УПутиЕстьПродолжение" Тогда
				
				НовыеПутиКОбработке.Добавить(
					ОбщегоНазначенияДокументооборотКлиентСервер.ПростаяКопияМассива(ОбрабатываемыйПуть));
				
			ИначеЕсли РезультатПродвижения = "ПутьЗавершен" Тогда
				
				СтруктураДляПроверки.ЗавершенныеПути.Добавить(ОбрабатываемыйПуть);
				
			ИначеЕсли РезультатПродвижения = "ПутьИмеетЦикл" Тогда
				
				ВыделитьЦиклВПути(ОбрабатываемыйПуть);
				СтруктураДляПроверки.Циклы.Добавить(ОбрабатываемыйПуть);
				
			ИначеЕсли РезультатПродвижения = "ПутьОборван" Тогда
				
				ПоследнийЭлемент = ПоследнийЭлементПути(ОбрабатываемыйПуть);
				СтруктураДляПроверки.ИмяЭлементаОбрыва = ПоследнийЭлемент;
				СтруктураДляПроверки.ПроверкаЗавершена = Истина;
				Прервать;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
			Прервать;
		КонецЕсли;
		
		Если НовыеПутиКОбработке.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		
		ПутиВОбработке = НовыеПутиКОбработке;
		
	КонецЦикла;
	
	Если СтруктураДляПроверки.ЗавершенныеПути.Количество() = 0 Тогда
		СтруктураДляПроверки.НетЗавершенныхПутей = Истина;
		СтруктураДляПроверки.ПроверкаЗавершена = Истина;
	КонецЕсли;
	
КонецПроцедуры

// Продвигается по пути схемы, при определении завершенных путей и возвращает результат
// продвижения.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//  Путь - Массив - массив из имен элементов схемы.
//  НовыеПутиКОбработке - Массив - массив новых путей для обработки.
//
// Возвращаемое значение:
//  Строка - может принимать значения
//   * "УПутиЕстьПродолжение"
//   * "ПутьЗавершен"
//   * "ПутьИмеетЦикл"
//   * "ПутьОборван"
//
Функция ПродвинутьсяПоПутиСхемы(СтруктураДляПроверки, Путь, НовыеПутиКОбработке)
	
	ПоследнийЭлемент = ПоследнийЭлементПути(Путь);
	Последователи = СтруктураДляПроверки.ЭлементыСхемы.Получить(ПоследнийЭлемент).Последователи;
	
	КоличествоПоследователей = Последователи.Количество();
	
	// Если у элемента нет последователей и путь не достиг элемента завершения, то это ошибка.
	Если КоличествоПоследователей = 0 Тогда
		Возврат "ПутьОборван";
	КонецЕсли;
	
	// Обходим всех последователей, кроме последнего.
	Для ИндексПоследователя = 0 По КоличествоПоследователей - 2 Цикл
		
		ЭлементПоследователь = Последователи[ИндексПоследователя];
		
		// Копируем исходный путь.
		НовыйПуть = ОбщегоНазначенияДокументооборотКлиентСервер.ПростаяКопияМассива(Путь);
		
		// Добавляем в новый путь последователя
		НовыйПуть.Добавить(ЭлементПоследователь);
		
		// Выполняем проверку и помещаем путь в соответствующий список структуры для проверки.
		Если ПутьЗавершен(СтруктураДляПроверки, НовыйПуть) Тогда
			СтруктураДляПроверки.ЗавершенныеПути.Добавить(НовыйПуть);
		ИначеЕсли ПутьИмеетЦикл(НовыйПуть) Тогда
			ВыделитьЦиклВПути(НовыйПуть);
			СтруктураДляПроверки.Циклы.Добавить(НовыйПуть);
		Иначе
			НовыеПутиКОбработке.Добавить(НовыйПуть);
		КонецЕсли;
		
	КонецЦикла;
	
	// Поместим последнего последователя в путь.
	ЭлементПоследователь = Последователи[КоличествоПоследователей - 1];
	Путь.Добавить(ЭлементПоследователь);
	
	// Выполняем проверку текущего пути и возвращаем результат.
	Если ПутьЗавершен(СтруктураДляПроверки, Путь) Тогда
		Возврат "ПутьЗавершен";
	ИначеЕсли ПутьИмеетЦикл(Путь) Тогда
		Возврат "ПутьИмеетЦикл";
	Иначе
		Возврат "УПутиЕстьПродолжение";
	КонецЕсли;
	
КонецФункции

// Возвращает последний элемент пути. Путь должен иметь не менее 1го элемента.
//
// Параметры:
//  Путь - Массив - массив из имен элементов схемы.
//
// Возвращаемое значение:
//  Строка
//
Функция ПоследнийЭлементПути(Путь)
	
	Возврат Путь[Путь.Количество() - 1];
	
КонецФункции

// Проверяет путь на предмет достижения элемиента завершения.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//  Путь - Массив - массив из имен элементов схемы.
//
// Возвращаемое значение:
//  Булево
//
Функция ПутьЗавершен(СтруктураДляПроверки, Путь)
	
	Результат = Ложь;
	
	ПоследнийЭлемент = ПоследнийЭлементПути(Путь);
	ТипЭлемента = СтруктураДляПроверки.ЭлементыСхемы.Получить(ПоследнийЭлемент).Тип;
	
	Если ТипЭлемента = Тип("ЭлементГрафическойСхемыЗавершение") Тогда
		Результат = Истина;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Определяет и возвращает признак наличия цикла в пути.
//
// Параметры:
//  Путь - Массив - массив из имен элементов схемы.
//
// Возвращаемое значение:
//  Булево
//
Функция ПутьИмеетЦикл(Путь)
	
	Результат = Ложь;
	
	// Проверяем только последений элемент пути.
	ИндексПоследнегоЭлемента = Путь.Количество() - 1;
	
	ПоследнийЭлемент = Путь[ИндексПоследнегоЭлемента];
	
	ИндексЭлемента = Путь.Найти(ПоследнийЭлемент);
	
	Если ИндексЭлемента <> ИндексПоследнегоЭлемента Тогда
		Результат = Истина;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Удаляет из пути все, что находится до цикла.
// Например, было так: 1-2-3-4-5-3
// Станет так: 3-4-5-3.
//
Процедура ВыделитьЦиклВПути(Путь)
	
	КоличествоЭлементов = Путь.Количество();
	
	// Получаем последнеий элемент пути
	ПоследнийЭлемент = Путь[КоличествоЭлементов - 1];
	
	// Получим индекс следующего элемента с конца.
	ИндексЭлемента = КоличествоЭлементов - 2;
	
	// Обходим путь с конца и удаляем элементы, которые не входят в цикл.
	УдалитьЭлемент = Ложь;
	Пока ИндексЭлемента >=0 Цикл
		
		// Удаляем элемент из массива
		Если УдалитьЭлемент Тогда
			Путь.Удалить(ИндексЭлемента);
			
		// Если текущий элемент равен последнему, то включаем удаление всех предыдущих.
		ИначеЕсли Путь[ИндексЭлемента] = ПоследнийЭлемент Тогда
			УдалитьЭлемент = Истина;
		КонецЕсли;
		
		ИндексЭлемента = ИндексЭлемента - 1;
	КонецЦикла;
	
КонецПроцедуры

// Проверяет зацикливание схемы.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//
Процедура ПроверитьЗацикливаниеСхемы(СтруктураДляПроверки)
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	// Проверим наличие действий и вложенных процессов в циклах.
	// Если в циклах их нет, то прекращаем проверку.
	Для Каждого Путь Из СтруктураДляПроверки.Циклы Цикл
		
		ЕстьЦиклыБезБлоковВыполнения = Истина;
		
		Для Каждого Элемент Из Путь Цикл
			
			ПараметрыЭлементы = СтруктураДляПроверки.ЭлементыСхемы.Получить(Элемент);
			
			Если ПараметрыЭлементы.Тип = Тип("ЭлементГрафическойСхемыОбработка") Тогда
				
				ЕстьЦиклыБезБлоковВыполнения = Ложь;
				
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		Если ЕстьЦиклыБезБлоковВыполнения Тогда
			
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			СтруктураДляПроверки.ЕстьЦиклыБезБлоковВыполнения = Истина;
			
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	// Проверим наличие элементов в которые невозможно попасть.
	Для Каждого Элемент Из СтруктураДляПроверки.ЭлементыСхемы Цикл
		
		ВЭлементНевозможноПопасть = Истина;
		
		// Проверим наличие элемента в циклах
		Для Каждого Путь Из СтруктураДляПроверки.Циклы Цикл
			
			Для Каждого ЭлементПути Из Путь Цикл
				
				Если ЭлементПути = Элемент.Ключ Тогда
					ВЭлементНевозможноПопасть = Ложь;
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
			// Если элемент входит хотябы в один цикл, то прервываем проверку
			// остальных циклов.
			Если Не ВЭлементНевозможноПопасть Тогда
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		// Если элемент входит хотябы в один цикл, то прерываем проверку текущего
		// элемента и переходим к следующему.
		Если Не ВЭлементНевозможноПопасть Тогда
			Продолжить;
		КонецЕсли;
		
		// Проверим наличие элемента в завершенных путях.
		Для Каждого Путь Из СтруктураДляПроверки.ЗавершенныеПути Цикл
			
			Для Каждого ЭлементПути Из Путь Цикл
				
				Если ЭлементПути = Элемент.Ключ Тогда
					ВЭлементНевозможноПопасть = Ложь;
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
			// Если элемент входит хотябы в один путь, то прервываем проверку
			// остальных путей.
			Если Не ВЭлементНевозможноПопасть Тогда
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		// Если элемент не найден ни в одном пути и ни в одном цикле, тогда
		// прекращаем проверку.
		Если ВЭлементНевозможноПопасть Тогда
			СтруктураДляПроверки.ИмяЭлементаВКоторыйНевозможноПопасть = Элемент.Ключ;
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	// Проверим возможность достижения элемента завершения из циклов.
	
	СостоянияЗацикленныхПутей = Неопределено;
	
	// Обойдем все циклы
	Для ИндексЦикла = 0 По СтруктураДляПроверки.Циклы.Количество() - 1 Цикл
		
		ЦиклыВОбработке = Новый Массив;
		
		// Получим состояние текущего цикла.
		СостояниеЦикла = СостояниеЦикла(
			СтруктураДляПроверки, ИндексЦикла, ЦиклыВОбработке, СостоянияЗацикленныхПутей);
		
		Если СостояниеЦикла <> "ИзЦиклаДоступноЗавершение" Тогда
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			
			ПредставлениеЦиклаСтрокой = "";
			ПутьЦикла = СтруктураДляПроверки.Циклы[ИндексЦикла];
			Разделитель = "";
			Для Каждого ЭлементПути Из ПутьЦикла Цикл
				ПредставлениеЦиклаСтрокой = ПредставлениеЦиклаСтрокой
					+ Разделитель
					+ Строка(ЭлементПути);
				Разделитель = " - ";
			КонецЦикла;
			
			СтруктураДляПроверки.ЦиклИзКоторогоНедоступноЗавершение = ПредставлениеЦиклаСтрокой;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Определяет и возвращает состояние цикла.
// Рекурсивная процедура. Рекурсивный вызов из СостояниеЦиклаПоСвязаннымЦиклам.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//  ИндексЦикла - Число - индекс цикла в СтруктураДляПроверкиСхемы.Циклы
//  ЦиклыВОбработке - Массив - массиво циклов, которые находятся в обработке определения состояния.
//  СостоянияЗацикленныхПутей - Соответствие
//    * Ключ - имя пути в схеме.
//    * Значение - Строка - состояние пути, соотвествуюет значению функции СостояниеЦикла
//
// Возвращаемое значение:
//  Строка - возвращается одно из 3х значений:
//   "ЦиклУжеВОбработке", "ИзЦиклаНеДоступноЗавершение", "ИзЦиклаДоступноЗавершение"
//
Функция СостояниеЦикла(СтруктураДляПроверки, ИндексЦикла, ЦиклыВОбработке,
	СостоянияЗацикленныхПутей = Неопределено)
	
	Если СостоянияЗацикленныхПутей = Неопределено Тогда
		СостоянияЗацикленныхПутей = Новый Соответствие;
	КонецЕсли;
	
	СостояниеЦикла = СостоянияЗацикленныхПутей.Получить(ИндексЦикла);
	Если СостояниеЦикла <> Неопределено Тогда
		Возврат СостояниеЦикла;
	КонецЕсли;
	
	Если ЦиклыВОбработке.Найти(ИндексЦикла) <> Неопределено Тогда
		Возврат "ЦиклУжеВОбработке";
	КонецЕсли;
	
	ЦиклыВОбработке.Добавить(ИндексЦикла);
	
	СостояниеЦикла = "ИзЦиклаНеДоступноЗавершение";
	
	ЦиклПути = СтруктураДляПроверки.Циклы[ИндексЦикла];
	
	Для Каждого ЭлементЦикла Из ЦиклПути Цикл
		
		Если ЭлементСодержитсяВЗавершенномПути(СтруктураДляПроверки, ЭлементЦикла) Тогда
			СостояниеЦикла = "ИзЦиклаДоступноЗавершение";
			Прервать;
		КонецЕсли;
		
		СостояниеПоСвязаннымЦиклам = СостояниеЦиклаПоСвязаннымЦиклам(
			СтруктураДляПроверки, ЭлементЦикла, ЦиклыВОбработке, СостоянияЗацикленныхПутей);
		
		Если СостояниеПоСвязаннымЦиклам = "ИзЦиклаДоступноЗавершение" Тогда
			СостояниеЦикла = СостояниеПоСвязаннымЦиклам;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	СостоянияЗацикленныхПутей.Вставить(ИндексЦикла, СостояниеЦикла);
	
	Возврат СостояниеЦикла;
	
КонецФункции

// Возвращает состояние цикла по связанным циклам.
// Вспомогательная функция, используется в СостояниеЦикла.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//  Элемент - Строка - имя элемента цикла.
//  ЦиклыВОбработке - Массив - массив индексов циклов.
//  СостоянияЗацикленныхПутей - Соответствие
//    * Ключ - имя пути в схеме.
//    * Значение - Строка - состояние пути, соотвествуюет значению функции СостояниеЦикла
//
// Возвращаемое значение:
//  Строка - возвращает одно из двух значений: "ИзЦиклаДоступноЗавершение", "ИзЦиклаНеДоступноЗавершение"
//
Функция СостояниеЦиклаПоСвязаннымЦиклам(СтруктураДляПроверки, Элемент, ЦиклыВОбработке, СостоянияЗацикленныхПутей)
	
	Для ИндексЦикла = 0 По СтруктураДляПроверки.Циклы.Количество() - 1 Цикл
		
		ЦиклПути = СтруктураДляПроверки.Циклы[ИндексЦикла];
		
		Если ЦиклПути.Найти(Элемент) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		СостояниеЦикла = СостояниеЦикла(
			СтруктураДляПроверки, ИндексЦикла, ЦиклыВОбработке, СостоянияЗацикленныхПутей);
		
		Если СостояниеЦикла = "ИзЦиклаДоступноЗавершение" Тогда
			Возврат СостояниеЦикла;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат "ИзЦиклаНеДоступноЗавершение";
	
КонецФункции

// Определяет, содержится элемент в завершенных путях.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//  Элемент - Строка - Имя элемента схемы процесса.
//
// Возвращаемое значение:
//  Булево
//
Функция ЭлементСодержитсяВЗавершенномПути(СтруктураДляПроверки, Элемент)
	
	Для Каждого Путь Из СтруктураДляПроверки.ЗавершенныеПути Цикл
		Для Каждого ЭлементПути Из Путь Цикл
			Если ЭлементПути = Элемент Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет корректность разделений и слияний в структуре для проверки.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//
Процедура ПроверитьКорректностьРазделенийИСлияний(СтруктураДляПроверки)
	
	Если СтруктураДляПроверки.ПроверкаЗавершена Тогда
		Возврат;
	КонецЕсли;
	
	Разделения = ОбщегоНазначенияДокументооборотКлиентСервер.ПростаяКопияМассива(
		СтруктураДляПроверки.Разделения);
	
	// Проверим элементы разделений на корректность последователей.
	// Последователи должны быть уникальными.
	Для Каждого Разделение Из Разделения Цикл
		
		ПараметрыРазделения = СтруктураДляПроверки.ЭлементыСхемы.Получить(Разделение);
		
		// Проверим корректность количества последователей.
		Если ПараметрыРазделения.Последователи.Количество() = 1 Тогда
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			СтруктураДляПроверки.РазделениеСОднойИсходящейЛинией = Разделение;
			Возврат;
		КонецЕсли;
		
		// Проверяем, чтобы последователи в текущем разделении были уникальными.
		Для Каждого Последователь1 Из ПараметрыРазделения.Последователи Цикл
			
			КоличествоВхождений = 0;
			Для Каждого Последователь2 Из ПараметрыРазделения.Последователи Цикл
				
				Если Последователь1 = Последователь2 Тогда
					КоличествоВхождений = КоличествоВхождений + 1;
				КонецЕсли;
				
				Если КоличествоВхождений > 1 Тогда
					СтруктураДляПроверки.ПроверкаЗавершена = Истина;
					СтруктураДляПроверки.РазделениеСНесколькимиИсходящимиЛиниямиВОдинЭлемент = Разделение;
					Возврат;
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Проверяем элементы слияний на количество предшественников.
	// Предшественников должно быть более 1го.
	Для Каждого Слияние Из СтруктураДляПроверки.Слияния Цикл
		
		ПараметрыСлияния = СтруктураДляПроверки.ЭлементыСхемы.Получить(Слияние);
		
		Если ПараметрыСлияния.Предшественники.Количество() = 1 Тогда
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			СтруктураДляПроверки.СлияниеСОднойВходящейЛинией = Слияние;
			Возврат;
		КонецЕсли;
		
	КонецЦикла;
	
	// Объединяем завершенные пути и циклы в один массив
	ЗавершенныеПутиИЦиклы = Новый Массив;
	Для Каждого ЗавершенныйПуть Из СтруктураДляПроверки.ЗавершенныеПути Цикл
		ЗавершенныеПутиИЦиклы.Добавить(ЗавершенныйПуть);
	КонецЦикла;
	Для Каждого ЦиклПути Из СтруктураДляПроверки.Циклы Цикл
		ЗавершенныеПутиИЦиклы.Добавить(ЦиклПути);
	КонецЦикла;
	
	Для Каждого Слияние Из СтруктураДляПроверки.Слияния Цикл
		
		СвязанноеРазделение = Неопределено;
		ИндексСвязанногоРазделения = Неопределено;
		МинимальнаяДистанцияДоРазделения = 2147483647;
		
		// Найдем раздление для текущего слияния.
		Для ИндексРазделения = 0 По Разделения.Количество() - 1 Цикл
			
			Разделение = Разделения[ИндексРазделения];
			
			Если Разделение = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			СлияниеИРаздлеоениеВОдномПути = Ложь; // хоть раз попали вместе на один путь
			МаксимальнаяДистанцияДоСлияния = 0;
			СлияниеБезРазделенияВПути = Ложь;
			
			Для Каждого Путь Из ЗавершенныеПутиИЦиклы Цикл
				
				ИндексРазделенияВПути = Путь.Найти(Разделение);
				ИндексСлияния = Путь.Найти(Слияние);
				
				РазделениеВходитВТекущийПуть = (ИндексРазделенияВПути <> Неопределено);
				СлияниеВходитВТекущийПуть = (ИндексСлияния <> Неопределено);
				
				Если Не РазделениеВходитВТекущийПуть И Не СлияниеВходитВТекущийПуть Тогда
					// Пропускаем текущий путь, если в нем нет ни разделения, ни слияния.
					Продолжить;
				ИначеЕсли Не РазделениеВходитВТекущийПуть И СлияниеВходитВТекущийПуть Тогда
					// Останавливаем поиск, когда в пути есть слияние и нет раздлеления.
					// Т.к. это заведом плохой путь.
					СлияниеБезРазделенияВПути = Истина;
					Прервать;
				ИначеЕсли РазделениеВходитВТекущийПуть И СлияниеВходитВТекущийПуть Тогда
					// Если в пути есть и слияние и разделение.
					
					// Если раздление раположено раньше слияния, тогда определяем
					// дистанцию между ними
					Если ИндексРазделенияВПути < ИндексСлияния Тогда
						Дистанция = ИндексСлияния - ИндексРазделенияВПути;
						Если Дистанция > МаксимальнаяДистанцияДоСлияния Тогда
							МаксимальнаяДистанцияДоСлияния = Дистанция;
						КонецЕсли;
						СлияниеИРаздлеоениеВОдномПути = Истина;
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЦикла;
			
			Если СлияниеИРаздлеоениеВОдномПути И Не СлияниеБезРазделенияВПути
				И МаксимальнаяДистанцияДоСлияния < МинимальнаяДистанцияДоРазделения Тогда
				
				МинимальнаяДистанцияДоРазделения = МаксимальнаяДистанцияДоСлияния;
				СвязанноеРазделение = Разделение;
				ИндексСвязанногоРазделения = ИндексРазделения;
			КонецЕсли;
			
		КонецЦикла;
		
		// Если не нашли слияния для разделения
		Если СвязанноеРазделение = Неопределено Тогда
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			СтруктураДляПроверки.СлияниеБезРазделения = Слияние;
			Возврат;
		Иначе
			
			Разделения[ИндексСвязанногоРазделения] = Неопределено;
			
			СегментыПуйтейДляРазделения = Новый Массив;
			
			Для Каждого Путь Из ЗавершенныеПутиИЦиклы Цикл
				
				ИндексРазделенияВПути = Путь.Найти(СвязанноеРазделение);
				ИндексСлияния = Путь.Найти(Слияние);
				
				РазделениеВходитВТекущийПуть = (ИндексРазделенияВПути <> Неопределено);
				СлияниеВходитВТекущийПуть = (ИндексСлияния <> Неопределено);
				
				Если Не РазделениеВходитВТекущийПуть И Не СлияниеВходитВТекущийПуть Тогда
					Продолжить;
				ИначеЕсли Не РазделениеВходитВТекущийПуть И СлияниеВходитВТекущийПуть Тогда
					// ВызватьИсключение Ложь;
					Продолжить;
				ИначеЕсли РазделениеВходитВТекущийПуть И СлияниеВходитВТекущийПуть Тогда
					
					Если ИндексРазделенияВПути >= ИндексСлияния Тогда
						//ВызватьИсключение Ложь;
						Продолжить;
					ИначеЕсли ИндексРазделенияВПути < ИндексСлияния Тогда
						
						СегментПути = Новый Массив;
						Для ИндексЭлементаПути = ИндексРазделенияВПути + 1 По ИндексСлияния - 1 Цикл
							СегментПути.Добавить(Путь[ИндексЭлементаПути]);
						КонецЦикла;
						
						Если СегментПути.Количество() = 0 Тогда
							СтруктураДляПроверки.ПроверкаЗавершена = Истина;
							СтруктураДляПроверки.СлияниеСразуПослеРазделения = Слияние;
							Возврат;
						КонецЕсли;
						
						СегментыПуйтейДляРазделения.Добавить(СегментПути);
						
					КонецЕсли;
					
				ИначеЕсли РазделениеВходитВТекущийПуть И Не СлияниеВходитВТекущийПуть Тогда
					
					СегментПути = Новый Массив;
					// Завершение не включаем
					Для ИндексЭлементаПути = ИндексРазделенияВПути + 1 По Путь.Количество() - 2 Цикл
						СегментПути.Добавить(Путь[ИндексЭлементаПути]);
					КонецЦикла;
					
					СегментыПуйтейДляРазделения.Добавить(СегментПути);
					
				КонецЕсли;
				
			КонецЦикла;
			
			// Теперь проверяем, что ни одна точка из одного сегмента не принадлежит другому.
			ПроблемныйЭлемент = ЭлементВходящийВНесколькоСегментовРазделениеСлияние(
				СтруктураДляПроверки, СегментыПуйтейДляРазделения, СвязанноеРазделение);
				
			Если ПроблемныйЭлемент <> Неопределено Тогда
				СтруктураДляПроверки.ПроверкаЗавершена = Истина;
				СтруктураДляПроверки.ЭлементПересеченияРазделений = ПроблемныйЭлемент;
				Возврат;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	СегментыПуйтейДляРазделения = Новый Массив;
	
	Для ИндексРазделения = 0 По Разделения.Количество() - 1 Цикл
		
		Разделение = Разделения[ИндексРазделения];
		
		Если Разделение = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого Путь Из ЗавершенныеПутиИЦиклы Цикл
			
			ИндексРазделенияВПути = Путь.Найти(Разделение);
			РазделениеВходитВТекущийПуть = (ИндексРазделенияВПути <> Неопределено);
			
			Если Не РазделениеВходитВТекущийПуть Тогда
				Продолжить;
			КонецЕсли;
			
			СегментПути = Новый Массив;
			
			// Элемент Завершение не включаем.
			Для ИндексЭлементаПути = ИндексРазделенияВПути + 1 По Путь.Количество() - 2 Цикл
				
				ЭлементПути = Путь[ИндексЭлементаПути];
				ПараметрыЭлемента = СтруктураДляПроверки.ЭлементыСхемы.Получить(ЭлементПути);
				
				Если ПараметрыЭлемента.Тип = Тип("ЭлементГрафическойСхемыСлияние") Тогда
					Прервать;
				КонецЕсли;
				
				СегментПути.Добавить(ЭлементПути);
			КонецЦикла;
			
			СегментыПуйтейДляРазделения.Добавить(СегментПути);
			
		КонецЦикла;
		
		// Теперь проверяем, что ни одна точка из одного сегмента не принадлежит другому.
		ПроблемныйЭлемент = ЭлементВходящийВНесколькоСегментовРазделениеСлияние(
			СтруктураДляПроверки, СегментыПуйтейДляРазделения, Разделение);
			
		Если ПроблемныйЭлемент <> Неопределено Тогда
			СтруктураДляПроверки.ПроверкаЗавершена = Истина;
			СтруктураДляПроверки.ЭлементПересеченияРазделений = ПроблемныйЭлемент;
			Возврат;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Ищет элемент, входящий в несколько сегментов Разделение-Слияние.
// В качестве результата, возвращает его имя.
//
// Параметры:
//  СтруктураДляПроверки - Структура - см. СтруктураДляПроверкиСхемы
//  СегментыРазделениеСлияние - Массив - массив последотельностей (массивов) элементов между разделением и слиянием.
//  Разделение - Строка - имя разделения, с которого начинается последовательность.
//
// Возвращаемое значение:
//  Строка, Неопределено - имя элемента входящего в 2 параллельных сегмента.
//
Функция ЭлементВходящийВНесколькоСегментовРазделениеСлияние(
	СтруктураДляПроверки, СегментыРазделениеСлияние, Разделение)
	
	ЭлементыИСегменты = Новый Соответствие;
	НачалаСегментов = Новый Соответствие;
	
	ОбработанныеСегменты = Новый Соответствие;
	
	Для ИндексСегмента = 0 По СегментыРазделениеСлияние.Количество() - 1 Цикл
		
		СегментРазделения = СегментыРазделениеСлияние[ИндексСегмента];
		
		ХешСегмента = Новый ХешированиеДанных(ХешФункция.MD5);
		ХешСегмента.Добавить(СтрСоединить(СегментРазделения, "-"));
		ХешСуммаСегмента = ХешСегмента.ХешСумма;
		
		Если ОбработанныеСегменты[ХешСуммаСегмента] = Истина Тогда
			Продолжить;
		КонецЕсли;
		ОбработанныеСегменты[ХешСуммаСегмента] = Истина;
		
		Для ИндексЭлемента = 0 По СегментРазделения.Количество() - 1 Цикл
			
			ЭлементСегмента = СегментРазделения[ИндексЭлемента];
			
			Если ЭлементыИСегменты[ЭлементСегмента] = Неопределено Тогда
				ЭлементыИСегменты[ЭлементСегмента] = Новый Соответствие;
			КонецЕсли;
			ЭлементыИСегменты[ЭлементСегмента][ИндексСегмента] = Истина;
			
			Если ИндексЭлемента = 0 Тогда
				Если НачалаСегментов[ЭлементСегмента] = Неопределено Тогда
					НачалаСегментов[ЭлементСегмента] = Новый Соответствие;
				КонецЕсли;
				НачалаСегментов[ЭлементСегмента][ИндексСегмента] = Истина;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	ПоследователиРазделения = СтруктураДляПроверки.ЭлементыСхемы[Разделение].Последователи;
	
	Для Каждого ПоследовательРазделения Из ПоследователиРазделения Цикл
		
		СегментыСПоследователемВНачале = НачалаСегментов[ПоследовательРазделения];
		
		Для Каждого СегментСПоследователемВНачале Из СегментыСПоследователемВНачале Цикл
			
			ИндексСегментаСПоследователемВНачале = СегментСПоследователемВНачале.Ключ;
			
			Для Каждого ЭлементСегмента Из СегментыРазделениеСлияние[ИндексСегментаСПоследователемВНачале] Цикл
				
				СегментыВКоторыеВходитЭлемент = ЭлементыИСегменты[ЭлементСегмента];
				
				Для Каждого СегментЭлемента Из СегментыВКоторыеВходитЭлемент Цикл
					
					Если СегментыСПоследователемВНачале[СегментЭлемента.Ключ] = Истина Тогда
						Продолжить;
					КонецЕсли;
					
					Возврат ЭлементСегмента;
					
				КонецЦикла;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецФункции


#КонецОбласти

#Область РаботаСДаннымиСхемы

// Добавляет последователей элемента схемы в путь.
// Процедура рекурсивная. Используется в функции ПутиСхемыПроцесса.
//
// Параметры:
//  ВсеПути - массив - все возможные пути.
//   * Массив - каждый путь это массив имен элементов схемы.
//  ИндексТекущегоПути - Число - индекс пути текущего элемента.
//  Предшественники - ТаблицаЗначений
//    * Имя - Строка
//    * ИмяПредшественника - Строка
//  ЭлементСхемы - Строка - имя элемента схемы, последователи которого добавляются в путь.
//
Процедура ДобавитьПоследователейЭлементаСхемыВПуть(
	ВсеПути, ИндексТекущегоПути, Предшественники, ЭлементСхемы)
	
	// Определяем по индексу текущий путь.
	ТекущийПуть = ВсеПути[ИндексТекущегоПути];
	
	// Добавляем элемент в путь.
	ТекущийПуть.Добавить(ЭлементСхемы);
	
	// Находим последователей элемента схемы.
	Отбор = Новый Структура;
	Отбор.Вставить("ИмяПредшественника", ЭлементСхемы);
	Последователи = Предшественники.НайтиСтроки(Отбор);
	КоличествоПоследователей = Последователи.Количество();
	
	// Если нет, то выходим из процедуры - текущий путь сформирован.
	Если КоличествоПоследователей = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ИндексПоследователя = КоличествоПоследователей - 1;
	
	// Создаем новые пути для каждого, кроме первого, последователя
	// и добавляем них соответствующих последователей.
	Пока ИндексПоследователя > 0 Цикл
		
		ПоследовательЭлементаСхемы = Последователи[ИндексПоследователя].Имя;
		
		ИндексПоследователя = ИндексПоследователя - 1;
		
		Если ТекущийПуть.Найти(ПоследовательЭлементаСхемы) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		НовыйПуть = ОбщегоНазначенияДокументооборотКлиентСервер.ПростаяКопияМассива(ТекущийПуть);
		ВсеПути.Добавить(НовыйПуть);
		
		ИндексНовогоПути = ВсеПути.Количество() - 1;
		
		ДобавитьПоследователейЭлементаСхемыВПуть(
			ВсеПути, ИндексНовогоПути, Предшественники, ПоследовательЭлементаСхемы);
	КонецЦикла;
	
	// Первого последователя добавляем в текущий путь.
	ПоследовательЭлементаСхемы = Последователи[0].Имя;
	Если ТекущийПуть.Найти(ПоследовательЭлементаСхемы) = Неопределено Тогда
		ДобавитьПоследователейЭлементаСхемыВПуть(
			ВсеПути, ИндексТекущегоПути, Предшественники, ПоследовательЭлементаСхемы);
	КонецЕсли;
	
КонецПроцедуры

Функция  НаименованиеЭлемента(ЭлементСхемы)

	НаименованиеЭлемента = СтрПолучитьСтроку(ЭлементСхемы.Наименование, 1);
	Если Не ЗначениеЗаполнено(НаименованиеЭлемента) Тогда
		НаименованиеЭлемента = ЭлементСхемы.Имя;
	КонецЕсли;	
	
	Возврат НаименованиеЭлемента;

КонецФункции

#КонецОбласти

#КонецОбласти