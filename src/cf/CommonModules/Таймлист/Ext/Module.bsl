#Область ПрограммныйИнтерфейс

// Возвращает признак использования сервиса в программе
//
// Возвращаемое значение:
//  Булево - Истина, если сервис используется в программе.
//
Функция ТаймлистИспользуется() Экспорт
	
	Возврат ПолучитьФункциональнуюОпцию("ИспользуетсяРаспознаваниеТаймлист");
	
КонецФункции

// Записывает логин и пароль доступа сервиса в информационную базу
//
// Параметры:
//  ДанныеАвторизации - Структура Из КлючИЗначение:
//   * Логин - Строка
//   * Пароль - Строка
//
Процедура ЗаписатьДанныеАвторизации(ДанныеАвторизации) Экспорт
	
	Константы.ТаймлистДанныеАвторизации.Установить(Новый ХранилищеЗначения(ДанныеАвторизации));
	
КонецПроцедуры

// Получает логин и пароль доступа к сервису Таймлист
//
// Возвращаемое значение:
//  Структура:
//   * Логин - Строка
//   * Пароль - Строка
//
Функция ДанныеАвторизацииВСервисе() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат Константы.ТаймлистДанныеАвторизации.Получить().Получить();
	
КонецФункции

// Выполняет проверку подключения к сервису Таймлист по указанным логину и паролю.
//
// Параметры:
//  Логин - Строка
//  Пароль - Строка
//
// Возвращаемое значение:
//  Булево - Истина, если подключение было успешно установлено
//
Функция СервисПоДаннымАвторизацииПодключен(Логин, Пароль) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	АдресСервера = Константы.ТаймлистАдресСервиса.Получить();
	ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL;
	Соединение = Новый HTTPСоединение(АдресСервера,,,,,, ЗащищенноеСоединение);
	
	СтрокаЗапроса = СтрШаблон("login?phone=%1&password=%2", Логин, Пароль);
	
	HTTPЗапрос = Новый HTTPЗапрос(СтрокаЗапроса);
	
	ОтветСервиса = Соединение.Получить(HTTPЗапрос);
	
	Если ОтветСервиса.КодСостояния = 200 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Обработчик регламентного задания ТаймлистОбработкаЗаданий.
// 
Процедура ОбработатьЗадания() Экспорт
	
	Отказ = Ложь;
	РегламентноеЗадание = Метаданные.РегламентныеЗадания.ТаймлистОбработкаЗаданий;
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(РегламентноеЗадание, Отказ);
	
	Если ПолучитьФункциональнуюОпцию("ИспользоватьКОД")
		И Не КОДСервер.ЭтоЦентральныйУзел() Тогда
		
		Текст = НСтр("ru = 'Это регламентное задание может выполняться только в центральном узле.'");
		РегламентныеЗаданияСервер.ОтменитьВыполнениеЗадания(РегламентноеЗадание, Текст);
		ВызватьИсключение Текст;
		
	КонецЕсли;
	
	Если Отказ = Истина Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	ТаймлистФайлыВОбработке.ВерсияФайла,
		|	ТаймлистФайлыВОбработке.Задание,
		|	ТаймлистФайлыВОбработке.Параметры,
		|	ЕСТЬNULL(ТаймлистОшибкиРаботыССервисом.КоличествоПопыток, 0) КАК КоличествоПопыток
		|ИЗ
		|	РегистрСведений.ТаймлистФайлыВОбработке КАК ТаймлистФайлыВОбработке
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ТаймлистОшибкиРаботыССервисом КАК ТаймлистОшибкиРаботыССервисом
		|		ПО ТаймлистОшибкиРаботыССервисом.ВерсияФайла = ТаймлистФайлыВОбработке.ВерсияФайла";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если Выборка.КоличествоПопыток > 3 Тогда
			Продолжить;
		КонецЕсли;
		
		ПараметрыИзХранилищаЗначения = Выборка.Параметры.Получить();
		ВыполнитьЗадание(Выборка.ВерсияФайла, Выборка.Задание, ПараметрыИзХранилищаЗначения);
	КонецЦикла;
	
КонецПроцедуры

// Помещает файл в очередь обработки.
// 
// Параметры:
//  ВерсияФайла - СправочникСсылка.ВерсииФайлов - обрабатываемая версия файла.
//  Задание - ПеречислениеСсылка.ТаймлистТипыЗаданий - выполняемое задание.
//  Параметры - Структура - параметры выполнения задания.
// 
Процедура ПоместитьФайлВОчередьОбработки(ВерсияФайла, Задание, Параметры = Неопределено) Экспорт
	
	РегистрыСведений.ТаймлистФайлыВОбработке.Добавить(ВерсияФайла, Задание, Параметры);
	
КонецПроцедуры

// Возвращает данные работы сервиса с указанным файлом.
// 
// Параметры:
//  ВерсияФайла - СправочникСсылка.ВерсииФайлов - обрабатываемая версия файла.
//  Поля - Строка - список полей через разделитель ",". Если не указаны, то берутся все поля.
//
// Возвращаемое значение:
//  Структура - см. РегистрСведений.ТаймлистДанныеРаботыСервиса.ОписаниеДанных
// 
Функция ДанныеРаботыСервиса(ВерсияФайла, Поля = "") Экспорт
	
	Возврат РегистрыСведений.ТаймлистДанныеРаботыСервиса.Данные(ВерсияФайла, Поля);
	
КонецФункции

// Удаляет данные работы сервиса по переданной версии файла, а также выполняет очистку в самом сервисе.
// 
// Параметры:
//  ВерсияФайла - СправочникСсылка.ВерсииФайлов - обрабатываемый файл.
//  ИдентификаторЗадания - Строка
// 
Процедура УдалитьДанныеФайла(ВерсияФайла, ИдентификаторЗадания = "") Экспорт
	
	Если ЗначениеЗаполнено(ИдентификаторЗадания) Тогда
		ВыполнитьУдалениеЗаданияВСервисе(ИдентификаторЗадания);
	Иначе
		ИдентификаторЗадания = ДанныеРаботыСервиса(ВерсияФайла, "ИдентификаторЗадания").ИдентификаторЗадания;
		Если ИдентификаторЗадания <> Неопределено Тогда
			ВыполнитьУдалениеЗаданияВСервисе(ИдентификаторЗадания);
		КонецЕсли;
	КонецЕсли;
	
	РегистрыСведений.ТаймлистДанныеРаботыСервиса.Удалить(ВерсияФайла);
	РегистрыСведений.ТаймлистФайлыВОбработке.Удалить(ВерсияФайла);
	РегистрыСведений.ТаймлистОшибкиРаботыССервисом.Удалить(ВерсияФайла);
	
КонецПроцедуры

#Область ДляВызоваИзДругихПодсистем

// Определяет следующие свойств регламентных заданий:
//  - зависимость от функциональных опций.
//  - возможность выполнения в различных режимах работы программы.
//  - прочие параметры.
//
// Параметры:
//  Настройки - ТаблицаЗначений - таблица значений с колонками:
//    * РегламентноеЗадание - ОбъектМетаданных:РегламентноеЗадание - регламентное задание.
//    * ФункциональнаяОпция - ОбъектМетаданных:ФункциональнаяОпция - функциональная опция,
//        от которой зависит регламентное задание.
//    * ЗависимостьПоИ      - Булево - если регламентное задание зависит более, чем
//        от одной функциональной опции и его необходимо включать только тогда,
//        когда все функциональные опции включены, то следует указывать Истина
//        для каждой зависимости.
//        По умолчанию Ложь - если хотя бы одна функциональная опция включена,
//        то регламентное задание тоже включено.
//    * ВключатьПриВключенииФункциональнойОпции - Булево, Неопределено - если Ложь, то при
//        включении функциональной опции регламентное задание не будет включаться. Значение
//        Неопределено соответствует значению Истина.
//        По умолчанию - неопределено.
//    * ДоступноВПодчиненномУзлеРИБ - Булево, Неопределено - Истина или Неопределено, если регламентное
//        задание доступно в РИБ.
//        По умолчанию - неопределено.
//    * ДоступноВПодчиненномУзлеКОД - Булево, Неопределено - Истина или Неопределено, если регламентное
//        задание доступно в подчиненном узле КОД.
//        По умолчанию - неопределено.
//    * ДоступноВАвтономномРабочемМесте - Булево, Неопределено - Истина или Неопределено, если регламентное
//        задание доступно в автономном рабочем месте.
//        По умолчанию - неопределено.
//    * ДоступноВМоделиСервиса      - Булево, Неопределено - Истина или Неопределено, если регламентное
//        задание доступно в модели сервиса.
//        По умолчанию - неопределено.
//    * РаботаетСВнешнимиРесурсами  - Булево - Истина, если регламентное задание модифицирует данные
//        во внешних источниках (получение почты, синхронизация данных и т.п.). Не следует устанавливать
//        значение Истина, для регламентных заданий, не модифицирующих данные во внешних источниках.
//        Например, регламентное задание ЗагрузкаКурсовВалют. По умолчанию - Ложь.
//    * Параметризуется             - Булево - Истина, если регламентное задание параметризованное.
//        По умолчанию - Ложь.
//
// Например:
//	Настройка = Настройки.Добавить();
//	Настройка.РегламентноеЗадание = Метаданные.РегламентныеЗадания.ОбновлениеСтатусовДоставкиSMS;
//	Настройка.ФункциональнаяОпция = Метаданные.ФункциональныеОпции.ИспользоватьПочтовыйКлиент;
//	Настройка.ДоступноВМоделиСервиса = Ложь;
//
Процедура ПриОпределенииНастроекРегламентныхЗаданий(Настройки) Экспорт
	
	Настройка = Настройки.Добавить();
	Настройка.РегламентноеЗадание = Метаданные.РегламентныеЗадания.ТаймлистОбработкаЗаданий;
	Настройка.ФункциональнаяОпция = Метаданные.ФункциональныеОпции.ИспользуетсяРаспознаваниеТаймлист;
	Настройка.РаботаетСВнешнимиРесурсами = Истина;
	Настройка.ДоступноВПодчиненномУзлеКОД = Ложь;
	Настройка.ДоступноВМоделиСервиса = Ложь;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область МетодыРаботыССервисом

// Выполняет задание с файлом.
// 
// Параметры:
//  ВерсияФайла - СправочникСсылка.ВерсииФайлов - обрабатываемый файл.
//  Задание - ПеречислениеСсылка.ТаймлистТипыЗаданий - выполняемое задание.
//  Параметры - Структура - параметры выполнения задания.
// 
Процедура ВыполнитьЗадание(ВерсияФайла, Задание, Параметры = Неопределено)
	
	Если Не ТаймлистИспользуется() Тогда
		Возврат;
	КонецЕсли;
	
	ОшибкаПроверкиТокена = ТокенПроверен();
	Если ЗначениеЗаполнено(ОшибкаПроверкиТокена) Тогда
		РегистрыСведений.ТаймлистОшибкиРаботыССервисом.Добавить(ВерсияФайла, ОшибкаПроверкиТокена);
		Возврат;
	КонецЕсли;
	
	ДанныеРаботыСервиса = ДанныеРаботыСервиса(ВерсияФайла);
	
	Если Задание = Перечисления.ТаймлистТипыЗаданий.ЗагрузитьФайлВСервис Тогда
		
		Если Не ЗначениеЗаполнено(ДанныеРаботыСервиса.Статус) Тогда
			
			ПараметрыЗагрузкиФайла = ПараметрыЗагрузкиФайлаВСервис(ВерсияФайла);
			Если ПараметрыЗагрузкиФайла <> Неопределено Тогда
				ЗагрузитьФайлВСервис(ВерсияФайла, ПараметрыЗагрузкиФайла);
			КонецЕсли;
			
		ИначеЕсли ДанныеРаботыСервиса.Статус = Перечисления.ТаймлистСтатусы.ОтправленНаЗагрузку Тогда
			
			ПроверитьЗагрузкуФайлаВСервис(ВерсияФайла, ДанныеРаботыСервиса.ИдентификаторЗадания);
			
		КонецЕсли;
		
	ИначеЕсли Задание = Перечисления.ТаймлистТипыЗаданий.НачатьРасшифровку Тогда
		
		НачатьРасшифровку(ВерсияФайла, ДанныеРаботыСервиса.ИдентификаторЗадания, Параметры);
		
	ИначеЕсли Задание = Перечисления.ТаймлистТипыЗаданий.ПроверитьРасшифровку Тогда
		
		ПроверитьРасшифровку(ВерсияФайла, ДанныеРаботыСервиса.ИдентификаторЗадания);
		
	ИначеЕсли Задание = Перечисления.ТаймлистТипыЗаданий.ПодготовитьДанныеКПолучениюАвтопротокола Тогда
		
		Если Параметры = Неопределено Или Не Параметры.Свойство("СпикерыДляАвтопротокола") Тогда
			ОписаниеОшибки = НСтр("ru = 'Отсутствуют данные спикеров для формирования автопротокола.'");
			РегистрыСведений.ТаймлистОшибкиРаботыССервисом.Добавить(ВерсияФайла, ОписаниеОшибки);
			Возврат;
		КонецЕсли;
		
		ПодготовитьДанныеКПолучениюАвтопротокола(ВерсияФайла, ДанныеРаботыСервиса.ИдентификаторЗадания,
			Параметры.СпикерыДляАвтопротокола);
		
		Если Параметры.СпикерыДляАвтопротокола.Количество() = 0 Тогда
			ЗаменитьСпикеровВРасшифровке(ВерсияФайла, ДанныеРаботыСервиса.Расшифровка);
		КонецЕсли;
		
	ИначеЕсли Задание = Перечисления.ТаймлистТипыЗаданий.ПолучитьАвтопротокол Тогда
		
		НачатьФормированиеАвтопротокола(ВерсияФайла, ДанныеРаботыСервиса.ИдентификаторЗадания);
		
	ИначеЕсли Задание = Перечисления.ТаймлистТипыЗаданий.ПроверитьАвтопротокол Тогда
		
		ПроверитьАвтопротокол(ВерсияФайла, ДанныеРаботыСервиса.ИдентификаторАвтопротокола);
		
	КонецЕсли;
	
КонецПроцедуры

// Выполняет загрузку файла в сервис.
//
// Параметры:
//  ВерсияФайла - СправочникСсылка.ВерсииФайлов
//  ПараметрыЗагрузкиФайла - Структура:
//   * ИмяФайла - Строка
//   * ИмяФайлаСПутем - Строка
// 
Процедура ЗагрузитьФайлВСервис(ВерсияФайла, ПараметрыЗагрузкиФайла)
	
	ДанныеТокена = ТаймлистПовтИсп.ДанныеТокена();
	
	ПодключениеAPI = Новый Структура;
	ПодключениеAPI.Вставить("Заголовки", Новый Соответствие);
	ПодключениеAPI.Вставить("Хост", Константы.ТаймлистАдресСервиса.Получить());
	ПодключениеAPI.Вставить("Данные", Новый Массив);
	
	ВебЗапрос = Новый HTTPЗапрос("/UploadUserFiles/", ПодключениеAPI.Заголовки);
	
	Разделитель = Прав(Формат(ТекущаяУниверсальнаяДатаВМиллисекундах(), "ЧЦ=16; ЧВН=; ЧГ=0"), 8)
		+ Формат(ТекущаяУниверсальнаяДатаВМиллисекундах(), "ЧЦ=16; ЧВН=; ЧГ=0");
	
	Тело = Новый ПотокВПамяти();
	ИмяПараметра = "files";
	ЗаписьДанных = Новый ЗаписьДанных(Тело);
	ЗаписьДанных.ЗаписатьСтроку("----------------------------" + Разделитель);
	ЗаписьДанных.ЗаписатьСтроку("Content-Disposition: form-data; name="""
		+ ИмяПараметра + """; filename=""" + ПараметрыЗагрузкиФайла.ИмяФайла + """");
	ЗаписьДанных.ЗаписатьСтроку("Content-Type: audio/mpeg");
	ЗаписьДанных.ЗаписатьСтроку("");
	ДвоичныеДанные = Новый ДвоичныеДанные(ПараметрыЗагрузкиФайла.ИмяФайлаСПутем);
	ЗаписьДанных.Записать(ДвоичныеДанные);
	ЗаписьДанных.ЗаписатьСтроку("");
	ИмяПараметра = "files";
	ЗаписьДанных.ЗаписатьСтроку("----------------------------" + Разделитель + "--");
	ЗаписьДанных.Закрыть();
	
	ДвоичныеДанные = Тело.ЗакрытьИПолучитьДвоичныеДанные();
	
	ПодключениеAPI.Заголовки.Вставить("Content-Type", "multipart/form-data; boundary=--------------------------"
		+ Разделитель);
	ПодключениеAPI.Заголовки.Вставить("Accept", "*/*");
	ПодключениеAPI.Заголовки.Вставить("Accept-Encoding", "gzip, deflate, br");
	
	ПодключениеAPI.Заголовки.Вставить("authorization", ДанныеТокена.Токен);
	
	Соединение = Новый HTTPСоединение(ПодключениеAPI.Хост,,,,, 3600, Новый ЗащищенноеСоединениеOpenSSL);
	ВебЗапрос.УстановитьТелоИзДвоичныхДанных(ДвоичныеДанные);
	
	Ответ = Соединение.ВызватьHTTPМетод("POST", ВебЗапрос);
	ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
	
	ИдентификаторЗаданияРаспознавания = "";
	
	Если Ответ.КодСостояния = 200 Тогда
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТелоОтвета);
		РезультатОтвета = ПрочитатьJSON(
			ЧтениеJSON, Истина, ?(ПодключениеAPI.Свойство("ПоляДата"), ПодключениеAPI.ПоляДата, ""));
		
		Для Каждого Соответствие Из РезультатОтвета[0] Цикл
			
			Если Соответствие.Ключ = "orderId" И ЗначениеЗаполнено(Соответствие.Значение) Тогда
				
				ИдентификаторЗаданияРаспознавания = Соответствие.Значение;
				РегистрыСведений.ТаймлистДанныеРаботыСервиса.ЗаписатьНачалоЗагрузкиФайлаВСервис(
					ВерсияФайла, ИдентификаторЗаданияРаспознавания);
				Возврат;
			КонецЕсли;
			
			Если Соответствие.Ключ = "error" И ЗначениеЗаполнено(Соответствие.Значение) Тогда
				
				ОписаниеОшибки = Соответствие.Значение;
				РегистрыСведений.ТаймлистОшибкиРаботыССервисом.Добавить(ВерсияФайла, ОписаниеОшибки);
				Возврат;
				
			КонецЕсли;
			
		КонецЦикла;
		
		ЧтениеJSON.Закрыть();
		
	Иначе
		
		ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Код ответа сервера - %1. %2'"), Строка(Ответ.КодСостояния), ТелоОтвета);
		РегистрыСведений.ТаймлистОшибкиРаботыССервисом.Добавить(ВерсияФайла, ОписаниеОшибки);
		
	КонецЕсли;
	
КонецПроцедуры

// Проверить загрузка файла в сервис.
// 
// Параметры:
//  ВерсияФайла - СправочникСсылка.ВерсииФайлов
//  ИдентификаторФайлаВСервисе - Строка
// 
Процедура ПроверитьЗагрузкуФайлаВСервис(ВерсияФайла, ИдентификаторФайлаВСервисе)
	
	ДанныеТокена = ТаймлистПовтИсп.ДанныеТокена();
	
	Статус = "UNKNOWN";
	АдресСервера = Константы.ТаймлистАдресСервиса.Получить();
	АдресРесурса = "orderStatus?orderId=" + ИдентификаторФайлаВСервисе;
	
	ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL;
	Соединение = Новый HTTPСоединение(АдресСервера, 443,,,,, ЗащищенноеСоединение);
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("User-Agent", "PostmanRuntime/7.36.0");
	Заголовки.Вставить("Accept", "*/*");
	Заголовки.Вставить("Accept-Encoding", "gzip, deflate, br");
	Заголовки.Вставить("Connection", "keep-alive");
	Заголовки.Вставить("authorization", ДанныеТокена.Токен);
	
	Запрос = Новый HTTPЗапрос(АдресРесурса, Заголовки);
	Ответ = Соединение.Получить(Запрос);
	ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
	
	Если Ответ.КодСостояния = 200 Тогда
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТелоОтвета);
		
		МассивДанных = ПрочитатьJSON(ЧтениеJSON, Истина);
		
		Для Каждого Элемент Из МассивДанных Цикл
			
			Если Элемент.Ключ = "lastCheckStatus" Тогда
				
				Статус = Элемент.Значение;
				
			ИначеЕсли Статус = "UPLOADED" И Элемент.Ключ = "file" Тогда
				
				ПараметрыРасшифровки = Новый Структура("ИмяФайла", Элемент.Значение);
				
				РегистрыСведений.ТаймлистДанныеРаботыСервиса.ЗаписатьСтатусРаботыССервисом(ВерсияФайла,
					Перечисления.ТаймлистСтатусы.Загружен);
				ПоместитьФайлВОчередьОбработки(ВерсияФайла, Перечисления.ТаймлистТипыЗаданий.НачатьРасшифровку,
					ПараметрыРасшифровки);
				
				Возврат;
				
			КонецЕсли;
			
		КонецЦикла;
		
	Иначе
		
		ОписаниеОшибки = СтрШаблон(НСтр("ru = 'Код ответа сервера - %1. %2'"),
			Строка(Ответ.КодСостояния), ТелоОтвета);
		РегистрыСведений.ТаймлистОшибкиРаботыССервисом.Добавить(ВерсияФайла, ОписаниеОшибки);
		
	КонецЕсли;
	
КонецПроцедуры

// Отправляет запрос в сервис на запуск формирования расшифровки.
// 
// Параметры:
//  ВерсияФайла - СправочникСсылка.ВерсииФайлов
//  ИдентификаторФайлаВСервисе - Строка
//  Параметры - Структура:
//   * КоличествоСпикеров - Число
//   * ИмяФайла - Строка
// 
Процедура НачатьРасшифровку(ВерсияФайла, ИдентификаторФайлаВСервисе, Параметры)
	
	ДанныеТокена = ТаймлистПовтИсп.ДанныеТокена();
	
	АдресСервера = Константы.ТаймлистАдресСервиса.Получить();
	
	АдресРесурса = "translateFile?orderId=" + ИдентификаторФайлаВСервисе
		+ "&speakers=" + Строка(Параметры.КоличествоСпикеров) + "&filename=" + Параметры.ИмяФайла;
	
	ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL;
	Соединение = Новый HTTPСоединение(АдресСервера, 443,,,,, ЗащищенноеСоединение);
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("User-Agent", "PostmanRuntime/7.36.0");
	Заголовки.Вставить("Accept", "*/*");
	Заголовки.Вставить("Accept-Encoding", "gzip, deflate, br");
	Заголовки.Вставить("Connection", "keep-alive");
	
	Заголовки.Вставить("authorization", ДанныеТокена.Токен);
	
	Запрос = Новый HTTPЗапрос(АдресРесурса, Заголовки);
	Ответ = Соединение.Получить(Запрос);
	ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
	
	Если Ответ.КодСостояния = 200 Тогда
		
		РегистрыСведений.ТаймлистДанныеРаботыСервиса.ЗаписатьСтатусРаботыССервисом(ВерсияФайла,
			Перечисления.ТаймлистСтатусы.ПолучениеРасшифровки);
		ПоместитьФайлВОчередьОбработки(ВерсияФайла, Перечисления.ТаймлистТипыЗаданий.ПроверитьРасшифровку);
	
	Иначе
		
		ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Код ответа сервера - %1. %2'"), Строка(Ответ.КодСостояния), ТелоОтвета);
		РегистрыСведений.ТаймлистОшибкиРаботыССервисом.Добавить(ВерсияФайла, ОписаниеОшибки);
		
	КонецЕсли;
	
КонецПроцедуры

// Проверяет статус расшифровки файла. После успешного выполнения записывает расшифровку в базу данных.
//
// Параметры:
//  ВерсияФайла - СправочникСсылка.ВерсииФайлов
//  ИдентификаторФайлаВСервисе - Строка - идентификатор задания распознавания в сервисе.
// 
Процедура ПроверитьРасшифровку(ВерсияФайла, ИдентификаторФайлаВСервисе)
	
	ДанныеТокена = ТаймлистПовтИсп.ДанныеТокена();
	
	Статус = "UNKNOWN";
	АдресСервера = Константы.ТаймлистАдресСервиса.Получить();
	АдресРесурса = "orderStatus?orderId=" + ИдентификаторФайлаВСервисе;
	
	ЗащищенноеСоединение = новый ЗащищенноеСоединениеOpenSSL;
	Соединение = Новый HTTPСоединение(АдресСервера, 443,,,,, ЗащищенноеСоединение);
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("User-Agent", "PostmanRuntime/7.36.0");
	Заголовки.Вставить("Accept", "*/*");
	Заголовки.Вставить("Accept-Encoding", "gzip, deflate, br");
	Заголовки.Вставить("Connection", "keep-alive");
	Заголовки.Вставить("authorization", ДанныеТокена.Токен);
	
	Запрос = Новый HTTPЗапрос(АдресРесурса, Заголовки);
	Ответ = Соединение.Получить(Запрос);
	ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
	
	Если Ответ.КодСостояния = 200 Тогда
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТелоОтвета);
		
		МассивДанных = ПрочитатьJSON(ЧтениеJSON, Истина);
		ЗначениеСоответствияОтветаСТаймКодами = МассивДанных.Получить("time_code");
		ЗначениеСоответствияОтветаСпикеры = МассивДанных.Получить("speakersData");
		
		Для Каждого Элемент Из МассивДанных Цикл
			
			Если Элемент.Ключ = "lastCheckStatus" Тогда
				
				Статус = Элемент.Значение;
				
			ИначеЕсли Статус = "SUCCESS" И Элемент.Ключ = "lastCheckAnswer" Тогда
				
				РасшифровкаHTMLХранилище = СформироватьРасшифровку(ЗначениеСоответствияОтветаСТаймКодами);
				СпикерыХранилище = СформироватьХранилищеСпикеров(ЗначениеСоответствияОтветаСпикеры);
				
				РегистрыСведений.ТаймлистДанныеРаботыСервиса.ЗаписатьРасшифровкуИСпикеров(ВерсияФайла,
					РасшифровкаHTMLХранилище, СпикерыХранилище);
				РегистрыСведений.ТаймлистФайлыВОбработке.Удалить(ВерсияФайла);
				
				Возврат;
				
			КонецЕсли;
			
		КонецЦикла;
		
	Иначе
		
		ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Код ответа сервера - %1. %2'"), Строка(Ответ.КодСостояния), ТелоОтвета);
		РегистрыСведений.ТаймлистОшибкиРаботыССервисом.Добавить(ВерсияФайла, ОписаниеОшибки);
		
	КонецЕсли;
	
КонецПроцедуры

// Отправляет запрос в сервис на переименование спикеров и назначение им ролей.После успешной операции
// выполняет подстановку новых имен спикеров в текущую расшифровку. 
// 
// Параметры:
//  ВерсияФайла - СправочникСсылка.ВерсииФайлов
//  ИдентификаторФайлаВСервисе - Строка
//  Спикеры - ХранилищеЗначения
//  СпикерыДляАвтопротокола - Массив Из Структура:
//   * initialName - Строка
//   * newName - Строка
//   * role - Строка
// 
Процедура ПодготовитьДанныеКПолучениюАвтопротокола(ВерсияФайла, ИдентификаторФайлаВСервисе,
	СпикерыДляАвтопротокола)
	
	ОписаниеОшибки = "";
	
	Пока СпикерыДляАвтопротокола.Количество() > 0 Цикл
		
		Если СпикерыДляАвтопротокола[0].role = "true" Тогда
			
			ОписаниеОшибки = УстановитьГлавнуюРольСпикеру(СпикерыДляАвтопротокола[0].initialName,
				ВерсияФайла, ИдентификаторФайлаВСервисе);
			
			Если ЗначениеЗаполнено(ОписаниеОшибки) Тогда
				Прервать;
			КонецЕсли;
			
		КонецЕсли;
		
		Если СпикерыДляАвтопротокола[0].initialName <> СпикерыДляАвтопротокола[0].newName Тогда
			
			ОписаниеОшибки = УстановитьНовоеИмяСпикера(
				СпикерыДляАвтопротокола[0].initialName, СпикерыДляАвтопротокола[0].newName,
					ВерсияФайла, ИдентификаторФайлаВСервисе);
			
			Если ЗначениеЗаполнено(ОписаниеОшибки) Тогда
				Прервать;
			КонецЕсли;
			
		КонецЕсли;
		
		СпикерыДляАвтопротокола.Удалить(0);
		
	КонецЦикла;
	
	Если ЗначениеЗаполнено(ОписаниеОшибки) Тогда
		РегистрыСведений.ТаймлистОшибкиРаботыССервисом.Добавить(ВерсияФайла, ОписаниеОшибки);
		ПоместитьФайлВОчередьОбработки(ВерсияФайла, Перечисления.ТаймлистТипыЗаданий.ПодготовитьДанныеКПолучениюАвтопротокола,
			Новый Структура("СпикерыДляАвтопротокола", СпикерыДляАвтопротокола));
	КонецЕсли;
	
КонецПроцедуры

// Отправляет запрос в сервис на запуск формирования расшифровки.
// 
// Параметры:
//  ВерсияФайла - СправочникСсылка.ВерсииФайлов
//  ИдентификаторФайлаВСервисе - Строка
// 
Процедура НачатьФормированиеАвтопротокола(ВерсияФайла, ИдентификаторФайлаВСервисе)
	
	АдресСервера = Константы.ТаймлистАдресСервиса.Получить();
	АдресРесурса = "generateProtocol?orderId=" + ИдентификаторФайлаВСервисе;
	
	ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL;
	Соединение = Новый HTTPСоединение(АдресСервера, 443,,,,, ЗащищенноеСоединение);
	Заголовки = Новый Соответствие;
	
	ДанныеТокена = ТаймлистПовтИсп.ДанныеТокена();
	
	Заголовки.Вставить("User-Agent", "PostmanRuntime/7.36.0");
	Заголовки.Вставить("Accept", "*/*");
	Заголовки.Вставить("Accept-Encoding", "gzip, deflate, br");
	Заголовки.Вставить("Connection", "keep-alive");
	Заголовки.Вставить("authorization", ДанныеТокена.Токен);

	Запрос = Новый HTTPЗапрос(АдресРесурса, Заголовки);
	Ответ = Соединение.Получить(Запрос);
	
	Если Ответ.КодСостояния = 200 Тогда
		
		ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТелоОтвета);
		
		МассивДанных = ПрочитатьJSON(ЧтениеJSON, Истина);
		ИдентификаторАвтопротокола = МассивДанных.Получить("protocolQueryId");
		
		РегистрыСведений.ТаймлистДанныеРаботыСервиса.ЗаписатьНачалоФормированияАвтопротокола(ВерсияФайла,
			ИдентификаторАвтопротокола);
		ПоместитьФайлВОчередьОбработки(ВерсияФайла, Перечисления.ТаймлистТипыЗаданий.ПроверитьАвтопротокол);
		
	Иначе
		
		ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Код ответа сервера - %1. %2'"), Строка(Ответ.КодСостояния), ТелоОтвета);
		РегистрыСведений.ТаймлистОшибкиРаботыССервисом.Добавить(ВерсияФайла, ОписаниеОшибки);
		
	КонецЕсли;
	
КонецПроцедуры

// Проверяет статус формирования автопротокола. После успешного выполнения записывает автопротокол в базу данных.
//
// Параметры:
//  ВерсияФайла - СправочникСсылка.ВерсииФайлов
//  ИдентификаторАвтопротокола - Строка - идентификатор задания распознавания в сервисе.
// 
Процедура ПроверитьАвтопротокол(ВерсияФайла, ИдентификаторАвтопротокола)
	
	АдресСервера = Константы.ТаймлистАдресСервиса.Получить();
	АдресРесурса = "protocolStatus?protocolQueryId=" + ИдентификаторАвтопротокола;
	
	ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL;
	Соединение = Новый HTTPСоединение(АдресСервера, 443,,,,, ЗащищенноеСоединение);
	Заголовки = Новый Соответствие;
	
	ДанныеТокена = ТаймлистПовтИсп.ДанныеТокена();
	
	Заголовки.Вставить("User-Agent", "PostmanRuntime/7.36.0");
	Заголовки.Вставить("Accept", "*/*");
	Заголовки.Вставить("Accept-Encoding", "gzip, deflate, br");
	Заголовки.Вставить("Connection", "keep-alive");
	Заголовки.Вставить("authorization", ДанныеТокена.Токен);
	
	Запрос = Новый HTTPЗапрос(АдресРесурса, Заголовки);
	Ответ = Соединение.Получить(Запрос);
	ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
	
	Если Ответ.КодСостояния = 200 Тогда
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТелоОтвета);
		
		МассивДанных = ПрочитатьJSON(ЧтениеJSON, Истина);
		
		ЗначениеСоответствияПротокола = МассивДанных.Получить("protocolAnswer");
		ЗначениеСоответствияСтатусаПротокола = МассивДанных.Получить("status");
		
		Если ЗначениеСоответствияСтатусаПротокола = "SUCCESS" Тогда
			
			ДанныеАвтопротокола = СформироватьАвтопротокол(ЗначениеСоответствияПротокола);
			РегистрыСведений.ТаймлистДанныеРаботыСервиса.ЗаписатьАвтопротокол(ВерсияФайла, ДанныеАвтопротокола);
			РегистрыСведений.ТаймлистФайлыВОбработке.Удалить(ВерсияФайла);
			
		КонецЕсли;
		
	Иначе
		
		ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Код ответа сервера - %1. %2'"), Строка(Ответ.КодСостояния), ТелоОтвета);
		РегистрыСведений.ТаймлистОшибкиРаботыССервисом.Добавить(ВерсияФайла, ОписаниеОшибки);
		
	КонецЕсли;
	
КонецПроцедуры

// Выполняет удаление задания и связанных данных в сервисе.
//
// Параметры:
//  ИдентификаторЗадания - Строка - идентификатор задания распознавания в сервисе.
// 
Процедура ВыполнитьУдалениеЗаданияВСервисе(ИдентификаторЗадания)
	
	АдресСервера = Константы.ТаймлистАдресСервиса.Получить();
	АдресРесурса = "deleteorder?orderId=" + ИдентификаторЗадания;
	
	ОписаниеОшибкиПроверкиТокена = ТокенПроверен();
	Если ЗначениеЗаполнено(ОписаниеОшибкиПроверкиТокена) Тогда
		ВызватьИсключение ОписаниеОшибкиПроверкиТокена;
	КонецЕсли;
	
	ДанныеТокена = ТаймлистПовтИсп.ДанныеТокена();
	
	ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL;
	Соединение = Новый HTTPСоединение(АдресСервера, 443,,,,, ЗащищенноеСоединение);
	Заголовки = Новый Соответствие;
	
	Заголовки.Вставить("User-Agent", "PostmanRuntime/7.36.0");
	Заголовки.Вставить("Accept", "*/*");
	Заголовки.Вставить("Accept-Encoding", "gzip, deflate, br");
	Заголовки.Вставить("Connection", "keep-alive");
	Заголовки.Вставить("authorization", ДанныеТокена.Токен);
	
	Запрос = Новый HTTPЗапрос(АдресРесурса, Заголовки);
	
	Ответ = Соединение.ВызватьHTTPМетод("DELETE", Запрос);
	ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
	
	Если Ответ.КодСостояния <> 200 Тогда
		ВызватьИсключение СтрШаблон(НСтр("ru = 'Код ответа сервера - %1. %2'"), Строка(Ответ.КодСостояния), ТелоОтвета);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

Функция ТокенПроверен()
	
	ОписаниеОшибки = "";
	
	ДанныеТокена = ТаймлистПовтИсп.ДанныеТокена();
	Если ДанныеТокена = Неопределено Или ТекущаяДатаСеанса() > (ДанныеТокена.ВремяПолучения + 86400) Тогда
		
		РезультатОбновленияТокена = ОбновитьТокен();
		ДанныеТокена = ТаймлистПовтИсп.ДанныеТокена();
		Если Не РезультатОбновленияТокена.ТокенПолучен Тогда
			ОписаниеОшибки = РезультатОбновленияТокена.ТекстОшибки;
		КонецЕсли;
		
	КонецЕсли;
	
	Если ДанныеТокена = Неопределено Тогда
		ОписаниеОшибки = НСтр("ru = 'Ошибка получения токена.'");
	КонецЕсли;
	
	Возврат ОписаниеОшибки;
	
КонецФункции

Функция ОбновитьТокен()
	
	Результат = Новый Структура("ТокенПолучен, ТекстОшибки", Ложь, "");
	
	ДанныеАвторизации = Константы.ТаймлистДанныеАвторизации.Получить().Получить();
	
	Если Не ЗначениеЗаполнено(ДанныеАвторизации) Тогда
		Возврат Результат;
	КонецЕсли;
	
	АдресСервера = Константы.ТаймлистАдресСервиса.Получить();
	АдресРесурса = "login?phone=" + ДанныеАвторизации.Логин + "&password=" + ДанныеАвторизации.Пароль;
	
	Если ЗначениеЗаполнено(ДанныеАвторизации) Тогда
		
		ЗащищенноеСоединение = новый ЗащищенноеСоединениеOpenSSL;
		Соединение = Новый HTTPСоединение(АдресСервера, 443,,,,, ЗащищенноеСоединение);
		Заголовки = Новый Соответствие;
		
		Заголовки.Вставить("User-Agent", "PostmanRuntime/7.36.0");
		Заголовки.Вставить("Accept", "*/*");
		Заголовки.Вставить("Accept-Encoding", "gzip, deflate, br");
		Заголовки.Вставить("Connection", "keep-alive");
		
		Запрос = Новый HTTPЗапрос(АдресРесурса, Заголовки);
		
		Ответ = Соединение.Получить(Запрос);
			
			Если Ответ.КодСостояния = 200 Тогда
				
				ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
				
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(ТелоОтвета);
				
				МассивДанных = ПрочитатьJSON(ЧтениеJSON, Истина);
				
				ДанныеТокена = ОписаниеДанныхТокена();
				
				ДанныеТокена.Токен = МассивДанных.Получить("tocken");
				ДанныеТокена.ВремяПолучения = ТекущаяДатаСеанса();
				ДанныеТокена.Минут = МассивДанных.Получить("minutes");
				ДанныеТокена.ИмяЗарегистрироованногоПользователя = МассивДанных.Получить("i");
				ДанныеТокена.Идентификатор = МассивДанных.Получить("_id");
				ДанныеТокена.ВремяСозданияАккаунта = МассивДанных.Получить("createdAt");
				ДанныеТокена.ВремяИзмененияАккаунта = МассивДанных.Получить("updatedAt");
				ДанныеТокена.АктивностьАккаунта = МассивДанных.Получить("Actived");
				ДанныеТокена.ПользовательСАдминистративнымиПравами = МассивДанных.Получить("Admin");
				ДанныеТокена.ЭлектроннаяПочта = МассивДанных.Получить("email");
				ДанныеТокена.Баланс = МассивДанных.Получить("balance");
				ДанныеТокена.Страна = МассивДанных.Получить("country");
				ДанныеТокена.Телефон = МассивДанных.Получить("phone");
				
				ЗаписатьТокен(ДанныеТокена);
				
				Результат.ТокенПолучен = Истина;
				
				
			Иначе
				
				Результат.ТекстОшибки = СтрШаблон(
					НСтр("ru = 'Код ответа сервера - %1. Ошибка %2'"), Строка(Ответ.КодСостояния), ТелоОтвета);
				
			КонецЕсли;
		
	Иначе
		
		Результат.ТекстОшибки = НСтр("ru = 'Заполните логин и пароль.'");
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ОписаниеДанныхТокена()
	
	НовыйОписаниеДанныхТокена = Новый Структура;
	
	НовыйОписаниеДанныхТокена.Вставить("Токен");
	НовыйОписаниеДанныхТокена.Вставить("ВремяПолучения");
	НовыйОписаниеДанныхТокена.Вставить("Минут");
	НовыйОписаниеДанныхТокена.Вставить("ИмяЗарегистрироованногоПользователя");
	НовыйОписаниеДанныхТокена.Вставить("Идентификатор");
	НовыйОписаниеДанныхТокена.Вставить("ВремяСозданияАккаунта");
	НовыйОписаниеДанныхТокена.Вставить("ВремяИзмененияАккаунта");
	НовыйОписаниеДанныхТокена.Вставить("АктивностьАккаунта");
	НовыйОписаниеДанныхТокена.Вставить("ПользовательСАдминистративнымиПравами");
	НовыйОписаниеДанныхТокена.Вставить("ЭлектроннаяПочта");
	НовыйОписаниеДанныхТокена.Вставить("Баланс");
	НовыйОписаниеДанныхТокена.Вставить("Страна");
	НовыйОписаниеДанныхТокена.Вставить("Телефон");
	
	Возврат НовыйОписаниеДанныхТокена;
	
КонецФункции

Процедура ЗаписатьТокен(ДанныеТокена)
	
	Константы.ТаймлистТокен.Установить(Новый ХранилищеЗначения(ДанныеТокена));
	ОбновитьПовторноИспользуемыеЗначения();
	
КонецПроцедуры

Функция ПараметрыЗагрузкиФайлаВСервис(ВерсияФайла)
	
	УстановитьПривилегированныйРежим(Истина);
	
	ДанныеЗагрузкиФайла = Новый Структура("ИмяФайла, ИмяФайлаСПутем", "", "");
	
	РеквизитыВерсииСтрока = "ТипХраненияФайла, Расширение, Том, ПутьКФайлу, Владелец.ЯзыкРаспознавания";
	РеквизитыВерсии = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ВерсияФайла, РеквизитыВерсииСтрока);
	
	Попытка
		ДанныеЗагрузкиФайла = ВременныйФайлДляРаспознавания(
			ВерсияФайла,
			РеквизитыВерсии.ТипХраненияФайла,
			РеквизитыВерсии.Расширение,
			РеквизитыВерсии.Том,
			РеквизитыВерсии.ПутьКФайлу);
	Исключение
		ОписаниеОшибки =
			НСтр("ru = 'Не удалось получить данные файла для распознавания.
			|Убедитесь, что файл не поврежден и повторите попытку.'");
		РегистрыСведений.ТаймлистОшибкиРаботыССервисом.Добавить(ВерсияФайла, ОписаниеОшибки);
		Возврат Неопределено;
	КонецПопытки;
	
	Возврат ДанныеЗагрузкиФайла;
	
КонецФункции

Функция ВременныйФайлДляРаспознавания(ВерсияФайла, ТипХранения, Расширение, Том, ПутьКФайлу)
	
	ИмяФайла = ИмяВременногоФайла(ВерсияФайла, Расширение);
	
	ИмяФайлаСПутем = КаталогВременныхФайлов() + ИмяФайла;
	
	Если ТипХранения = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
		
		ХранилищеФайла = РаботаСФайламиВызовСервера.ПолучитьХранилищеФайлаИзИнформационнойБазы(ВерсияФайла);
		ДвоичныеДанныеФайла = ХранилищеФайла.Получить();
		
		ДвоичныеДанныеФайла.Записать(ИмяФайлаСПутем);
		
	Иначе
		
		Если Не Том.Пустая() Тогда
			ИмяФайлаСПутемВТоме = ФайловыеФункции.ПолныйПутьТома(Том) + ПутьКФайлу; 
			КопироватьФайл(ИмяФайлаСПутемВТоме, ИмяФайлаСПутем);
			Файл = Новый Файл(ИмяФайлаСПутем);
			Файл.УстановитьТолькоЧтение(Ложь);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Новый Структура("ИмяФайла, ИмяФайлаСПутем", ИмяФайла, ИмяФайлаСПутем);
	
КонецФункции

Функция ИмяВременногоФайла(ВерсияФайла, Расширение)
	
	Возврат СтрШаблон("%1.%2", ВерсияФайла.УникальныйИдентификатор(), Расширение);
	
КонецФункции

Функция СформироватьРасшифровку(ОтветСервисаРасшифровка)
	
	Расшифровка = "";
	
	ЧтениеJSONРасшифровка = Новый ЧтениеJSON;
	ЧтениеJSONРасшифровка.УстановитьСтроку(ОтветСервисаРасшифровка);
	МассивДанныхРасшифровки = ПрочитатьJSON(ЧтениеJSONРасшифровка, Истина);
	ЧастьСоСпикером = Истина;
	
	ТаблицаРасшифровки = НоваяТаблицаРасшифровки();
	
	Для Каждого Элемент Из МассивДанныхРасшифровки Цикл
		
		Строка = ТаблицаРасшифровки.Добавить();
		Строка.Время = ВремяПоСекундам(Элемент[0]);
		
		ЧастьСоСпикером = Лев(Элемент[1], 7) = "СПИКЕР_";
		
		Если ЧастьСоСпикером  Тогда
			
			КонецСпикера = СтрНайти(Элемент[1], ": ", НаправлениеПоиска.СНачала, 1, 1);
			
			СпикерЧасть = Лев(Элемент[1], КонецСпикера + 1);
			Строка.ЧастьРасшифровки = СтрЗаменить(Элемент[1], СпикерЧасть, "");
			
			Строка.Спикер = Лев(СпикерЧасть, КонецСпикера - 1);
			Строка.НачалоСпикера = Истина;
			
		Иначе
			
			Строка.ЧастьРасшифровки = Элемент[1];
			Строка.Спикер = СпикерЧасть;
			Строка.НачалоСпикера = Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого Строка Из ТаблицаРасшифровки Цикл
		
		Если Строка.НачалоСпикера И Строка.НомерСтроки = 1 Тогда 
			
			Расшифровка = Расшифровка + Строка.Спикер + " (" + Строка.Время + "): "
				+ Строка.ЧастьРасшифровки;
			
		ИначеЕсли Строка.НачалоСпикера И Строка.НомерСтроки > 1 Тогда
			
			Расшифровка = Расшифровка + Символы.ВК + Символы.ПС + Символы.ВК + Символы.ПС + Строка.Спикер
				+ " (" + Строка.Время + "): " + Строка.ЧастьРасшифровки;
			
		Иначе
			
			Расшифровка = Расшифровка + Строка.ЧастьРасшифровки;
			
		КонецЕсли;
		
	КонецЦикла;
	
	РасшифровкаHTML = ШапкаРасшифровкиHTML();
	
	СодержаниеРасшифровкиHTML = "";
	
	Для Каждого СтрокаРасшифровки Из ТаблицаРасшифровки Цикл
		
		СодержаниеРасшифровкиHTML = СодержаниеРасшифровкиHTML
			+ ?(СтрокаРасшифровки.НачалоСпикера, "</p><p><b><u>" + СтрокаРасшифровки.Спикер
				+ "</u> (" + СтрокаРасшифровки.Время + "): </b>" + СтрокаРасшифровки.ЧастьРасшифровки,
		СтрокаРасшифровки.ЧастьРасшифровки);
		
	КонецЦикла;
	
	РасшифровкаHTML = СтрЗаменить(РасшифровкаHTML, "TimelistRecognizeResult", СодержаниеРасшифровкиHTML);
	
	Возврат Новый ХранилищеЗначения(РасшифровкаHTML);
	
КонецФункции

Функция СформироватьАвтопротокол(ОтветСервисаАвтопротокол)
	
	Автопротокол = "";
	
	ЧтениеJSONАвтопротокол = Новый ЧтениеJSON;
	ЧтениеJSONАвтопротокол.УстановитьСтроку(ОтветСервисаАвтопротокол);
	МассивДанныхАвтопротокола = ПрочитатьJSON(ЧтениеJSONАвтопротокол, Истина);
	МассивЧастейАвтопротокола = Новый Массив;
	МассивПунктовАвтопротокола = Новый Массив;
	
	Для Каждого ЭлементДанныхАвтопротокола Из МассивДанныхАвтопротокола Цикл
		
		ЭтоНачалоПунктовПротокола = Ложь;
		
		Для Каждого Элемент Из ЭлементДанныхАвтопротокола Цикл
			
			МассивЧастейАвтопротокола.Добавить(Элемент);
			
			Если ЭтоНачалоПунктовПротокола = Истина И СтрНачинаетсяС(Элемент, "-") Тогда
				МассивПунктовАвтопротокола.Добавить(Сред(Элемент, 3, СтрДлина(Элемент) - 3));
			КонецЕсли;
			
			Если Элемент = "***Следующие шаги ***" Тогда
				ЭтоНачалоПунктовПротокола = Истина;
			КонецЕсли;
			
		КонецЦикла;
		
		Для Каждого Элемент Из МассивЧастейАвтопротокола Цикл
			
			Автопротокол = Автопротокол + "→ " + Элемент + Символы.ПС;
			
		КонецЦикла;
		
	КонецЦикла;
	
	АвтоПротоколHTML = ШапкаАвтопротоколаHTML();
	Вставка = "";
	
	Для Каждого СтрокаАвтопротокола Из МассивЧастейАвтопротокола Цикл
		
		Если СтрокаАвтопротокола = "***Следующие шаги ***" Тогда
			Вставка = Вставка + "<p><b>" + СтрокаАвтопротокола
				+ НСтр("ru = '(данные этого раздела используются для заполнения протокола мероприятия и пунктов исполнения)'")
				+ "</b></p>";
			
		Иначе
			
			Вставка = Вставка + "<p>" + СтрокаАвтопротокола + "</p>";
			
		КонецЕсли;
		
	КонецЦикла;
	
	АвтоПротоколHTML = СтрЗаменить(АвтоПротоколHTML, "TimelistAutoprotocol", Вставка);
	АвтопротоколХранилище = Новый ХранилищеЗначения(АвтоПротоколHTML);
	
	СледующиеШаги = СтрСоединить(МассивПунктовАвтопротокола, ";");
	
	ДанныеАвтопротокола = Новый Структура("Автопротокол, СледующиеШаги", АвтопротоколХранилище, СледующиеШаги);
	
	Возврат ДанныеАвтопротокола;
	
КонецФункции

Функция НоваяТаблицаРасшифровки()
	
	ТаблицаРасшифровки = Новый ТаблицаЗначений();
	ТаблицаРасшифровки.Колонки.Добавить("НомерСтроки", ОбщегоНазначения.ОписаниеТипаЧисло(2,,
		ДопустимыйЗнак.Неотрицательный));
	ТаблицаРасшифровки.Колонки.Добавить("Время", ОбщегоНазначения.ОписаниеТипаСтрока(8));
	ТаблицаРасшифровки.Колонки.Добавить("Спикер", ОбщегоНазначения.ОписаниеТипаСтрока(9));
	ТаблицаРасшифровки.Колонки.Добавить("ЧастьРасшифровки", ОбщегоНазначения.ОписаниеТипаСтрока(0));
	ТаблицаРасшифровки.Колонки.Добавить("НачалоСпикера", Новый ОписаниеТипов("Булево"));
	
	Возврат ТаблицаРасшифровки;
	
КонецФункции

Функция ВремяПоСекундам(КоличествоСекунд)
	
	Если КоличествоСекунд = 0  Тогда
		Возврат "00:00:00";
	Иначе
		Дата = Дата(1,1,1) + КоличествоСекунд;
		Возврат Формат(Дата, "ДФ=HH:mm:ss");
	КонецЕсли;
	
КонецФункции

Функция ШапкаРасшифровкиHTML()
	
	ДокументHTML = Новый ДокументHTML;
	
	ЭлементТело = ДокументHTML.СоздатьЭлемент("body");
	ДокументHTML.Тело = ЭлементТело;
	
	ЭлементБлок = ДокументHTML.СоздатьЭлемент("p");
	ЭлементТело.ДобавитьДочерний(ЭлементБлок);
	
	ЭлементТекст = ДокументHTML.СоздатьТекстовыйУзел("TimelistGetAutoprotocol");
	ЭлементБлок.ДобавитьДочерний(ЭлементТекст);
	
	ЭлементБлок = ДокументHTML.СоздатьЭлемент("p");
	ЭлементТело.ДобавитьДочерний(ЭлементБлок);
	
	ЭлементТекст = ДокументHTML.СоздатьТекстовыйУзел("TimelistRecognizeResult");
	ЭлементБлок.ДобавитьДочерний(ЭлементТекст);
	
	ЗаписьDOM = Новый ЗаписьDOM;
	ЗаписьHTML = Новый ЗаписьHTML;
	ЗаписьHTML.УстановитьСтроку();
	ЗаписьDOM.Записать(ДокументHTML, ЗаписьHTML);
	РасшифровкаHTML = ЗаписьHTML.Закрыть();
	
	Возврат РасшифровкаHTML;
	
КонецФункции

Функция ШапкаАвтопротоколаHTML()
	
	ДокументHTML = Новый ДокументHTML;
	
	ЭлементТело = ДокументHTML.СоздатьЭлемент("body");
	ДокументHTML.Тело = ЭлементТело;
	
	ЭлементБлок = ДокументHTML.СоздатьЭлемент("p");
	ЭлементТело.ДобавитьДочерний(ЭлементБлок);
	
	ЭлементТекст = ДокументHTML.СоздатьТекстовыйУзел("TimelistAutoprotocol");
	ЭлементБлок.ДобавитьДочерний(ЭлементТекст);
	
	ЗаписьDOM = Новый ЗаписьDOM;
	ЗаписьHTML = Новый ЗаписьHTML;
	ЗаписьHTML.УстановитьСтроку();
	ЗаписьDOM.Записать(ДокументHTML, ЗаписьHTML);
	АвтопротоколHTML = ЗаписьHTML.Закрыть();
	
	Возврат АвтопротоколHTML;
	
КонецФункции

Функция СформироватьХранилищеСпикеров(ОтветСервисаСпикеры)
	
	ЧтениеJSONСпикеры = Новый ЧтениеJSON;
	ЧтениеJSONСпикеры.УстановитьСтроку(ОтветСервисаСпикеры);
	
	МассивДанныхСпикеров = ПрочитатьJSON(ЧтениеJSONСпикеры, Истина);
	
	ТаблицаСпикеров = НоваяТаблицаСпикеров();
	
	Для Каждого Элемент Из МассивДанныхСпикеров Цикл
		
		Строка = ТаблицаСпикеров.Добавить();
		Строка.initialName = Элемент.Получить("initialName");
		Строка.name = Элемент.Получить("name");
		Строка.role = Элемент.Получить("role");
		
	КонецЦикла;
	
	Возврат Новый ХранилищеЗначения(ТаблицаСпикеров);
	
КонецФункции

Функция НоваяТаблицаСпикеров()
	
	ТаблицаСпикеров = Новый ТаблицаЗначений;
	ТаблицаСпикеров.Колонки.Добавить("initialName", ОбщегоНазначения.ОписаниеТипаСтрока(0));
	ТаблицаСпикеров.Колонки.Добавить("name", ОбщегоНазначения.ОписаниеТипаСтрока(0));
	ТаблицаСпикеров.Колонки.Добавить("role", ОбщегоНазначения.ОписаниеТипаСтрока(0));
	
	Возврат ТаблицаСпикеров;
	
КонецФункции

Функция УстановитьГлавнуюРольСпикеру(ИмяСпикера, ВерсияФайла, ИдентификаторФайлаВСервисе)
	
	ОписаниеОшибки = "";
	
	АдресСервера = Константы.ТаймлистАдресСервиса.Получить();
	АдресРесурса = "changeSpeakerRole";
	
	Разделитель = СтрЗаменить(Новый УникальныйИдентификатор(), "-", "");
	Тело = Новый ПотокВПамяти;
	ЗаписьДанных = Новый ЗаписьДанных(Тело,,,Символы.ВК + Символы.ПС,"");
	
	ЗаписьДанных.ЗаписатьСтроку("----------------------------" + Разделитель);
	ЗаписьДанных.ЗаписатьСтроку("Content-Disposition: form-data; name=""orderId"""
		+ Символы.ВК + Символы.ПС + Символы.ВК + Символы.ПС + ИдентификаторФайлаВСервисе);
	ЗаписьДанных.ЗаписатьСтроку("----------------------------" + Разделитель);
	ЗаписьДанных.ЗаписатьСтроку("Content-Disposition: form-data; name=""initialName"""
		+ Символы.ВК + Символы.ПС + Символы.ВК + Символы.ПС + ИмяСпикера);
	ЗаписьДанных.ЗаписатьСтроку("----------------------------" + Разделитель);
	ЗаписьДанных.ЗаписатьСтроку("Content-Disposition: form-data; name=""role"""
		+ Символы.ВК + Символы.ПС + Символы.ВК + Символы.ПС + "LEAD");
	ЗаписьДанных.ЗаписатьСтроку("----------------------------" + Разделитель + "--");
	ЗаписьДанных.Закрыть();
	
	ДанныеТела = Тело.ЗакрытьИПолучитьДвоичныеДанные();
	
	ЗащищенноеСоединение = новый ЗащищенноеСоединениеOpenSSL;
	Соединение = Новый HTTPСоединение(АдресСервера, 443,,,,, ЗащищенноеСоединение);
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("User-Agent", "PostmanRuntime/7.36.0");
	Заголовки.Вставить("Accept", "*/*");
	Заголовки.Вставить("Accept-Encoding", "gzip, deflate, br");
	Заголовки.Вставить("Connection", "keep-alive");
	Заголовки.Вставить("Content-Type", "multipart/form-data; boundary=--------------------------" + Разделитель);
	
	ДанныеТокена = ТаймлистПовтИсп.ДанныеТокена();
	Заголовки.Вставить("authorization", ДанныеТокена.Токен);
	
	Запрос = Новый HTTPЗапрос(АдресРесурса, Заголовки);
	Запрос.УстановитьТелоИзДвоичныхДанных(ДанныеТела);
	Ответ = Соединение.ВызватьHTTPМетод("PUT", Запрос);
	
	Если Ответ.КодСостояния = 200 Тогда
		
		ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТелоОтвета);
		МассивДанных = ПрочитатьJSON(ЧтениеJSON, Истина);
		ЗначениеСоответствияОтветаСпикеры = МассивДанных.Получить("speakersData");
		СпикерыХранилище = СформироватьХранилищеСпикеров(ЗначениеСоответствияОтветаСпикеры);
		
		РегистрыСведений.ТаймлистДанныеРаботыСервиса.ЗаписатьСпикеров(ВерсияФайла, СпикерыХранилище);
		
	Иначе
		
		ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Код ответа сервера - %1. %2'"), Строка(Ответ.КодСостояния), ТелоОтвета);
		
	КонецЕсли;
	
	Возврат ОписаниеОшибки;
	
КонецФункции

Функция УстановитьНовоеИмяСпикера(ТекущееИмя, НовоеИмя, ВерсияФайла, ИдентификаторФайлаВСервисе)
	
	ОписаниеОшибки = "";
	
	АдресСервера = Константы.ТаймлистАдресСервиса.Получить();
	АдресРесурса = "changeSpeakerName";
	
	Разделитель = СтрЗаменить(Новый УникальныйИдентификатор(), "-", "");
	
	Тело = Новый ПотокВПамяти;
	
	ЗаписьДанных = Новый ЗаписьДанных(Тело,,,Символы.ВК + Символы.ПС,"");
	
	ЗаписьДанных.ЗаписатьСтроку("----------------------------" + Разделитель);
	ЗаписьДанных.ЗаписатьСтроку("Content-Disposition: form-data; name=""orderId"""
		+ Символы.ВК + Символы.ПС + Символы.ВК + Символы.ПС + ИдентификаторФайлаВСервисе);
	ЗаписьДанных.ЗаписатьСтроку("----------------------------" + Разделитель);
	ЗаписьДанных.ЗаписатьСтроку("Content-Disposition: form-data; name=""initialName"""
		+ Символы.ВК + Символы.ПС + Символы.ВК + Символы.ПС + ТекущееИмя);
	ЗаписьДанных.ЗаписатьСтроку("----------------------------" + Разделитель);
	ЗаписьДанных.ЗаписатьСтроку("Content-Disposition: form-data; name=""newName"""
		+ Символы.ВК + Символы.ПС + Символы.ВК + Символы.ПС + НовоеИмя);
	ЗаписьДанных.ЗаписатьСтроку("----------------------------" + Разделитель + "--");
	ЗаписьДанных.Закрыть();
	
	ДанныеТела = Тело.ЗакрытьИПолучитьДвоичныеДанные();
	
	ЗащищенноеСоединение = новый ЗащищенноеСоединениеOpenSSL;
	
	Соединение = Новый HTTPСоединение(АдресСервера, 443,,,,, ЗащищенноеСоединение);
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("User-Agent", "PostmanRuntime/7.36.0");
	Заголовки.Вставить("Accept", "*/*");
	Заголовки.Вставить("Accept-Encoding", "gzip, deflate, br");
	Заголовки.Вставить("Connection", "keep-alive");
	Заголовки.Вставить("Content-Type", "multipart/form-data; boundary=--------------------------" + Разделитель);
	
	ДанныеТокена = ТаймлистПовтИсп.ДанныеТокена();
	
	Заголовки.Вставить("authorization", ДанныеТокена.Токен);

	Запрос = Новый HTTPЗапрос(АдресРесурса, Заголовки);
	Запрос.УстановитьТелоИзДвоичныхДанных(ДанныеТела);
	Ответ = Соединение.ВызватьHTTPМетод("PUT", Запрос);
	
	Если Ответ.КодСостояния = 200 Тогда 
		
		ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТелоОтвета);
		МассивДанных = ПрочитатьJSON(ЧтениеJSON, Истина);
		ЗначениеСоответствияОтветаСпикеры = МассивДанных.Получить("speakersData");
		СпикерыХранилище = СформироватьХранилищеСпикеров(ЗначениеСоответствияОтветаСпикеры);
		
		РегистрыСведений.ТаймлистДанныеРаботыСервиса.ЗаписатьСпикеров(ВерсияФайла, СпикерыХранилище);
		
	Иначе
		
		ОписаниеОшибки = СтрШаблон(
			НСтр("ru = 'Код ответа сервера - %1. %2'"), Строка(Ответ.КодСостояния), ТелоОтвета);
		
	КонецЕсли;
	
	Возврат ОписаниеОшибки;
	
КонецФункции

Процедура ЗаменитьСпикеровВРасшифровке(ВерсияФайла, РасшифровкаХранилище)
	
	НовыеСпикерыХранилище = РегистрыСведений.ТаймлистДанныеРаботыСервиса.Данные(ВерсияФайла, "Спикеры").Спикеры;
	
	СпикерыТаблица = НовыеСпикерыХранилище.Получить();
	РасшифровкаHTML = РасшифровкаХранилище.Получить();
	
	Для Каждого Строка Из СпикерыТаблица Цикл
		РасшифровкаHTML = СтрЗаменить(РасшифровкаHTML, Строка.initialName, Строка.name);
	КонецЦикла;
	
	РасшифровкаХранилище = Новый ХранилищеЗначения(РасшифровкаHTML);
	
	РегистрыСведений.ТаймлистДанныеРаботыСервиса.ЗаписатьРасшифровку(ВерсияФайла, РасшифровкаХранилище,
		Перечисления.ТаймлистСтатусы.АвтопротоколГотовКПолучению);
	ПоместитьФайлВОчередьОбработки(ВерсияФайла, Перечисления.ТаймлистТипыЗаданий.ПолучитьАвтопротокол);
	
КонецПроцедуры

#КонецОбласти