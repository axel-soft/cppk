#Если НЕ ВебКлиент И Не МобильныйКлиент Тогда
		
////////////////////////////////////////////////////
//// РАБОТА С ПРОСТЫМ АВТОЗАПОЛНЕНИЕМ MS OFFICE


// Возвращает признак того, является ли указанное расширение ассоциированным с MSWord (включая шаблоны).
//
// Параметры:
//  Расширение - Строка - расширение в нижнем регистре.
//
// Возвращаемое значение:
//  Булево - признак того, что расширение ассоциируется с MSWord (включая шаблоны).
//
Функция ФорматMSWord(Расширение) Экспорт
	
	Возврат Расширение = "doc" 
		ИЛИ Расширение = "dot"
		ИЛИ Расширение = "docx" 
		ИЛИ Расширение = "dotx";
		
КонецФункции

// Возвращает признак того, является ли указанное расширение ассоциированным с MSWord.
//
// Параметры:
//  Расширение - Строка - расширение в нижнем регистре.
//
// Возвращаемое значение:
//  Булево - признак того, что расширение ассоциируется с MSWord.
//
Функция ЭтоMSWord(Расширение) Экспорт
	
	Возврат Расширение = "doc" 
		ИЛИ Расширение = "docx";
		
КонецФункции

Функция ПолучитьМассивКороткихПодстрок(Знач ДлиннаяСтрока, МаксДлинаПодстроки)
	
	Результат = Новый Массив;
	
	Пока СтрДлина(ДлиннаяСтрока) > 0 Цикл
		Если СтрДлина(ДлиннаяСтрока) >= МаксДлинаПодстроки Тогда
			Подстрока = Лев(ДлиннаяСтрока, МаксДлинаПодстроки);
		Иначе
			Подстрока = ДлиннаяСтрока;
		КонецЕсли;
		
		Результат.Добавить(Подстрока);
		ДлиннаяСтрока = Прав(ДлиннаяСтрока, СтрДлина(ДлиннаяСтрока) - СтрДлина(Подстрока));
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции
		
//Заполняет документ MSWord с использованием настроек автозаполнения
//Параметры:Расширение - расширение файла ("doc" и т.п.)
//			НастройкиЗамены - массив настроек замены
//			ПутьКФайлуНаДиске - путь на компьютере, куда выгружена текущая версия файла
//Возвращает:Путь на диске компьютера, куда сохранена заполненная версия файла
Функция ЗаполнитьФайлMSWordПоАдресуФайла(Расширение, НастройкиЗамены, ПутьКФайлуНаДиске) Экспорт
	
	Если НастройкиЗамены.Количество() = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	НовыйПутьКФайлу = ПолучитьИмяВременногоФайла(Расширение);

	КолКолонок = 0;
	Для Каждого НастройкаЗамены Из НастройкиЗамены Цикл
		Если ТипЗнч(НастройкаЗамены.ЗначениеЗамены) = Тип("Массив") Тогда
			КолКолонок = КолКолонок + 1;
		КонецЕсли;
	КонецЦикла;
	
	Попытка
		СисИнфо = Новый СистемнаяИнформация;
		Если СисИнфо.ТипПлатформы = ТипПлатформы.Windows_x86 ИЛИ СисИнфо.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
			WordApp = Новый COMОбъект("Word.Application");
		Иначе
			УдалитьФайлы(НовыйПутьКФайлу);
			Возврат "Linux";
		КонецЕсли;
	Исключение
		УдалитьФайлы(НовыйПутьКФайлу);
		ВызватьИсключение(НСтр("ru = 'Ошибка работы с приложением MS Word. Необходимо проверить правильность установки приложения.'"));
	КонецПопытки;
	
	WordApp.WordBasic.DisableAutoMacros(1);
	ОчиститьТабличнуюЧасть = Истина; НашаТаблица = Неопределено;
	Док = WordApp.Documents.Add(ПутьКФайлуНаДиске);
	КоличествоТаблиц = Док.Tables.Count;
	Для Каждого НастройкаЗамены Из НастройкиЗамены Цикл
		Попытка
			Если ЗначениеЗаполнено(НастройкаЗамены.ЗначениеЗамены) ИЛИ НЕ ПустаяСтрока(НастройкаЗамены.ТермДляЗамены) Тогда
				Если ТипЗнч(НастройкаЗамены.ЗначениеЗамены) = Тип("Массив") Тогда 
					ИмяРеквизита = СтрЗаменить(Лев(НастройкаЗамены.ТермДляЗамены, 20), " ", "_");
					
					Если КоличествоТаблиц > 0 Тогда 
						Если НашаТаблица = Неопределено Тогда 
							Для Ит = 1 По КоличествоТаблиц Цикл 
								Если Док.Tables(Ит).Rows.Count > 1 Тогда 
									
									Для Ном = 1 По Док.Tables(Ит).Columns.Count Цикл
										Попытка
											Если Док.Bookmarks(ИмяРеквизита).Range.BookmarkID = 
												Док.Tables(Ит).Cell(2, Ном).Range.Fields(1).Result.BookmarkID Тогда 
												
												НашаТаблица = Док.Tables(Ит);
												НастройкаЗамены.НомерКолонкиТабличнойЧасти = Ном;
												Прервать;
											КонецЕсли;
										Исключение
										КонецПопытки;
									КонецЦикла;
								КонецЕсли;
								
								Если НашаТаблица <> Неопределено Тогда 
									// Нашли нужную таблицу
									Прервать;
								КонецЕсли;
							КонецЦикла;
						Иначе 
							Для Ном = 1 По НашаТаблица.Columns.Count Цикл
								Попытка
									Если Док.Bookmarks(ИмяРеквизита).Range.BookmarkID = 
										НашаТаблица.Cell(2, Ном).Range.Fields(1).Result.BookmarkID Тогда 
										
										НастройкаЗамены.НомерКолонкиТабличнойЧасти = Ном;
										Прервать;
									КонецЕсли;
								Исключение
								КонецПопытки;
							КонецЦикла;
						КонецЕсли;
						
						Если ОчиститьТабличнуюЧасть Тогда 
							КоличествоСтрокТаблицы = НашаТаблица.Rows.Count;
							Если КоличествоСтрокТаблицы > 2 Тогда 
								Пока КоличествоСтрокТаблицы > 2 Цикл 
									НашаТаблица.Rows(КоличествоСтрокТаблицы).Delete();
									КоличествоСтрокТаблицы = КоличествоСтрокТаблицы - 1;
								КонецЦикла;
							КонецЕсли;
							
							Для Ном = 1 По НастройкаЗамены.ЗначениеЗамены.Количество() - 1 Цикл 
								НашаТаблица.Rows.Add();

							КонецЦикла;
							
							ОчиститьТабличнуюЧасть = Ложь;
						КонецЕсли;
						
						Для Ном = 2 По НастройкаЗамены.ЗначениеЗамены.Количество() + 1 Цикл
							Значение = НастройкаЗамены.ЗначениеЗамены[Ном - 2];
							
							Если Ном = 2 Тогда 
								Док.Bookmarks(ИмяРеквизита).Range.Fields(1).Result.Text = СокрЛП(Значение.Значение);
							Иначе 
								НашаТаблица.Cell(Ном, НастройкаЗамены.НомерКолонкиТабличнойЧасти).Range.Text = 
									СокрЛП(Значение.Значение);
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
					
				Иначе 
				
					НастройкаЗамены.ЗначениеЗамены = СтрЗаменить(НастройкаЗамены.ЗначениеЗамены, Символы.ПС, "_+_");
					Если НЕ ПустаяСтрока(НастройкаЗамены.ТермДляЗамены) Тогда
						ИмяРеквизита = СтрЗаменить(Лев(НастройкаЗамены.ТермДляЗамены, 20), " ", "_");
						Док.Bookmarks(ИмяРеквизита).Range.Fields(1).Result.Text = НастройкаЗамены.ЗначениеЗамены;
					КонецЕсли;
					Если НЕ ПустаяСтрока(НастройкаЗамены.ЗаменяемаяСтрока) Тогда
						МассивКороткихПодстрок = ПолучитьМассивКороткихПодстрок(НастройкаЗамены.ЗначениеЗамены, 200);
						Для Счетчик = 0 ПО МассивКороткихПодстрок.Количество() - 1 Цикл
							МассивКороткихПодстрок[Счетчик] = МассивКороткихПодстрок[Счетчик] + "_~_";
						КонецЦикла;	  
						Счетчик = 0;
						Для Каждого ОднаПодстрока Из МассивКороткихПодстрок Цикл
							Если Счетчик = 0 Тогда
								Док.Content.Find.Execute(НастройкаЗамены.ЗаменяемаяСтрока, , , , , , , , , ОднаПодстрока, 2);
								Для Каждого Секция Из Док.Sections Цикл
									Для Каждого Верхний Из Секция.Headers Цикл 
										Если Верхний.Exists Тогда
											Верхний.Range.Find.Execute(НастройкаЗамены.ЗаменяемаяСтрока, , , , , , , , , ОднаПодстрока, 2);
										КонецЕсли;
									КонецЦикла;
									Для Каждого Нижний Из Секция.Footers Цикл 
										Если Нижний.Exists Тогда
											Нижний.Range.Find.Execute(НастройкаЗамены.ЗаменяемаяСтрока, , , , , , , , , ОднаПодстрока, 2);
										КонецЕсли;
									КонецЦикла;
								КонецЦикла;
							Иначе
								Док.Content.Find.Execute("_~_", , , , , , , , , ОднаПодстрока, 2);
								Для Каждого Секция Из Док.Sections Цикл
									Для Каждого Верхний Из Секция.Headers Цикл 
										Если Верхний.Exists Тогда
											Верхний.Range.Find.Execute("_~_", , , , , , , , , ОднаПодстрока, 2);
										КонецЕсли;
									КонецЦикла;
									Для Каждого Нижний Из Секция.Footers Цикл 
										Если Нижний.Exists Тогда
											Нижний.Range.Find.Execute("_~_", , , , , , , , , ОднаПодстрока, 2);
										КонецЕсли;
									КонецЦикла;
								КонецЦикла;	
							КонецЕсли;
							Счетчик = Счетчик + 1;
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
				
				Док.Content.Find.Execute("_~_", , , , , , , , , "", 2);
				Док.Content.Find.Execute("_+_", , , , , , , , , "^p", 2);
				Для Каждого Секция Из Док.Sections Цикл
					Для Каждого Верхний Из Секция.Headers Цикл 
						Если Верхний.Exists Тогда
							Верхний.Range.Find.Execute("_~_", , , , , , , , , "", 2);
							Верхний.Range.Find.Execute("_+_", , , , , , , , , "^p", 2);
						КонецЕсли;
					КонецЦикла;
					Для Каждого Нижний Из Секция.Footers Цикл 
						Если Нижний.Exists Тогда
							Нижний.Range.Find.Execute("_~_", , , , , , , , , "", 2);
							Нижний.Range.Find.Execute("_+_", , , , , , , , , "^p", 2);
						КонецЕсли;
					КонецЦикла;
				КонецЦикла;
			КонецЕсли;
		Исключение
			Инфо = ИнформацияОбОшибке();
		КонецПопытки;
	КонецЦикла; 	 
	

	ВерсияСтрока = WordApp.Build;
	МассивСтр = СтрРазделить(ВерсияСтрока, ".", Ложь);
	ВерсияЧисло = 0;
	Попытка
		ВерсияЧисло = Число(МассивСтр[0]);
	Исключение
		ВерсияЧисло = 0;
	КонецПопытки;		
	
	Если ВерсияЧисло >= 12 Тогда
	
		Если Расширение = "docx" Тогда
			Док.SaveAs(НовыйПутьКФайлу, 12);                        
		Иначе
			Док.SaveAs(НовыйПутьКФайлу, 0);
		КонецЕсли;
		
	Иначе
	    Если Расширение = "docx" Тогда
			Док.SaveAs(НовыйПутьКФайлу, 109);                        
		Иначе
			Док.SaveAs(НовыйПутьКФайлу);
		КонецЕсли;
	КонецЕсли;
	
	Док.Saved = Истина;
	Док.Close(); 
	WordApp.Quit();	
	WordApp = Неопределено;
	ДвоичныеДанныеЗаполненногоФайла = Новый ДвоичныеДанные(НовыйПутьКФайлу);
	
	УдалитьФайлы(ПутьКФайлуНаДиске);	
	УдалитьФайлы(НовыйПутьКФайлу);
	
	Возврат ДвоичныеДанныеЗаполненногоФайла;
	
КонецФункции

//Заполняет документ MSWord с использованием настроек автозаполнения
//Параметры:Расширение - расширение файла ("doc" и т.п.)
//			НастройкиЗамены - массив настроек замены
//			ДвоичныеДанныеФайла - бинарные данные текущей версии файла
//Возвращает:Путь на диске компьютера, куда сохранена заполненная версия файла
Функция ЗаполнитьФайлMSWordПоДвоичнымДанным(Расширение, НастройкиЗамены, ДвоичныеДанныеФайла) Экспорт
	
	Если НастройкиЗамены.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ДвоичныеДанныеФайла <> Неопределено Тогда
		Если НРег(Расширение) = "doc" Тогда 
			ПутьКФайлуНаДиске = ПолучитьИмяВременногоФайла(Расширение);
			ДвоичныеДанныеФайла.Записать(ПутьКФайлуНаДиске);
			Возврат ЗаполнитьФайлMSWordПоАдресуФайла(Расширение, НастройкиЗамены, ПутьКФайлуНаДиске);
		ИначеЕсли НРег(Расширение) = "docx" Тогда
			Попытка
				Возврат ЗаполнитьФайлMSWordВXML(ДвоичныеДанныеФайла, Расширение, НастройкиЗамены, Ложь);
			Исключение
				Возврат ЗаполнитьФайлMSWordВXML(ДвоичныеДанныеФайла, Расширение, НастройкиЗамены, Истина);
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

//Осуществляет поиск в файле MSWord полей и строк, которые указаны в массиве автозамен
//Параметры:Расширение - расширение файла ("doc" и т.п.)
//			НастройкиЗамены - массив автозамен в файле
//			ДвоичныеДанныеФайла - ДвоичныеДанные последней версии файла
//Возвращает:Текст сообщения об ошибке с использованием НСтр() с перечислением отсутствующих полей и строк, если какое-либо поле или строка не найдена
//			 ПустаяСтрока, если все поля и строки присутствуют в файле
Функция ПроверитьНаличиеПолейИСтрокВФайлеMSWord(Расширение, НастройкиЗамены, ДвоичныеДанныеФайла) Экспорт
	
	ИмяФайлаСПутем = ПолучитьИмяВременногоФайла(Расширение);
	ДвоичныеДанныеФайла.Записать(ИмяФайлаСПутем);
	
	Если НРег(Расширение) = "doc" Тогда
		Попытка
			WordApp = Новый COMОбъект("Word.Application");    
		Исключение
			УдалитьФайлы(ИмяФайлаСПутем);
			Возврат НСтр("ru = 'Ошибка работы с приложением MS Word. Необходимо проверить правильность установки приложения.'");
		КонецПопытки;
		
		WordApp.WordBasic.DisableAutoMacros(1);
		Док = WordApp.Documents.Add(ИмяФайлаСПутем); 
	КонецЕсли;
	
	ЕстьОшибкаПоПолям = Ложь;
	ОписаниеОшибкиПоля = НСтр("ru = 'Следующие поля отсутствуют в шаблоне:'") + Символы.ВК;
	
	ЕстьОшибкаПоСтрокам = Ложь;
	ОписаниеОшибкиСтроки = НСтр("ru = 'Следующие строки отсутствуют в шаблоне:'") + Символы.ВК;
	
	Для Каждого НастройкаЗамены Из НастройкиЗамены Цикл
		
		Если ПустаяСтрока(НастройкаЗамены.ТермДляЗамены) И
			 ПустаяСтрока(НастройкаЗамены.ЗаменяемаяСтрока) Тогда
			Возврат НСтр("ru = 'Необходимо указать либо строку для замены, либо поле для замены'");
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(НастройкаЗамены.ТермДляЗамены) Тогда
			ПолеНайдено = Ложь;
			Если НРег(Расширение) = "doc" Тогда 
				Для Каждого Field из Док.FormFields Цикл
					Если (Field.Name = НастройкаЗамены.ТермДляЗамены) Тогда
						ПолеНайдено = Истина;
					КонецЕсли;
				КонецЦикла;
			ИначеЕсли НРег(Расширение) = "docx" Тогда
				ПолеНайдено = ПроверитьНаличиеПоляВФайлеDocX(НастройкаЗамены.ТермДляЗамены, ИмяФайлаСПутем);
			КонецЕсли;
			
			Если НЕ ПолеНайдено Тогда 
				ОписаниеОшибкиПоля = ОписаниеОшибкиПоля + НастройкаЗамены.ТермДляЗамены + Символы.ВК;
				ЕстьОшибкаПоПолям = Истина;
			КонецЕсли;
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(НастройкаЗамены.ЗаменяемаяСтрока) Тогда
			Если НРег(Расширение) = "doc" Тогда
				РезультатЕстьВВерхнемКолонтитуле = Ложь;
				РезультатЕстьВНижнемКолонтитуле = Ложь;
				Для Каждого Секция Из WordApp.ActiveDocument.Sections Цикл
					Для Каждого Верхний Из Секция.Headers Цикл 
						Если Верхний.Exists Тогда
							РезультатЕстьВВерхнемКолонтитуле = Верхний.Range.Find.Execute(НастройкаЗамены.ЗаменяемаяСтрока,,,,,,Истина);
							Если РезультатЕстьВВерхнемКолонтитуле Тогда
								Прервать;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;
					Для Каждого Нижний Из Секция.Footers Цикл 
						Если Нижний.Exists Тогда
							РезультатЕстьВНижнемКолонтитуле = Нижний.Range.Find.Execute(НастройкаЗамены.ЗаменяемаяСтрока,,,,,,Истина);
							Если РезультатЕстьВНижнемКолонтитуле Тогда
								Прервать;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;
				КонецЦикла;
				Если НЕ WordApp.Selection.Find.Execute(НастройкаЗамены.ЗаменяемаяСтрока,,,,,,Истина)
					И НЕ WordApp.Selection.Find.Execute(НастройкаЗамены.ЗаменяемаяСтрока,,,,,,Ложь) 
					И Не РезультатЕстьВВерхнемКолонтитуле 
					И Не РезультатЕстьВНижнемКолонтитуле Тогда
					ОписаниеОшибкиСтроки = ОписаниеОшибкиСтроки + НастройкаЗамены.ЗаменяемаяСтрока + Символы.ВК;
					ЕстьОшибкаПоСтрокам = Истина;
				Иначе 
					WordApp.Selection.Collapse();
				КонецЕсли;
			ИначеЕсли НРег(Расширение) = "docx" Тогда 
				ПолеНайдено = ПроверитьНаличиеСтрокиВФайлеDocX(НастройкаЗамены.ЗаменяемаяСтрока, ИмяФайлаСПутем);
				Если НЕ ПолеНайдено Тогда
					ОписаниеОшибкиСтроки = ОписаниеОшибкиСтроки + НастройкаЗамены.ЗаменяемаяСтрока + Символы.ВК;
					ЕстьОшибкаПоСтрокам = Истина;	
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;

	Если НРег(Расширение) = "doc" Тогда
		Док.Saved = Истина;
		Док.Close(); 
		WordApp.Quit();
		WordApp = Неопределено;
	КонецЕсли;

	УдалитьФайлы(ИмяФайлаСПутем);
	
	Если ЕстьОшибкаПоПолям И
		 ЕстьОшибкаПоСтрокам Тогда
		Возврат ОписаниеОшибкиПоля + Символы.ВК + ОписаниеОшибкиСтроки;
	ИначеЕсли ЕстьОшибкаПоПолям Тогда
		Возврат ОписаниеОшибкиПоля;
	ИначеЕсли ЕстьОшибкаПоСтрокам Тогда
		Возврат ОписаниеОшибкиСтроки;
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

//Выполняет поиск всех полей в файле формата MSWord 2003-
Функция НайтиВсеПоляВФайлеMSWord(Расширение, ДвоичныеДанныеФайла,
	ТекстыДляПоиска = Неопределено, НайденныеТексты = Неопределено) Экспорт
	
	РезультатПоиска = Новый Массив();
	Если Расширение = "doc" Тогда
		Попытка
			WordApp = Новый COMОбъект("Word.Application");
		Исключение
			Сообщение = НСтр("ru = 'Ошибка работы с приложением MS Word. Необходимо проверить правильность установки приложения.'");
			ВызватьИсключение(Сообщение);
		КонецПопытки;
		
		WordApp.WordBasic.DisableAutoMacros(1);
		ИмяФайлаСПутем = ПолучитьИмяВременногоФайла(Расширение);
		ДвоичныеДанныеФайла.Записать(ИмяФайлаСПутем);
		
		Док = WordApp.Documents.Add(ИмяФайлаСПутем);
		Для Каждого Field Из Док.FormFields Цикл
			Если РезультатПоиска.Найти(Field.Name) = Неопределено 
				И Найти(Field.Name, "_GoBack") = 0 Тогда
				РезультатПоиска.Добавить(Field.Name);
			КонецЕсли;
		КонецЦикла;
		
		Если ТекстыДляПоиска <> Неопределено Тогда
			
			Для Каждого Подстрока Из ТекстыДляПоиска Цикл
				Результат = WordApp.Selection.Find.Execute(Подстрока);
				Если Результат Тогда
					НайденныеТексты.Добавить(Подстрока);
				КонецЕсли;	
			КонецЦикла;	
			
			
		КонецЕсли;	
		
		Док.Saved = Истина;
		Док.Close(); 
		WordApp.Quit();
		WordApp = Неопределено;
		УдалитьФайлы(ИмяФайлаСПутем);
	ИначеЕсли Расширение = "docx" Тогда
		
        НайтиВсеПоляВФайлеDocX(ДвоичныеДанныеФайла, РезультатПоиска,
        	ТекстыДляПоиска, НайденныеТексты);
        
	КонецЕсли;
	
	Возврат РезультатПоиска;
	
КонецФункции

//Выполняет поиск указанной строки в файле формата MS Word 2003-
// Параметры
// ПолеДляПоиска - Строка или Массив строк
Функция ПроверитьНаличиеСтрокиВФайлеMSWord(ИмяФайлаСПутем, ПолеДляПоиска, WordApp = Неопределено) Экспорт
	
	МассивПоиска = ПолеДляПоиска;
	Если ТипЗнч(ПолеДляПоиска) = Тип("Строка") Тогда
		МассивПоиска = Новый Массив;
		МассивПоиска.Добавить(ПолеДляПоиска);
	КонецЕсли;	
	
	ЗакрыватьПриложение = Ложь;
	Если WordApp = Неопределено Тогда 
		
		СисИнфо = Новый СистемнаяИнформация;
		Если СисИнфо.ТипПлатформы = ТипПлатформы.Windows_x86 ИЛИ СисИнфо.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
			Попытка
				WordApp = Новый COMОбъект("Word.Application");
			Исключение
				ВызватьИсключение(НСтр("ru = 'Ошибка работы с приложением MS Word. Необходимо проверить правильность установки приложения.'"));
			КонецПопытки;
		Иначе
			ВызватьИсключение(НСтр("ru = 'Работа с файлами MS Word возможна только в Windows. Обратитесь к администратору.'"));	
		КонецЕсли;
		ЗакрыватьПриложение = Истина;
		
	КонецЕсли;
	
	WordApp.WordBasic.DisableAutoMacros(1);
	Док = WordApp.Documents.Add(ИмяФайлаСПутем);
	Если Док.ProtectionType <> 2 Тогда
		
		Результат = Ложь;
		Для Каждого Подстрока Из МассивПоиска Цикл
			Результат = WordApp.Selection.Find.Execute(Подстрока);
			Если Результат Тогда
				Прервать;
			КонецЕсли;	
		КонецЦикла;	
		
		Если Не Результат Тогда
			Для Каждого InlineShape Из WordApp.ActiveDocument.InlineShapes Цикл
				Если МассивПоиска.Найти(InlineShape.AlternativeText) <> Неопределено Тогда
					Результат = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	Иначе
		Результат = Ложь;
	КонецЕсли;
	Док.Saved = Истина;
	Док.Close(); 
	Если ЗакрыватьПриложение Тогда
		WordApp.Quit();
		WordApp = Неопределено;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////
//// РАБОТА С АВТОЗАПОЛНЕНИЕМ MS OFFICE 2007+

//заполняет поля и строки в файле MSWord формата 2007+
Функция ЗаполнитьФайлMSWordВXML(ДвоичныеДанныеФайла, ТекущаяВерсияРасширение, 
	МассивДанныхДляАвтоЗамен, ЗаменятьПространствоИмен = Истина,
	ЗаполнятьТолькоПоляРегистрации = Ложь) Экспорт
	
	СтарыйПутьКФайлу = ПолучитьИмяВременногоФайла(ТекущаяВерсияРасширение);
	ДвоичныеДанныеФайла.Записать(СтарыйПутьКФайлу);
	НовыйПутьКФайлу = ПолучитьИмяВременногоФайла(ТекущаяВерсияРасширение);
	
	КопироватьФайл(СтарыйПутьКФайлу, СтрЗаменить(СтарыйПутьКФайлу, ТекущаяВерсияРасширение, "zip"));
	ИмяФайлаСПутемZIP = СтрЗаменить(СтарыйПутьКФайлу, ТекущаяВерсияРасширение, "zip");

	ВременнаяПапкаДляРазархивирования = ПолучитьИмяВременногоФайла("");
	ВременныйZIPФайл = ПолучитьИмяВременногоФайла("zip"); 

	Архив = Новый ЧтениеZipФайла();
	Архив.Открыть(ИмяФайлаСПутемZIP);
	Архив.ИзвлечьВсе(ВременнаяПапкаДляРазархивирования, РежимВосстановленияПутейФайловZIP.Восстанавливать);
	Архив.Закрыть();

	//Заполнение полей в теле документа
	Если ЗаменятьПространствоИмен Тогда
		ЗаменитьПространствоИменR(ВременнаяПапкаДляРазархивирования + "/word/document.xml");
	КонецЕсли;
	ЧтениеXML = Новый ЧтениеXML();
	ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/document.xml");
	ЗаписьXML = Новый ЗаписьXML;
	ПараметрыЗаписи = Новый ПараметрыЗаписиXML(,, Ложь, Ложь);
	ЗаписьXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/document_update.xml", ПараметрыЗаписи);
	ЗаписьXML.ЗаписатьОбъявлениеXML();
	
	АдресXML = ВременнаяПапкаДляРазархивирования + "/word/document_update1.xml";

	ВыполнитьЗаменуПолейИСтрокВДокументеMSOfficeOpenXML(
		ЧтениеXML, ЗаписьXML, АдресXML, МассивДанныхДляАвтоЗамен, ЗаполнятьТолькоПоляРегистрации);
	ЧтениеXML.Закрыть();
	ЗаписьXML.Закрыть();

	ПереместитьФайл(
		ВременнаяПапкаДляРазархивирования + "/word/document_update.xml",
		ВременнаяПапкаДляРазархивирования + "/word/document.xml");
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования + "/word/document_update.xml");
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования + "/word/document_update1.xml");
	
	// Заполнение полей в верхних колонтитулах
	ЧтениеXML = Новый ЧтениеXML();
	ЗаписьXML = Новый ЗаписьXML;
	Для Счетчик = 1 по 10 Цикл
		Если НайтиФайлы(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml").Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		Если ЗаменятьПространствоИмен Тогда
			ЗаменитьПространствоИменR(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml");
		КонецЕсли;
		ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml");
		ЗаписьXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + "_update.xml", ПараметрыЗаписи);
		ЗаписьXML.ЗаписатьОбъявлениеXML(); 
		АдресXML = ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + "_update1.xml";

		ВыполнитьЗаменуПолейИСтрокВДокументеMSOfficeOpenXML(
			ЧтениеXML, ЗаписьXML, АдресXML, МассивДанныхДляАвтоЗамен, ЗаполнятьТолькоПоляРегистрации);
		
		ЧтениеXML.Закрыть();
		ЗаписьXML.Закрыть();
		
		ПереместитьФайл(
			ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + "_update.xml",
			ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml");
		УдалитьФайлы(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + "_update.xml");
		УдалитьФайлы(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + "_update1.xml");
	КонецЦикла;
	
	// Заполнение полей в нижних колонтитулах
	ЧтениеXML = Новый ЧтениеXML();
	ЗаписьXML = Новый ЗаписьXML;
	Для Счетчик = 1 по 10 Цикл
		Если НайтиФайлы(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml").Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		Если ЗаменятьПространствоИмен Тогда
			ЗаменитьПространствоИменR(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml");
		КонецЕсли;
		ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml");
		ЗаписьXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + "_update.xml", ПараметрыЗаписи);
		ЗаписьXML.ЗаписатьОбъявлениеXML(); 
		
		АдресXML = ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + "_update1.xml";
		
		ВыполнитьЗаменуПолейИСтрокВДокументеMSOfficeOpenXML(
			ЧтениеXML, ЗаписьXML, АдресXML, МассивДанныхДляАвтоЗамен, ЗаполнятьТолькоПоляРегистрации);
		
		ЧтениеXML.Закрыть();
		ЗаписьXML.Закрыть();
		
		ПереместитьФайл(
			ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + "_update.xml",
			ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml");
		УдалитьФайлы(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + "_update.xml");
		УдалитьФайлы(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + "_update1.xml");
	КонецЦикла;
	
	Архиватор = Новый ЗаписьZipФайла(ВременныйZIPФайл, "", "");
	Архиватор.Добавить(
		ВременнаяПапкаДляРазархивирования + "\*.*",
		РежимСохраненияПутейZIP.СохранятьОтносительныеПути,
		РежимОбработкиПодкаталоговZIP.ОбрабатыватьРекурсивно);
	Архиватор.Записать();

	ПереместитьФайл(ВременныйZIPФайл, НовыйПутьКФайлу);
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования);	
	
	ДвоичныеДанныеЗаполненногоФайла = Новый ДвоичныеДанные(НовыйПутьКФайлу);
	УдалитьФайлы(СтарыйПутьКФайлу);
	УдалитьФайлы(НовыйПутьКФайлу);
	УдалитьФайлы(ИмяФайлаСПутемZIP);
	
	Возврат ДвоичныеДанныеЗаполненногоФайла;
	
КонецФункции

Функция ПроверитьНаличиеПоляВФайлеDocX(ИмяПоля, ПутьКФайлу)
	
	КопироватьФайл(ПутьКФайлу, СтрЗаменить(ПутьКФайлу, "docx", "zip"));
	ИмяФайлаСПутемZIP = СтрЗаменить(ПутьКФайлу, "docx", "zip");

	ВременнаяПапкаДляРазархивирования = ПолучитьИмяВременногоФайла("");
	ВременныйZIPФайл = ПолучитьИмяВременногоФайла("zip"); 

	Архив = Новый ЧтениеZipФайла();
	Архив.Открыть(ИмяФайлаСПутемZIP);
	Архив.ИзвлечьВсе(ВременнаяПапкаДляРазархивирования, РежимВосстановленияПутейФайловZIP.Восстанавливать);
	Архив.Закрыть();

	//поиск полей в теле документа
	ЧтениеXML = Новый ЧтениеXML();
	ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/document.xml");
	Если НайтиПоле(ЧтениеXML, ИмяПоля) Тогда
		ЧтениеXML.Закрыть();
		УдалитьФайлы(ВременнаяПапкаДляРазархивирования);
		УдалитьФайлы(ВременныйZIPФайл);
		Возврат Истина;
	КонецЕсли;
			
	Для Счетчик = 1 по 10 Цикл
		Если НайтиФайлы(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml").Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml"); 
		Если НайтиПоле(ЧтениеXML, ИмяПоля) Тогда
			ЧтениеXML.Закрыть();
			УдалитьФайлы(ВременнаяПапкаДляРазархивирования);
			УдалитьФайлы(ВременныйZIPФайл);
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;	
			
	Для Счетчик = 1 по 10 Цикл
		Если НайтиФайлы(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml").Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml"); 
		Если НайтиПоле(ЧтениеXML, ИмяПоля) Тогда
			ЧтениеXML.Закрыть();
			УдалитьФайлы(ВременнаяПапкаДляРазархивирования);
			УдалитьФайлы(ВременныйZIPФайл);
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;

	ЧтениеXML.Закрыть();
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования);
	УдалитьФайлы(ВременныйZIPФайл);
	Возврат Ложь;
	
КонецФункции

Функция НайтиПоле(ЧтениеXML, ИмяПоля)
	
	ЧтениеXML.ИгнорироватьПробелы = Ложь;
	ФлагНайденоПоле = Ложь;	
	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Если ЧтениеXML.Имя = "w:bookmarkStart" Тогда
				ФлагНайденоПоле = Истина; 
			КонецЕсли;

			Если ЧтениеXML.КоличествоАтрибутов() > 0 Тогда
				Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
					Если ФлагНайденоПоле И ЧтениеXML.Имя = "w:name" 
						И ИмяПоля = ЧтениеXML.Значение Тогда
						Возврат Истина;
					КонецЕсли;
				КонецЦикла
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

//Корректирует   - если в соседних <w:t>  Вставить  Э  П   или    Вставить  ЭП 
//
// Параметры
// ИмяФайлаДокумента - Строка
Процедура КорректироватьРазрывы_ВставитьЭП(ИмяФайлаДокумента) Экспорт
	
	ЧтениеТекста = Новый ЧтениеТекста(
		ИмяФайлаДокумента,
		КодировкаТекста.UTF8);
	ТекстXml = ЧтениеТекста.Прочитать();
	ЧтениеТекста.Закрыть();    
	
	НужноЗаписать = Ложь;
	
	ЧислоПроходов = 0;
	Позиция = 1;
	
	Пока Истина Цикл
		
		ПозицияДок = СтрНайти(ТекстXml, "<w:t>Вст</w:t>", НаправлениеПоиска.СНачала, Позиция);
		Если ПозицияДок <> 0 Тогда
		
			ПозицияWT = СтрНайти(ТекстXml, "<w:t>", НаправлениеПоиска.СНачала, ПозицияДок + 5);
			ПозицияЭП = СтрНайти(ТекстXml, "<w:t>авитьЭП</w:t>", НаправлениеПоиска.СНачала, ПозицияДок + 5);
			Если ПозицияWT <> 0 Тогда

				Если ПозицияWT = ПозицияЭП Тогда // нашли
					
					// заменим <w:t>ЭП</w:t> на <w:t> </w:t> - с пробелом
					// потом заменим <w:t>Вставить</w:t> на  <w:t>ВставитьЭП</w:t>
					
					ТекстXml = Лев(ТекстXml, ПозицияЭП - 1)
					 + "<w:t> </w:t>"
					  + Сред(ТекстXml, ПозицияЭП + СтрДлина("<w:t>авитьЭП</w:t>"));

					ТекстXml = Лев(ТекстXml, ПозицияДок - 1)
					 + "<w:t>ВставитьЭП</w:t>"
					  + Сред(ТекстXml, ПозицияДок + СтрДлина("<w:t>Вст</w:t>"));
					  
					  НужноЗаписать = Истина;
					  
					  Прервать;
					  
				КонецЕсли;
			  
			КонецЕсли;	
			  
		КонецЕсли;	
		  
		
		ПозицияДок = СтрНайти(ТекстXml, "<w:t>Встави</w:t>", НаправлениеПоиска.СНачала, Позиция);
		Если ПозицияДок <> 0 Тогда
		
			ПозицияWT = СтрНайти(ТекстXml, "<w:t>", НаправлениеПоиска.СНачала, ПозицияДок + 5);
			ПозицияЭП = СтрНайти(ТекстXml, "<w:t>тьЭП</w:t>", НаправлениеПоиска.СНачала, ПозицияДок + 5);
			Если ПозицияWT <> 0 Тогда

				Если ПозицияWT = ПозицияЭП Тогда // нашли
					
					// заменим <w:t>ЭП</w:t> на <w:t> </w:t> - с пробелом
					// потом заменим <w:t>Вставить</w:t> на  <w:t>ВставитьЭП</w:t>
					
					ТекстXml = Лев(ТекстXml, ПозицияЭП - 1)
					 + "<w:t> </w:t>"
					  + Сред(ТекстXml, ПозицияЭП + СтрДлина("<w:t>тьЭП</w:t>"));

					ТекстXml = Лев(ТекстXml, ПозицияДок - 1)
					 + "<w:t>ВставитьЭП</w:t>"
					  + Сред(ТекстXml, ПозицияДок + СтрДлина("<w:t>Встави</w:t>"));
					  
					  НужноЗаписать = Истина;
					  
					  Прервать;
					  
				КонецЕсли;
			  
			КонецЕсли;	
			  
		КонецЕсли;	
		
		
		ПозицияДок = СтрНайти(ТекстXml, "<w:t>Вставить</w:t>", НаправлениеПоиска.СНачала, Позиция);
		Если ПозицияДок = 0 Тогда
			Прервать;
		КонецЕсли;	
		
		ПозицияWT = СтрНайти(ТекстXml, "<w:t>", НаправлениеПоиска.СНачала, ПозицияДок + 5);
		ПозицияЭП = СтрНайти(ТекстXml, "<w:t>ЭП</w:t>", НаправлениеПоиска.СНачала, ПозицияДок + 5);
		Если ПозицияWT = 0 Тогда
			Прервать;
		КонецЕсли;	

		Если ПозицияWT = ПозицияЭП Тогда // нашли
			
			// заменим <w:t>ЭП</w:t> на <w:t> </w:t> - с пробелом
			// потом заменим <w:t>Вставить</w:t> на  <w:t>ВставитьЭП</w:t>
			
			ТекстXml = Лев(ТекстXml, ПозицияЭП - 1)
			 + "<w:t> </w:t>"
			  + Сред(ТекстXml, ПозицияЭП + СтрДлина("<w:t>ЭП</w:t>"));

			ТекстXml = Лев(ТекстXml, ПозицияДок - 1)
			 + "<w:t>ВставитьЭП</w:t>"
			  + Сред(ТекстXml, ПозицияДок + СтрДлина("<w:t>Вставить</w:t>"));
			  
			  НужноЗаписать = Истина;
			  
			  Прервать;
			  
		КонецЕсли;
		  
		ПозицияЭ = СтрНайти(ТекстXml, "<w:t>Э</w:t>", НаправлениеПоиска.СНачала, ПозицияДок + 5); 
		Если ПозицияWT = ПозицияЭ Тогда // нашли 
			
			ПозицияWT2 = СтрНайти(ТекстXml, "<w:t>", НаправлениеПоиска.СНачала, ПозицияЭ + 5);
			ПозицияП = СтрНайти(ТекстXml, "<w:t>П</w:t>", НаправлениеПоиска.СНачала, ПозицияЭ + 5);
			Если ПозицияWT2 = 0 Тогда
				Прервать;
			КонецЕсли;	

			Если ПозицияWT2 = ПозицияП Тогда // нашли    
				
				// заменим <w:t>П</w:t> на <w:t> </w:t> - с пробелом
				// заменим <w:t>Э</w:t> на <w:t> </w:t> - с пробелом
				// потом заменим <w:t>Вставить</w:t> на  <w:t>ВставитьЭП</w:t>

				ТекстXml = Лев(ТекстXml, ПозицияП - 1)
				 + "<w:t> </w:t>"
				  + Сред(ТекстXml, ПозицияП + СтрДлина("<w:t>П</w:t>"));
				
				ТекстXml = Лев(ТекстXml, ПозицияЭ - 1)
				 + "<w:t> </w:t>"
				  + Сред(ТекстXml, ПозицияЭ + СтрДлина("<w:t>Э</w:t>"));

				ТекстXml = Лев(ТекстXml, ПозицияДок - 1)
				 + "<w:t>ВставитьЭП</w:t>"
				  + Сред(ТекстXml, ПозицияДок + СтрДлина("<w:t>Вставить</w:t>"));
				  
				НужноЗаписать = Истина; 
				  
				Прервать;
				
				
			КонецЕсли;	
			
		КонецЕсли;	
		  
		Позиция = ПозицияДок + 5;  
		
		ЧислоПроходов = ЧислоПроходов + 1;
		Если ЧислоПроходов > 1000 Тогда
			Прервать;
		КонецЕсли;	
		
	КонецЦикла;	
	
	Если НужноЗаписать Тогда
		ЗаписьТекста = Новый ЗаписьТекста(
			ИмяФайлаДокумента,
			КодировкаТекста.UTF8);
		ЗаписьТекста.Записать(ТекстXml);
		ЗаписьТекста.Закрыть(); 
	КонецЕсли;
	
КонецПроцедуры	

//Выполняет поиск указанной строки в файле MS Word формата 2007+
//Параметры
// ПолеДляПоиска - Строка или Массив строк
//
Функция ПроверитьНаличиеСтрокиВФайлеDocX(ПолеДляПоиска, ПутьКФайлу) Экспорт
	
	МассивПоиска = ПолеДляПоиска;
	Если ТипЗнч(ПолеДляПоиска) = Тип("Строка") Тогда
		МассивПоиска = Новый Массив;
		МассивПоиска.Добавить(ПолеДляПоиска);
	КонецЕсли;	
	
	КопироватьФайл(ПутьКФайлу, СтрЗаменить(ПутьКФайлу, "docx", "zip"));
	ИмяФайлаСПутемZIP = СтрЗаменить(ПутьКФайлу, "docx", "zip");

	ВременнаяПапкаДляРазархивирования = ПолучитьИмяВременногоФайла("");
	ВременныйZIPФайл = ПолучитьИмяВременногоФайла("zip"); 

	Архив = Новый ЧтениеZipФайла();
	Архив.Открыть(ИмяФайлаСПутемZIP);
	Архив.ИзвлечьВсе(ВременнаяПапкаДляРазархивирования, РежимВосстановленияПутейФайловZIP.Восстанавливать);
	Архив.Закрыть();
	
	КорректироватьРазрывы_ВставитьЭП(ВременнаяПапкаДляРазархивирования + "/word/document.xml");

	//поиск строк в теле документа
	ЧтениеXML = Новый ЧтениеXML();
	ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/document.xml");
	
	НайденаВТеле = Ложь;
	НайденаВКолонтитулах = Ложь;
	ФлагНайденаСтрока = Ложь;
	ФлагНайденаКартинка = Ложь;
	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда

			Если ЧтениеXML.Имя = "w:t" Тогда
				ФлагНайденаСтрока = Истина;
			КонецЕсли;
			Если ЧтениеXML.Имя =  "w:drawing" Тогда
				ФлагНайденаКартинка = Истина;
			КонецЕсли;
			Если ЧтениеXML.КоличествоАтрибутов() > 0 Тогда
				Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
					Если ФлагНайденаКартинка И ЧтениеXML.Имя = "name" Тогда
						СтрПоиска = ЧтениеXML.Значение;
						Если МассивПоиска.Найти(СтрПоиска) <> Неопределено Тогда
							НайденаВТеле = Истина;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
			Если ФлагНайденаСтрока Тогда
				
				Найден = Ложь;
				Для Каждого Подстрока Из МассивПоиска Цикл
					Если Найти(ЧтениеXML.Значение, Подстрока) > 0 Тогда
						Найден = Истина;
						Прервать;
					КонецЕсли;	
				КонецЦикла;
									
				Если Найден Тогда
					ЧтениеXML.Закрыть();
					НайденаВТеле = Истина;
				Иначе
					ФлагНайденаСтрока = Ложь;
				КонецЕсли;
				
			Иначе
				ФлагНайденаСтрока = Ложь;
			КонецЕсли;  
		КонецЕсли;
	КонецЦикла;
	ЧтениеXML.Закрыть();	
	Если НЕ НайденаВТеле Тогда
		Для Счетчик = 1 по 10 Цикл
			Если НайтиФайлы(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml").Количество() = 0 Тогда
				Прервать;
			КонецЕсли;

			ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml"); 

			Пока ЧтениеXML.Прочитать() Цикл
				Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда

					Если ЧтениеXML.Имя = "w:t" Тогда
						ФлагНайденаСтрока = Истина;
					КонецЕсли;

				ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
					
					Если ФлагНайденаСтрока Тогда
						
						Найден = Ложь;
						Для Каждого Подстрока Из МассивПоиска Цикл
							Если Найти(ЧтениеXML.Значение, Подстрока) > 0 Тогда
								Найден = Истина;
								Прервать;
							КонецЕсли;	
						КонецЦикла;
						
						Если Найден Тогда
							ЧтениеXML.Закрыть();
							НайденаВКолонтитулах = Истина;
						Иначе
							ФлагНайденаСтрока = Ложь;
						КонецЕсли;
							
					Иначе
						ФлагНайденаСтрока = Ложь;
					КонецЕсли;  
					
				КонецЕсли;
			КонецЦикла;
			
			ЧтениеXML.Закрыть();			
		КонецЦикла;
		Если НЕ НайденаВКолонтитулах Тогда
			Для Счетчик = 1 по 10 Цикл
				Если НайтиФайлы(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml").Количество() = 0 Тогда
					Прервать;
				КонецЕсли;

				ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml"); 

				Пока ЧтениеXML.Прочитать() Цикл
					Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда

						Если ЧтениеXML.Имя = "w:t" Тогда
							ФлагНайденаСтрока = Истина;
						КонецЕсли;

					ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
						
						Если ФлагНайденаСтрока Тогда
							
							Найден = Ложь;
							Для Каждого Подстрока Из МассивПоиска Цикл
								Если Найти(ЧтениеXML.Значение, Подстрока) > 0 Тогда
									Найден = Истина;
									Прервать;
								КонецЕсли;	
							КонецЦикла;
							
							Если Найден Тогда
								ЧтениеXML.Закрыть();
								НайденаВКолонтитулах = Истина;
							Иначе
								ФлагНайденаСтрока = Ложь;
							КонецЕсли;
								
						Иначе
							ФлагНайденаСтрока = Ложь;
						КонецЕсли;  
						
					КонецЕсли;
				КонецЦикла;
				
				ЧтениеXML.Закрыть();			
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Возврат НайденаВКолонтитулах ИЛИ НайденаВТеле;
	
КонецФункции

Процедура НайтиВсеПоляВФайлеDocX(ДвоичныеДанныеФайла, МассивПолей,
	ТекстыДляПоиска = Неопределено, НайденныеТексты = Неопределено)
	
	Если Не ЗначениеЗаполнено(ДвоичныеДанныеФайла) Тогда 
		Возврат;
	КонецЕсли;
	
	ВременныйФайл = ПолучитьИмяВременногоФайла("docx");
	ДвоичныеДанныеФайла.Записать(ВременныйФайл);
	
	КопироватьФайл(ВременныйФайл, СтрЗаменить(ВременныйФайл, "docx", "zip"));
	ИмяФайлаСПутемZIP = СтрЗаменить(ВременныйФайл, "docx", "zip");

	ВременнаяПапкаДляРазархивирования = ПолучитьИмяВременногоФайла("");
	ВременныйZIPФайл = ПолучитьИмяВременногоФайла("zip"); 

	Архив = Новый ЧтениеZipФайла();
	Архив.Открыть(ИмяФайлаСПутемZIP);
	Архив.ИзвлечьВсе(ВременнаяПапкаДляРазархивирования, РежимВосстановленияПутейФайловZIP.Восстанавливать);
	Архив.Закрыть();

	//поиск полей в теле документа
	ЧтениеXML = Новый ЧтениеXML();
	ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/document.xml");
	НайтиВсеПоля(ЧтениеXML, МассивПолей);	
	ЧтениеXML.Закрыть();
	
	Для Счетчик = 1 по 10 Цикл
		Если НайтиФайлы(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml").Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/header" + Счетчик + ".xml");
		НайтиВсеПоля(ЧтениеXML, МассивПолей);
		ЧтениеXML.Закрыть();
	КонецЦикла;
	
	Для Счетчик = 1 по 10 Цикл
		Если НайтиФайлы(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml").Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/footer" + Счетчик + ".xml");
		НайтиВсеПоля(ЧтениеXML, МассивПолей);
		ЧтениеXML.Закрыть();
	КонецЦикла;
	
	Если ТекстыДляПоиска <> Неопределено Тогда

		//поиск строк в теле документа
		ЧтениеXML = Новый ЧтениеXML();
		ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/word/document.xml");
		НайтиВсеТексты(ЧтениеXML, ТекстыДляПоиска, НайденныеТексты);	
		ЧтениеXML.Закрыть();
			
	КонецЕсли;	
	
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования);
	УдалитьФайлы(ВременныйZIPФайл);
	УдалитьФайлы(ВременныйФайл);
	
КонецПроцедуры

Процедура НайтиВсеТексты(ЧтениеXML, МассивПоиска, НайденныеТексты)
	
	ФлагНайденаСтрока = Ложь;
	
	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда

			Если ЧтениеXML.Имя = "w:t" Тогда
				ФлагНайденаСтрока = Истина;
			КонецЕсли;
			
			Если ЧтениеXML.КоличествоАтрибутов() > 0 Тогда
				Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
					
				КонецЦикла;
			КонецЕсли;
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
			Если ФлагНайденаСтрока Тогда
				
				Найден = Ложь;
				Для Каждого Подстрока Из МассивПоиска Цикл
					Если Найти(ЧтениеXML.Значение, Подстрока) > 0 Тогда
						НайденныеТексты.Добавить(Подстрока);
					КонецЕсли;	
				КонецЦикла;
									
				Если Найден Тогда
					ЧтениеXML.Закрыть();
				Иначе
					ФлагНайденаСтрока = Ложь;
				КонецЕсли;
				
			Иначе
				ФлагНайденаСтрока = Ложь;
			КонецЕсли;  
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры	

Процедура НайтиВсеПоля(ЧтениеXML, МассивПолей)
	
	ЧтениеXML.ИгнорироватьПробелы = Ложь;
	ФлагНайденоПоле = Ложь;	
	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Если ЧтениеXML.Имя = "w:bookmarkStart" Тогда
				ФлагНайденоПоле = Истина; 
			КонецЕсли;

			Если ЧтениеXML.КоличествоАтрибутов() > 0 Тогда
				Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
					Если ФлагНайденоПоле И ЧтениеXML.Имя = "w:name" 
						И Найти(ЧтениеXML.Значение, "_GoBack") = 0 
						И Лев(ЧтениеXML.Значение, 1) <> "_" Тогда 
						МассивПолей.Добавить(ЧтениеXML.Значение);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;	
	
КонецПроцедуры

// Осуществляет замену всех полей в файле MSWord, согласно переданному массиву данных для замены. 
// Пробегает по исходному файлу (ЧтениеXML) и делает такой же (ЗаписьXML) только с заменой полей.
// 
// Параметры: ЧтениеXML - объект ЧтениеXML, содержащий в себе файл, составляющий OpenOffice документ
//  ЧтениеXML - ЧтениеXML - Чтение XML
//  ЗаписьXML - ЗаписьXML - объект ЧтениеXML, содержащий в себе файл с измененными данными, составляющий OpenOffice документ
//  АдресXML - Строка - путь к временному файлу
//  МассивДанныхДляАвтоЗамен - Массив из Структура - массив настроек для заполнения файла данными:
//   * ТермДляЗамены - Строка - Имя поля в файле
//   * ЗаменяемаяСтрока - Строка - Что заменять
//   * ЗначениеЗамены - Произвольный - На что заменять
//   * НомерКолонкиТабличнойЧасти - Число - 
//  ЗаполнятьТолькоПоляРегистрации - Булево - учитываются только поля регистрации.
Процедура ВыполнитьЗаменуПолейИСтрокВДокументеMSOfficeOpenXML(
	ЧтениеXML, ЗаписьXML, АдресXML, МассивДанныхДляАвтоЗамен, ЗаполнятьТолькоПоляРегистрации = Ложь)
	
	// Примечание. В файле шаблона не должно быть скрытых закладок. И закладки не должны друг друга перекрывать, т.е.
	// внутри действия одной закладки не должно быть других закладок. 
	// И скрытые закладки не нужны, это отражено в документации.
	
	// Получаем количество строк в таблице товары, если она заполнена.
	КоличествоСтрок = 0;
	Для Каждого Настройка Из МассивДанныхДляАвтоЗамен Цикл 
		Если Настройка.НомерКолонкиТабличнойЧасти = 1 Тогда 
			КоличествоСтрок = Настройка.ЗначениеЗамены.Количество();
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	ЧтениеXML.ИгнорироватьПробелы = Ложь;
	
	ФлагНайденоПоле = Ложь; 
	// Закрывающий тэг bookMarkEnd должен быть с таким же id, каи открывающий
	//	(например <w:bookmarkEnd w:id="6"/>):
	IdТегаBookmark = Неопределено;
	ФлагНайденаСтрока = Ложь;
	
	ПереводСтроки = Ложь; ВозможенПереводСтроки = Ложь;
	СтрЗамены = "";
	СтрПоиска = "";
	
	СтрокаТаблицы = 0; НомерКолонки = 0;
	ФлагНайденаТаблица = Ложь; ФлагНайденаНашаТаблица = Ложь;
	ФлагНайденаСтрокаТаблицы = Ложь;
	
	// Иногда бывает, что текст поля "разрезает на куски" теги проверки орфографии, т.е. часть текста имеет по мнению Word ошибку,
	// тексты внутри таких тегов надо заменять на пустую строку.
	// но только уже после удачной замены, т.к. обычный текст тоже может быть внутри тегов орфограции - он должен остаться.
	ФлагПолеУдачноЗаменено = Ложь;
	
	ПервыйТег = КоличествоСтрок > 1; ПропуститьСтроку = Ложь;
	СтрокаXMLОткрыт = Ложь;
	
	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			// Найдено предполагаемое поле для замены
			ФлагТекущийТэгBookmarkStart = Ложь;
			Если ЧтениеXML.Имя = "w:bookmarkStart" Тогда
				ФлагНайденоПоле = Истина; 
				СкрытаяЗакладка = Ложь;
				ФлагПолеУдачноЗаменено = Ложь;
				ФлагТекущийТэгBookmarkStart = Истина;
			КонецЕсли;
			
			Если ЧтениеXML.Имя = "w:t" Тогда
				ФлагНайденаСтрока = Истина;
			КонецЕсли;
			
			// Предполагаем, что найдена наша таблица для замены
			Если ЧтениеXML.Имя = "w:tbl" И КоличествоСтрок > 0 Тогда
				ФлагНайденаТаблица = Истина;
				СтрокаТаблицы = 0;
			КонецЕсли;
			
			
			// Предполагаем, что найдена строка нашей таблица для замены
			Если ЧтениеXML.Имя = "w:tr" И ФлагНайденаТаблица Тогда 
				Если СтрокаТаблицы > КоличествоСтрок И ФлагНайденаНашаТаблица Тогда 
					ПропуститьСтроку = Истина;
					Продолжить;
				КонецЕсли;
				
				СтрокаТаблицы = СтрокаТаблицы + 1;
				
				Если СтрокаТаблицы = 2 И КоличествоСтрок > 1 Тогда
					ФлагНайденаСтрокаТаблицы = Истина;
				КонецЕсли;
			КонецЕсли;
			
			Если ЧтениеXML.Имя = "w:tc" Тогда 
				НомерКолонки = НомерКолонки + 1;
			КонецЕсли;
			
			// В случае перезаполнения файла, этот тег пропускаем, чтобы не создавались лишние переводы строки.
			Если ЧтениеXML.Имя = "w:br" И ВозможенПереводСтроки И Не ЗаполнятьТолькоПоляРегистрации Тогда
				ПереводСтроки = Истина;
				Продолжить;
			КонецЕсли;
			
			Если ПропуститьСтроку Тогда 
				Продолжить;
			КонецЕсли;
			
			
			ЗаписьXML.ЗаписатьНачалоЭлемента(ЧтениеXML.Имя);
			
			Если ПервыйТег Или ФлагНайденаСтрокаТаблицы Тогда
				Если Не СтрокаXMLОткрыт Тогда 
					КопияСтрокиXML = СоздатьНовуюЗапись(АдресXML);
					СтрокаXMLОткрыт = Истина;
				КонецЕсли;
				
				КопияСтрокиXML.ЗаписатьНачалоЭлемента(ЧтениеXML.Имя);
			КонецЕсли;
			
			// Читаем и записываем атрибуты тега
			Если ЧтениеXML.КоличествоАтрибутов() > 0 Тогда
				Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
					Если ФлагНайденоПоле И ЧтениеXML.Имя = "w:name"
						И Найти(ЧтениеXML.Значение, "_GoBack") = 0 Тогда
						СтрПоиска = ЧтениеXML.Значение;
						
						// Скрытые закладки начинаются с символа "_"
						Если Лев(ЧтениеXML.Значение, 1) = "_" Тогда 
							СкрытаяЗакладка = Истина;
						КонецЕсли;
						
						Если ФлагНайденаТаблица И Не ФлагНайденаНашаТаблица Тогда
							Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
								Если НастройкаЗамены.ТермДляЗамены = СтрПоиска 
									И НастройкаЗамены.НомерКолонкиТабличнойЧасти > 0 Тогда
									ФлагНайденаНашаТаблица = Истина;
									Прервать;
								КонецЕсли;
							КонецЦикла;
						КонецЕсли;
						
						Если ПервыйТег Или ФлагНайденаСтрокаТаблицы Тогда 
							КопияСтрокиXML.ЗаписатьАтрибут(ЧтениеXML.Имя, Лев(СтрПоиска, 19) + "1");
						КонецЕсли;
					
					ИначеЕсли ПервыйТег Или ФлагНайденаСтрокаТаблицы Тогда 
						КопияСтрокиXML.ЗаписатьАтрибут(ЧтениеXML.Имя, ЧтениеXML.Значение);
					КонецЕсли;
					
					ЗаписьXML.ЗаписатьАтрибут(ЧтениеXML.Имя, ЧтениеXML.Значение);
					
					Если ФлагНайденоПоле И Найти(ЧтениеXML.Значение, "_GoBack") > 0 Тогда
						ФлагНайденоПоле = Ложь; // Весь тег внутри этого поля перезапишем "как есть".
						СтрЗамены = "";
					КонецЕсли;
					
					Если ФлагТекущийТэгBookmarkStart И ЧтениеXML.Имя = "w:id" И IdТегаBookmark = Неопределено Тогда
						IdТегаBookmark = ЧтениеXML.Значение;
					КонецЕсли;
				КонецЦикла
			КонецЕсли;
			
			ПервыйТег = Ложь;
			
			
		// Текст тега
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
			
			Если ФлагПолеУдачноЗаменено Тогда
				
				// После удачной замены, все остальные куски текста до конца поля нужно пропустить,
				// иногда текст режется на куски тегами проверки орфографии.
				Продолжить;
				
			ИначеЕсли ПереводСтроки И ВозможенПереводСтроки И Не ЗаполнятьТолькоПоляРегистрации Тогда
				ЗаписьXML.ЗаписатьБезОбработки("");
				
			// Перезаполняем поля таблицы
			ИначеЕсли ФлагНайденаНашаТаблица И ФлагНайденоПоле И ФлагНайденаСтрока Тогда
				Если ПропуститьСтроку Тогда 
					Продолжить;
				КонецЕсли;
				
				СтрЗамены = СтрПоиска; // Имя поля, найденного ранее
				БылаВыполненаЗамена = Ложь;
				
				Если ЗначениеЗаполнено(СтрЗамены) Тогда 
					Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
						ИмяРеквизита = СтрЗаменить(Лев(НастройкаЗамены.ТермДляЗамены, 20), " ", "_");
						Если ИмяРеквизита <> СтрПоиска Тогда
							Продолжить;
						КонецЕсли;
						
						СтрЗамены = НастройкаЗамены.ЗначениеЗамены[СтрокаТаблицы - 2].Значение;
						БылаВыполненаЗамена = Истина;
						Прервать;
					КонецЦикла;
				КонецЕсли;
				
				ЗаписатьВXMLСодержимое(ЗаписьXML, СтрЗамены);
				
				Если ФлагНайденаСтрокаТаблицы Тогда 
					ЗаписатьВXMLСодержимое(КопияСтрокиXML, СтрЗамены);
				КонецЕсли;
				
				СтрЗамены = "";
				ФлагНайденоПоле = Ложь;
				
			// Перезаполняем поля документа. Замена поля на строку по шаблону.
			ИначеЕсли ФлагНайденоПоле И ФлагНайденаСтрока Тогда
				
				Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
					ИмяРеквизита = СтрЗаменить(Лев(НастройкаЗамены.ТермДляЗамены, 20), " ", "_");
					Если ИмяРеквизита = СтрПоиска И НастройкаЗамены.НомерКолонкиТабличнойЧасти = 0 Тогда
						СтрЗамены = НастройкаЗамены.ЗначениеЗамены;
						Прервать;
					КонецЕсли;
				КонецЦикла;

				Если ЗначениеЗаполнено(СтрЗамены) Тогда
					
					ЗаписатьВXMLСодержимое(ЗаписьXML, СтрЗамены);
					// Теперь все теги после удачной замены до конца тега: <w:bookmarkEnd w:id="Число"/> с таким же id,
					// как перед этим bookmarkStart: <w:bookmarkStart w:id="Число" w:name="ИмяПоляАвтозамены"/>
					ФлагПолеУдачноЗаменено = Истина;
					
				ИначеЕсли Не СкрытаяЗакладка И Не ЗаполнятьТолькоПоляРегистрации И СтрЗамены <> ЧтениеXML.Значение Тогда
					ЗаписьXML.ЗаписатьТекст(Символ(160));
				Иначе
					ЗаписьXML.ЗаписатьТекст(ЧтениеXML.Значение);
				КонецЕсли;
				
				ФлагНайденоПоле = Ложь;
				СтрЗамены = "";
				ВозможенПереводСтроки = Истина;
				
			// Перезаполняем строки документа. Замена строки шаблона на строку (один раз).
			ИначеЕсли ФлагНайденаСтрока Тогда
				СтрЗамены = ЧтениеXML.Значение;
				БылаВыполненаЗамена = Ложь;
				Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
					Если Не ЗначениеЗаполнено(НастройкаЗамены.ЗаменяемаяСтрока) Тогда
						Продолжить;
					КонецЕсли;
					Если Найти(СтрЗамены, НастройкаЗамены.ЗаменяемаяСтрока) > 0 Тогда
						СтрЗамены = СтрЗаменить(СтрЗамены, НастройкаЗамены.ЗаменяемаяСтрока,
							НастройкаЗамены.ЗначениеЗамены);
						БылаВыполненаЗамена = Истина;
					КонецЕсли;
				КонецЦикла;
				
				ЗаписатьВXMLСодержимое(ЗаписьXML, СтрЗамены);

				Если ФлагНайденаСтрокаТаблицы Тогда
					ЗаписатьВXMLСодержимое(КопияСтрокиXML, СтрЗамены);
				КонецЕсли;
			Иначе
				ЗаписьXML.ЗаписатьТекст(ЧтениеXML.Значение);
				
				Если ФлагНайденаСтрокаТаблицы Тогда 
					КопияСтрокиXML.ЗаписатьТекст(ЧтениеXML.Значение);
				КонецЕсли;
			КонецЕсли;
			
			
		// Читаем и записываем конец тега
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			// В случае перезаполнения файла, этот тег пропускаем, чтобы не создавались лишние переводы строки.
			Если ЧтениеXML.Имя = "w:br" И ВозможенПереводСтроки И Не ЗаполнятьТолькоПоляРегистрации Тогда
				Продолжить;
			КонецЕсли;
			
			Если ФлагНайденаТаблица И ЧтениеXML.Имя = "w:tbl" Тогда
				ФлагНайденаТаблица = Ложь;
				ФлагНайденаНашаТаблица = Ложь;
				ПропуститьСтроку = Ложь;
				СтрЗамены = "";
			КонецЕсли;
			
			
			Если ПропуститьСтроку Тогда 
				Продолжить;
			КонецЕсли;
			
			ЗаписьXML.ЗаписатьКонецЭлемента();
			Если ФлагНайденаСтрокаТаблицы Тогда
				КопияСтрокиXML.ЗаписатьКонецЭлемента();
			КонецЕсли;
			
			ЭтоBookmarkEnd = Ложь;
			Если ЧтениеXML.Имя = "w:bookmarkEnd" Тогда
				ЭтоBookmarkEnd = Истина; // в самом конце, после проверок таблицы нужно сбросить признаки перевода строки.
				ЭтоКонецПоляСТемЖеId = Ложь;
				Если ЧтениеXML.КоличествоАтрибутов() > 0 Тогда
					Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
						Если ЧтениеXML.Имя = "w:id" И ЧтениеXML.Значение = IdТегаBookmark Тогда
							ЭтоКонецПоляСТемЖеId = Истина;
							Прервать;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
				Если ЭтоКонецПоляСТемЖеId Тогда
					IdТегаBookmark = Неопределено;
					ФлагНайденоПоле = Ложь; СкрытаяЗакладка = Ложь;
					СтрЗамены = "";
					ФлагПолеУдачноЗаменено = Ложь;
				КонецЕсли;
			КонецЕсли;
			Если ФлагНайденаСтрока Тогда
				ФлагНайденаСтрока = Ложь;
				СтрЗамены = "";
			КонецЕсли;
			
			Если ЧтениеXML.Имя = "w:tr" И ФлагНайденаТаблица Тогда 
				НомерКолонки = 0;
				ФлагНайденаСтрокаТаблицы = Ложь;
				
				Если СтрокаТаблицы = 2 И КоличествоСтрок > 1 Тогда 
					КопияСтрокиXML.ЗаписатьКонецЭлемента();
					КопияСтрокиXML.Закрыть();
					СтрокаXMLОткрыт = Ложь;
					ЗаменитьПространствоИменR(АдресXML);
					
					// Добавление в документ копии первой строки таблицы, с последующим заполнением данными документа
					Если ФлагНайденаНашаТаблица Тогда 
						Пока СтрокаТаблицы - 1 < КоличествоСтрок Цикл 
							ЧтениеСтрокиXML = Новый ЧтениеXML();
							ЧтениеСтрокиXML.ОткрытьФайл(АдресXML);
							ЧтениеСтрокиXML.ИгнорироватьПробелы = Ложь;
							ФлагНайденоПоле = Ложь; ФлагНайденаСтрока = Ложь;
							
							Пока ЧтениеСтрокиXML.Прочитать() Цикл
								Если ЧтениеСтрокиXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
									
									// Первый тег пропускаем
									Если ЧтениеСтрокиXML.Имя = "w:document" Тогда 
										Продолжить;
									КонецЕсли;
									
									Если ЧтениеСтрокиXML.Имя = "w:bookmarkStart" Тогда
										ФлагНайденоПоле = Истина; 
									КонецЕсли;
									
									Если ЧтениеСтрокиXML.Имя = "w:t" Тогда
										ФлагНайденаСтрока = Истина;
									КонецЕсли;
									
									Если ЧтениеСтрокиXML.Имя = "w:tr" Тогда 
										СтрокаТаблицы = СтрокаТаблицы + 1;
									КонецЕсли;
									Если ЧтениеСтрокиXML.Имя = "w:tc" Тогда 
										НомерКолонки = НомерКолонки + 1;
									КонецЕсли;
					
									// В случае перезаполнения файла, этот тег пропускаем, чтобы не создавались лишние переводы строки.
									Если ЧтениеСтрокиXML.Имя = "w:br" И ВозможенПереводСтроки
										И Не ЗаполнятьТолькоПоляРегистрации Тогда
										ПереводСтроки = Истина;
										Продолжить;
									КонецЕсли;
					
									ЗаписьXML.ЗаписатьНачалоЭлемента(ЧтениеСтрокиXML.Имя);
									Если ЧтениеСтрокиXML.КоличествоАтрибутов() > 0 Тогда
										Пока ЧтениеСтрокиXML.ПрочитатьАтрибут() Цикл
											
											Если ФлагНайденоПоле И ЧтениеСтрокиXML.Имя = "w:name"
												И Найти(ЧтениеXML.Значение, "_GoBack") = 0 Тогда
												СтрПоиска = ЧтениеСтрокиXML.Значение;
											КонецЕсли;
											
											ЗаписьXML.ЗаписатьАтрибут(ЧтениеСтрокиXML.Имя, ЧтениеСтрокиXML.Значение);
										КонецЦикла
									КонецЕсли;
									
								ИначеЕсли ЧтениеСтрокиXML.ТипУзла = ТипУзлаXML.Текст Тогда
									Если ПереводСтроки И ВозможенПереводСтроки И Не ЗаполнятьТолькоПоляРегистрации Тогда
										ЗаписьXML.ЗаписатьБезОбработки("");
										
									ИначеЕсли ФлагНайденоПоле И ФлагНайденаСтрока Тогда 
										
										СтрЗамены = ЧтениеСтрокиXML.Значение;
										БылаВыполненаЗамена = Ложь;
										Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
											ИмяРеквизита = Лев(НастройкаЗамены.ТермДляЗамены, 19) + "1";
											Если ИмяРеквизита <> СтрПоиска Тогда
												Продолжить;
											КонецЕсли;
											
											СтрЗамены = НастройкаЗамены.ЗначениеЗамены[СтрокаТаблицы - 2].Значение;
											БылаВыполненаЗамена = Истина;
											Прервать;
										КонецЦикла;
										
										ЗаписатьВXMLСодержимое(ЗаписьXML, СтрЗамены);
										
										СтрЗамены = "";
										ФлагНайденоПоле = Ложь;
									Иначе 
										ЗаписьXML.ЗаписатьТекст(ЧтениеСтрокиXML.Значение);
									КонецЕсли;
									
								ИначеЕсли ЧтениеСтрокиXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
									// В случае перезаполнения файла, этот тег пропускаем, чтобы не создавались лишние переводы строки.
									Если ЧтениеСтрокиXML.Имя = "w:br" И ВозможенПереводСтроки
										И Не ЗаполнятьТолькоПоляРегистрации Тогда
										Продолжить;
									КонецЕсли;
									
									Если ЧтениеСтрокиXML.Имя = "w:document" Тогда 
										Продолжить;
									КонецЕсли;
									
									ЗаписьXML.ЗаписатьКонецЭлемента();
									
									Если ФлагНайденоПоле И ЧтениеСтрокиXML.Имя = "w:bookmarkEnd" Тогда
										ФлагНайденоПоле = Ложь;
										СтрЗамены = "";
									КонецЕсли;
									Если ФлагНайденаСтрока Тогда
										ФлагНайденаСтрока = Ложь;
										СтрЗамены = "";
									КонецЕсли;
									
									Если ЧтениеСтрокиXML.Имя = "w:tr" Тогда 
										НомерКолонки = 0;
									КонецЕсли;
								КонецЕсли;
							КонецЦикла;
						
							ЧтениеСтрокиXML.Закрыть();
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
			Если ЭтоBookmarkEnd И ВозможенПереводСтроки Тогда
				ПереводСтроки = Ложь;
				ВозможенПереводСтроки = Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Записывает в файл DOCX текст, содержащий спецсимволы (переводы строк, табуляция).
// 
// Параметры:
// 	ЗаписьXML - ЗаписьXML - ЗаписьXML, с помощью которой производится запись в файл.
// 	Содержимое - Строка - Текст, который нужно записать в файл.
//
Процедура ЗаписатьВXMLСодержимое(ЗаписьXML, Знач Содержимое)
	
	Спецсимволы = Новый Соответствие;
	Спецсимволы.Вставить("<w:br/>", Символы.ПС);
	Спецсимволы.Вставить("</w:t><w:tab/><w:t>", Символы.Таб);
	
	Для Каждого Спецсимвол Из Спецсимволы Цикл
		Содержимое = СтрЗаменить(Содержимое, Спецсимвол.Значение, СтрШаблон("_###_%1_###_", Спецсимвол.Ключ));
	КонецЦикла;
	
	МассивПодстрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Содержимое, "_###_", Ложь);
	
	Для Каждого Подстрока Из МассивПодстрок Цикл
		Если Спецсимволы[Подстрока] <> Неопределено Тогда
			ЗаписьXML.ЗаписатьБезОбработки(Подстрока);
		Иначе
			ЗаписьXML.ЗаписатьТекст(Подстрока);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Создает новый файл XML
Функция СоздатьНовуюЗапись(ИмяФайла)
	
	ФайлНаДиске = Новый Файл(ИмяФайла);
	Если ФайлНаДиске.Существует() Тогда
		ПереместитьФайл(ИмяФайла, ИмяФайла + "1");
		УдалитьФайлы(ИмяФайла);
		
		НовоеЧтениеXML = Новый ЧтениеXML();
		НовоеЧтениеXML.ОткрытьФайл(ИмяФайла + "1");
		НовоеЧтениеXML.ИгнорироватьПробелы = Ложь;
		
		СтрокаXML = Новый ЗаписьXML;
		СтрокаXML.ОткрытьФайл(ИмяФайла);
		СтрокаXML.ЗаписатьОбъявлениеXML();
		
		Пока НовоеЧтениеXML.Прочитать() Цикл
			СтрокаXML.ЗаписатьТекущий(НовоеЧтениеXML);
			Прервать;
		КонецЦикла;
		
		НовоеЧтениеXML.Закрыть();
		УдалитьФайлы(ИмяФайла + "1");
		
	Иначе 
		СтрокаXML = Новый ЗаписьXML;
		СтрокаXML.ОткрытьФайл(ИмяФайла);
		СтрокаXML.ЗаписатьОбъявлениеXML(); 
	КонецЕсли;
	
	Возврат СтрокаXML;
	
КонецФункции

// Выполняет в указанном xml замену пространства имен "r" на "dor".
Процедура ЗаменитьПространствоИменR(ИмяФайла) Экспорт
	
	ОбъектЧтениеТекста = Новый ЧтениеТекста(ИмяФайла, КодировкаТекста.UTF8);
	Строка = ОбъектЧтениеТекста.Прочитать();
	ОбъектЧтениеТекста.Закрыть();
	УдалитьФайлы(ИмяФайла);
	
	Пока Найти(Строка, "xmlns:lсrdo") > 0 Цикл
		Строка = СтрЗаменить(Строка, "xmlns:lсrdo", "xmlns:r");
	КонецЦикла;
	Пока Найти(Строка, " lсrdo:") > 0 Цикл
		Строка = СтрЗаменить(Строка, " lсrdo:", " r:");
	КонецЦикла;
	Пока Найти(Строка, "xmlns:rdo") > 0 Цикл
		Строка = СтрЗаменить(Строка, "xmlns:rdo", "xmlns:r");
	КонецЦикла;
	Пока Найти(Строка, " rdo:") > 0 Цикл
		Строка = СтрЗаменить(Строка, " rdo:", " r:");
	КонецЦикла;
	Пока Найти(Строка, "xmlns:dor") > 0 Цикл
		Строка = СтрЗаменить(Строка, "xmlns:dor", "xmlns:r");
	КонецЦикла;
	Пока Найти(Строка, " dor:") > 0 Цикл
		Строка = СтрЗаменить(Строка, " dor:", " r:");
	КонецЦикла;
	
	Строка = СтрЗаменить(Строка, "xmlns:r", "xmlns:dor");
	Строка = СтрЗаменить(Строка, " r:", " dor:");
	
	ОбъектЗапись = Новый ЗаписьТекста(ИмяФайла, КодировкаТекста.UTF8);
	ОбъектЗапись.Записать(Строка);
	ОбъектЗапись.Закрыть();
	
КонецПроцедуры

////////////////////////////////////////////////////
//// РАБОТА С OPEN OFFICE

// Выполняет поиск указанного элемента в файла OpenOffice Writer
//
// Параметры:
//  ПутьКФайлу - Строка - путь к файлу на диске на клиенте или на сервере, в зависимости от того,
//						откуда вызывается функция
//  МассивТегов - Массив строк - имя поля или строка, которую необходимо найти
//  ТипИскомыхДанных - Строка - если выполняется поиск строки, то необходимо указать "Строка", если поле - "Поле"
//
// Возвращаемое значение:
//  Булево - Признак того, что искомый элемент найден в файле.
Функция НайтиДанныеВФайлеOpenOfficeWriter(ПутьКФайлу, МассивТегов, ТипИскомыхДанных) Экспорт
	
	КопироватьФайл(ПутьКФайлу, СтрЗаменить(НРег(ПутьКФайлу), "odt", "zip"));
	ИмяФайлаСПутемZIP = СтрЗаменить(НРег(ПутьКФайлу), "odt", "zip");

	ВременнаяПапкаДляРазархивирования = ПолучитьИмяВременногоФайла("");
	
	Архив = Новый ЧтениеZipФайла();
	Архив.Открыть(ИмяФайлаСПутемZIP);
	Архив.ИзвлечьВсе(ВременнаяПапкаДляРазархивирования, РежимВосстановленияПутейФайловZIP.Восстанавливать);
	Архив.Закрыть();
	ЧтениеXML = Новый ЧтениеXML();
	
	ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/content.xml");
	РезультатПроверкиТела = АвтозаполнениеШаблоновФайловКлиентСервер.ПроверитьНаличиеПолейИСтрокВФайлеOpenOfficeWriter(
		ЧтениеXML, МассивТегов, ТипИскомыхДанных);
	ЧтениеXML.Закрыть();
	
	ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/styles.xml");
	РезультатПроверкиКолонтитулы = АвтозаполнениеШаблоновФайловКлиентСервер.ПроверитьНаличиеПолейИСтрокВФайлеOpenOfficeWriter(
		ЧтениеXML, МассивТегов, ТипИскомыхДанных);
	ЧтениеXML.Закрыть();
	
	Если ПустаяСтрока(РезультатПроверкиТела)
		ИЛИ ПустаяСтрока(РезультатПроверкиКолонтитулы) Тогда
		Найдено = Истина;
	Иначе
		Найдено = Ложь;
	КонецЕсли;
	
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования);
	УдалитьФайлы(ИмяФайлаСПутемZIP);	
	
	Возврат Найдено;
	
КонецФункции

//Выполняет замену полей и строк в документе OpenOffice Writer
//Параметры:ЧтениеXML - объект ЧтениеXML, содержащий в себе файл, составляющий OpenOffice документ
//			ЗаписьXML - объект ЧтениеXML, содержащий в себе файл с измененными данными, составляющий OpenOffice документ
//			МассивДанныхДляАвтоЗамен - массив настроек для заполнения файла данными
Процедура ВыполнитьЗаменуПолейИСтрокВДокументеOpenOfficeWriter(
	ЧтениеXML,ЗаписьXML,МассивДанныхДляАвтоЗамен,
	ЗаполнятьТолькоПоляРегистрации = Ложь) Экспорт
	
	ЧтениеXML.ИгнорироватьПробелы = Ложь;
	
	ФлагНайденоПоле = Ложь;
	ФлагНайденаСтрока = Ложь;
	СтрЗамены = "";
	СтрПоиска = "";
	ТекстБылЗаписан = Ложь;
	СтрокаСтиля = "";
	
	ИмяТега = "";
	СтрЗаменыРеквизита = "";
	СтрЗаменыРеквизитаНайдена = Ложь;
	
	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			
			Если ЧтениеXML.Имя = "text:variable-set" Или ЧтениеXML.Имя = "text:user-field-get" Тогда
				ФлагНайденоПоле = Истина;
			КонецЕсли;

			Если ЧтениеXML.Имя = "text:user-field-decl" Тогда
				ИмяТега = ЧтениеXML.Имя;
			КонецЕсли;
			
			Если ЧтениеXML.Имя = "text:p" ИЛИ ЧтениеXML.Имя = "text:span" Тогда
				ФлагНайденаСтрока = Истина;
			КонецЕсли;

			ЗаписьXML.ЗаписатьНачалоЭлемента(ЧтениеXML.Имя);

			Если ЧтениеXML.КоличествоАтрибутов() > 0 Тогда
				
				СтрЗаменыРеквизита = "";
				
				Если ИмяТега = "text:user-field-decl" Тогда
					ИмяПоля = ЧтениеXML.ПолучитьАтрибут("text:name");
					Если ЗначениеЗаполнено(ИмяПоля) Тогда
						
						Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
							Если НастройкаЗамены.ТермДляЗамены = ИмяПоля Тогда
								СтрЗаменыРеквизита = НастройкаЗамены.ЗначениеЗамены;
								СтрЗаменыРеквизитаНайдена = Истина;
							КонецЕсли;
						КонецЦикла;
						
					КонецЕсли;	
				КонецЕсли;	
				
				Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
					
					НовоеЗначение = ЧтениеXML.Значение;
					
					Если ИмяТега = "text:user-field-decl" 
						И ЧтениеXML.Имя = "office:string-value" 
						И СтрЗаменыРеквизитаНайдена Тогда
						НовоеЗначение = СтрЗаменыРеквизита;
					КонецЕсли;	
					
					Если ФлагНайденоПоле И ЧтениеXML.Имя = "text:name" Тогда
						СтрПоиска = ЧтениеXML.Значение;
					КонецЕсли;
					
					Если ЧтениеXML.Имя = "text:style-name" Тогда
						СтрокаСтиля = "text:style-name = """ + ЧтениеXML.Значение + """";
					КонецЕсли;
					
					Если ЗначениеЗаполнено(ЧтениеXML.Значение)
						И Не ЗначениеЗаполнено(НовоеЗначение)
						И ЗаполнятьТолькоПоляРегистрации Тогда
						НовоеЗначение = ЧтениеXML.Значение;  // оcтавляем как было
					КонецЕсли;
					
					ЗаписьXML.ЗаписатьАтрибут(ЧтениеXML.Имя, НовоеЗначение); 
					
				КонецЦикла
			КонецЕсли;
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
			
			Если ФлагНайденоПоле Тогда
				
				НайденаЗамена = Ложь;
				Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
					Если НастройкаЗамены.ТермДляЗамены = СтрПоиска Тогда
						СтрЗамены = НастройкаЗамены.ЗначениеЗамены;
						НайденаЗамена = Истина;
					КонецЕсли;
				КонецЦикла;
				
				Если ЗаполнятьТолькоПоляРегистрации И Не НайденаЗамена Тогда
					СтрЗамены = ЧтениеXML.Значение;
				КонецЕсли;	
				
				ЗаписьXML.ЗаписатьТекст(СтрЗамены);
				ТекстБылЗаписан = Истина;
			ИначеЕсли ФлагНайденаСтрока Тогда
				СтрЗамены = ЧтениеXML.Значение;
				БылаВыполненаЗамена = Ложь;
				Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
					Если Не ЗначениеЗаполнено(НастройкаЗамены.ЗаменяемаяСтрока) Тогда
						Продолжить;
					КонецЕсли;
					Если Найти(СтрЗамены, НастройкаЗамены.ЗаменяемаяСтрока) > 0 Тогда 
						СтрЗамены = СтрЗаменить(СтрЗамены, НастройкаЗамены.ЗаменяемаяСтрока, НастройкаЗамены.ЗначениеЗамены);
						БылаВыполненаЗамена = Истина;
					КонецЕсли;
				КонецЦикла;
				Если БылаВыполненаЗамена И Найти(СтрЗамены, Символы.ПС) > 0 Тогда
					СтрЗамены = СтрЗаменить(СтрЗамены, Символы.ПС, "</text:p><text:p " + СтрокаСтиля + ">");
					Если СтрЗамены <> ЧтениеXML.Значение Тогда
						ЗаписьXML.ЗаписатьБезОбработки(СтрЗамены);
					Иначе
						ЗаписьXML.ЗаписатьТекст(СтрЗамены);
					КонецЕсли;
				Иначе
					ЗаписьXML.ЗаписатьТекст(СтрЗамены);
                КонецЕсли;
			Иначе
				ЗаписьXML.ЗаписатьТекст(ЧтениеXML.Значение);
			КонецЕсли;  
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			
			Если НЕ ТекстБылЗаписан И ФлагНайденоПоле Тогда
				
				НайденаЗамена = Ложь;
				
				Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
					Если НастройкаЗамены.ТермДляЗамены = СтрПоиска Тогда
						СтрЗамены = НастройкаЗамены.ЗначениеЗамены;
						НайденаЗамена = Истина;
					КонецЕсли;
				КонецЦикла;
				
				Если ЗаполнятьТолькоПоляРегистрации И Не НайденаЗамена Тогда
					СтрЗамены = ЧтениеXML.Значение;
				КонецЕсли;	
				
				ЗаписьXML.ЗаписатьТекст(СтрЗамены);	
			КонецЕсли;
			ЗаписьXML.ЗаписатьКонецЭлемента();
			Если ФлагНайденоПоле Тогда
				ФлагНайденоПоле = Ложь;
				ТекстБылЗаписан = Ложь;
				СтрЗамены = "";
			КонецЕсли;
			Если ФлагНайденаСтрока Тогда
				ФлагНайденаСтрока = Ложь;
				СтрЗамены = "";
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

//Проверяет наличие полей для ввода и текстовых строк в OpenOffice Writer документе
//Параметры:ЧтениеXML - объект ЧтениеXML, содержащий в себе файл, составляющий OpenOffice документ
//			ПолеДляПоиска - имя искомого поля либо искомая строка, массив строк
//			РежимПоиска - режим поиска. Допустимые значения - "Поле" и "Строка"
//Возвращает:ПустаяСтрока, если искомое поле или строка найдены
//			 Значение параметра ПолеДляПоиска, если искомые данные не найдены
Функция ПроверитьНаличиеПолейИСтрокВФайлеOpenOfficeWriter(ЧтениеXML, ПолеДляПоиска, РежимПоиска) Экспорт
	
	МассивПоиска = ПолеДляПоиска;
	Если ТипЗнч(ПолеДляПоиска) = Тип("Строка") Тогда
		МассивПоиска = Новый Массив;
		МассивПоиска.Добавить(ПолеДляПоиска);
	КонецЕсли;	
	
	ФлагНайденоПоле = Ложь;
	ФлагНайденаСтрока = Ложь;
	ФлагНайденаКартинка = Ложь;
	СтрПоиска = "";

	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Если РежимПоиска = "Поле" Тогда
				Если ЧтениеXML.Имя = "text:variable-set" Или ЧтениеXML.Имя = "text:user-field-get" Тогда
					ФлагНайденоПоле = Истина;
				КонецЕсли;
			ИначеЕсли РежимПоиска = "Строка" Тогда
				Если ЧтениеXML.Имя = "text:p" Тогда
					ФлагНайденаСтрока = Истина;
				КонецЕсли;
				Если ЧтениеXML.Имя = "draw:frame" Тогда
					ФлагНайденаКартинка = Истина;
				КонецЕсли;
			КонецЕсли;

			Если ЧтениеXML.КоличествоАтрибутов() > 0 Тогда
				Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
					Если ФлагНайденоПоле И ЧтениеXML.Имя = "text:name" Тогда
						СтрПоиска = ЧтениеXML.Значение;
						Если МассивПоиска.Найти(СтрПоиска) <> Неопределено Тогда
							Возврат "";
						КонецЕсли;
					КонецЕсли;
					Если ФлагНайденаКартинка И ЧтениеXML.Имя = "draw:name" Тогда
						СтрПоиска = ЧтениеXML.Значение;
						Если МассивПоиска.Найти(СтрПоиска) <> Неопределено Тогда
							Возврат "";
						КонецЕсли;	
					КонецЕсли;
				КонецЦикла
			КонецЕсли;
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
			Если ФлагНайденоПоле Тогда
				Если МассивПоиска.Найти(СтрПоиска) <> Неопределено Тогда
					Возврат "";
				КонецЕсли;
			КонецЕсли;
			Если ФлагНайденаСтрока Тогда
				Для Каждого Подстрока Из МассивПоиска Цикл 
					Если СтрЧислоВхождений(ЧтениеXML.Значение, Подстрока) > 0 Тогда
						Возврат "";
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			Если ФлагНайденоПоле И (ЧтениеXML.Имя = "text:variable-set" Или ЧтениеXML.Имя = "text:user-field-get") Тогда
				ФлагНайденоПоле = Ложь;
			КонецЕсли; 
			Если ФлагНайденаСтрока И ЧтениеXML.Имя = "text:p" Тогда
				ФлагНайденаСтрока = Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПолеДляПоиска;
	
КонецФункции

//Осуществляет поиск полей (переменных) в файле OpenOfficeWriter
//Параметры:ЧтениеXML - объект типа ЧтениеXML, в который загружена часть файла OpenOffice.
//						content.xml - тело файла
//						styles.xml - верхний и нижний колонтитулы
//Возвращает:Массив наименований полей в указанной части файла. Массив пустой, если полей не найдено.
Функция НайтиПоляВФайлеOpenOfficeWriter(ЧтениеXML) Экспорт
	
	ДанныеДляВозврата = Новый Массив();
	ФлагНайденоПоле = Ложь;
	
	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Если ЧтениеXML.Имя = "text:variable-set" Или ЧтениеXML.Имя = "text:user-field-get" Тогда
				ФлагНайденоПоле = Истина;
			КонецЕсли;
			Если ЧтениеXML.КоличествоАтрибутов() > 0 Тогда
				Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
					Если ФлагНайденоПоле И ЧтениеXML.Имя = "text:name" Тогда
						ДанныеДляВозврата.Добавить(ЧтениеXML.Значение);
					КонецЕсли;
				КонецЦикла
			КонецЕсли;
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			Если ФлагНайденоПоле Тогда
				ФлагНайденоПоле = Ложь;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	
	Возврат ДанныеДляВозврата;
	
КонецФункции

//Выполняет замену данных в документе OpenOffice Writer
//Параметры:СтарыйПутьКФайлу - путь на диске, по которому выгружена текущая версия файла
//			ТекущаяВерсияРасширение - расширение файла
//			Файл - ссылка на объект файл, в котором следует выполнить замену
//			МассивДанныхДляАвтоЗамен - массив настроек для заполнения файла данными
//Возвращает:Путь на диске к заполненному файлу
Функция ЗаполнитьФайлOpenOfficeWriter(ДвоичныеДанныеФайла, ТекущаяВерсияРасширение, 
	МассивДанныхДляАвтоЗамен, ЗаполнятьТолькоПоляРегистрации = Ложь) Экспорт	
	
	СтарыйПутьКФайлу = ПолучитьИмяВременногоФайла(ТекущаяВерсияРасширение);
	ДвоичныеДанныеФайла.Записать(СтарыйПутьКФайлу);
	НовыйПутьКФайлу = ПолучитьИмяВременногоФайла(ТекущаяВерсияРасширение);
	
	КопироватьФайл(СтарыйПутьКФайлу, СтрЗаменить(СтарыйПутьКФайлу, ТекущаяВерсияРасширение, "zip"));
	ИмяФайлаСПутемZIP = СтрЗаменить(СтарыйПутьКФайлу, ТекущаяВерсияРасширение, "zip");

	ВременнаяПапкаДляРазархивирования = ПолучитьИмяВременногоФайла("");
	ВременныйZIPФайл = ПолучитьИмяВременногоФайла("zip"); 

	Архив = Новый ЧтениеZipФайла();
	Архив.Открыть(ИмяФайлаСПутемZIP);
	Архив.ИзвлечьВсе(ВременнаяПапкаДляРазархивирования, РежимВосстановленияПутейФайловZIP.Восстанавливать);
	Архив.Закрыть();

	//Заполнение полей в теле документа
	ЧтениеXML = Новый ЧтениеXML();
	ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/content.xml");
	ЗаписьXML = Новый ЗаписьXML;
	ПараметрыЗаписи = Новый ПараметрыЗаписиXML(,, Ложь, Ложь);
	ЗаписьXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/content_update.xml", ПараметрыЗаписи);
	ЗаписьXML.ЗаписатьОбъявлениеXML();
		
	ВыполнитьЗаменуПолейИСтрокВДокументеOpenOfficeWriter(ЧтениеXML, ЗаписьXML, 
		МассивДанныхДляАвтоЗамен, ЗаполнятьТолькоПоляРегистрации);
	ЧтениеXML.Закрыть();
	ЗаписьXML.Закрыть();

	ПереместитьФайл(ВременнаяПапкаДляРазархивирования + "/content_update.xml", ВременнаяПапкаДляРазархивирования + "/content.xml");
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования + "/content_update.xml");

	//заполнение полей в колонтитулах
	ЧтениеXML = Новый ЧтениеXML();
	ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/styles.xml");
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/styles_update.xml", ПараметрыЗаписи);
	ЗаписьXML.ЗаписатьОбъявлениеXML(); 

	ВыполнитьЗаменуПолейИСтрокВДокументеOpenOfficeWriter(ЧтениеXML, ЗаписьXML, МассивДанныхДляАвтоЗамен);
	
	ЧтениеXML.Закрыть();
	ЗаписьXML.Закрыть();
	
	ПереместитьФайл(ВременнаяПапкаДляРазархивирования + "/styles_update.xml", ВременнаяПапкаДляРазархивирования + "/styles.xml");
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования + "/styles_update.xml");
	
	Архиватор = Новый ЗаписьZipФайла(ВременныйZIPФайл, "", "");
	Архиватор.Добавить(ВременнаяПапкаДляРазархивирования + "\*.*", РежимСохраненияПутейZIP.СохранятьОтносительныеПути, РежимОбработкиПодкаталоговZIP.ОбрабатыватьРекурсивно);
	Архиватор.Записать();

	ПереместитьФайл(ВременныйZIPФайл, НовыйПутьКФайлу);
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования);	
	
	ДвоичныеДанныеЗаполненногоФайла = Новый ДвоичныеДанные(НовыйПутьКФайлу);
	УдалитьФайлы(СтарыйПутьКФайлу);
	УдалитьФайлы(НовыйПутьКФайлу);
	УдалитьФайлы(ИмяФайлаСПутемZIP);
	
	Возврат ДвоичныеДанныеЗаполненногоФайла;
	
КонецФункции

////////////////////////////////////////////////////
//// ПРОЧИЕ ФУНКЦИИ

//Осуществляет замену строк в текстовом документе
//Параметры:СтарыйПутьКФайлу - путь к выгруженной версии файла, в котором осуществляется замена
//			ТекущаяВерсияРасширение - расширение файла, в котором производится замена
//			МассивДанныхДляАвтоЗамен - массив данных для замены. Получается функцией ПолучитьМассивАвтозаполненийШаблона
//Возвращает:Путь к измененному файлу, если замена прошла успешно
//			 ПустаяСтрока, если содержимое исходного файла не удалось прочитать
Функция ЗаполнитьТекстовыйФайл(ДвоичныеДанныеФайла, ТекущаяВерсияРасширение, МассивДанныхДляАвтоЗамен) Экспорт
	
	СтарыйПутьКФайлу = ПолучитьИмяВременногоФайла(ТекущаяВерсияРасширение);
	ДвоичныеДанныеФайла.Записать(СтарыйПутьКФайлу);
	НовыйПутьКФайлу = ПолучитьИмяВременногоФайла(ТекущаяВерсияРасширение);
	
	Текст = Новый ЧтениеТекста(СтарыйПутьКФайлу);
	Стр = Текст.Прочитать();
	Текст.Закрыть();
	Если Стр <> Неопределено И 
		НЕ ПустаяСтрока(Стр) Тогда 
		
		Для Каждого НастройкаЗамены Из МассивДанныхДляАвтоЗамен Цикл
			Стр = СтрЗаменить(Стр, НастройкаЗамены.ЗаменяемаяСтрока, НастройкаЗамены.ЗначениеЗамены);
		КонецЦикла;
		
		РезультатЗамены = Новый ЗаписьТекста(НовыйПутьКФайлу);
		РезультатЗамены.Записать(Стр);
		РезультатЗамены.Закрыть();
		
		ДвоичныеДанныеЗаполненногоФайлам = Новый ДвоичныеДанные(НовыйПутьКФайлу);
		УдалитьФайлы(СтарыйПутьКФайлу);
		УдалитьФайлы(НовыйПутьКФайлу);
		Возврат ДвоичныеДанныеЗаполненногоФайлам;
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Выполняет заполнение файла данными его владельца в соответствии с правилами автозаполнения шаблонов файлов.
//
// Параметры:
//  ВызовСКлиента - Булево - признак того, что вызов выполняется с клиента.
//   * ИмяСвойстваПараметра - Список типов - Текстовое описание свойства (колонки) параметра.
//  ФайлСсылка - СправочникСсылка.Файл - ссылка на заполняемый файл.
//  ОбновлятьВерсиюПослеЗаполнения - Булево - признак того, что необходимо будет создать новую версию файла.
//	УникальныйИдентификатор - УникальныйИдентификатор - уникальный идентификатор формы, с которой выполняется вызов функции
//	ДокументВладелецФайла - СправочникСсылка.ДокументыПредприятия - ссылка на документ, по которому необходимо выполнить заполнение.
//	ЗаполнятьТолькоПоляРегистрации - Булево - если Истина, то заполняем только поля РегНомер РегДата и такие же скрипты
//
// Возвращаемое значение:
//  Структура - структура
//	* Результат - Булево - признак того, что заполнение выполнено
//	* ДвоичныеДанныеЗаполненногоФайла - ДвоичныеДанные - двоичные данные заполненного файла
//	* Описание - Строка - описание ошибки, если при заполнении произошла ошибка
Функция ЗаполнитьПоляФайлаДаннымиВладельца(
	ВызовСКлиента,
	ФайлСсылка,
	ОбновлятьВерсиюПослеЗаполнения,
	УникальныйИдентификатор = Неопределено,
	ДокументВладелецФайла = Неопределено,
	ЗаполнятьТолькоПоляРегистрации = Ложь) Экспорт
	
	НастройкиАвтозаполнения =
		АвтозаполнениеШаблоновФайловВызовСервера.ПолучитьНастройкиАвтозаполненияШаблоновФайлов(
			ФайлСсылка,
			ДокументВладелецФайла,
			,
			,
			ЗаполнятьТолькоПоляРегистрации);
			
	#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
		Запрос = Новый Запрос;
		Запрос.Текст = 
			"ВЫБРАТЬ ПЕРВЫЕ 1
			|	Файлы.ТекущаяВерсия КАК ТекущаяВерсия,
			|	ВерсииФайлов.ДатаМодификацииУниверсальная КАК ДатаМодификацииУниверсальная
			|ИЗ
			|	Справочник.Файлы КАК Файлы
			|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ВерсииФайлов КАК ВерсииФайлов
			|		ПО Файлы.ТекущаяВерсия = ВерсииФайлов.Ссылка
			|ГДЕ
			|	Файлы.Ссылка = &Файл";
		
		Запрос.Параметры.Вставить("Файл", ФайлСсылка);
		РезультатЗапроса = Запрос.Выполнить();
		
		ДанныеФайлаТаблица = РезультатЗапроса.Выгрузить();
		ДанныеФайла = Новый Структура();
		Для Каждого Строка Из ДанныеФайлаТаблица Цикл
			
			Для Каждого Колонка Из ДанныеФайлаТаблица.Колонки Цикл
				Данныефайла.Вставить(Колонка.Имя, Строка[Колонка.Имя]);
			КонецЦикла;
			
		КонецЦикла;
		
		ИмяКаталога = ФайловыеФункции.ПолучитьПутьКРабочемуКаталогуПользователя();
		
		Если ИмяКаталога = Неопределено Тогда
			ИмяКаталога = "";
		КонецЕсли;
		
		ИмяФайлаСПутемВРабочемКаталоге = РаботаСФайламиВызовСервера.ПолучитьИмяФайлаСПутемИзРегистра(
			ДанныеФайла.ТекущаяВерсия, ИмяКаталога, Истина, Ложь);
		
	#Иначе
		
		ДанныеФайла = РаботаСФайламиВызовСервера.ДанныеФайла(ФайлСсылка);
		
		ИмяФайлаСПутемВРабочемКаталоге = ДанныеФайла.ПолноеИмяФайлаВРабочемКаталоге;
		
	#КонецЕсли
	
	ФайлВКеше = Новый Файл(ИмяФайлаСПутемВРабочемКаталоге);
	
	Если ФайлВКеше.Существует() Тогда
		
		ДатаФайлаНаДиске = ФайлВКеше.ПолучитьУниверсальноеВремяИзменения();
		
		Если ДатаФайлаНаДиске > ДанныеФайла.ДатаМодификацииУниверсальная Тогда // В рабочем каталоге более новый
			НастройкиАвтозаполнения.ДвоичныеДанныеФайла = Новый ДвоичныеДанные(ИмяФайлаСПутемВРабочемКаталоге);
		КонецЕсли;
		
	КонецЕсли;
	
	ДанныеВозврата = Новый Структура;
	ДанныеВозврата.Вставить("ЕстьОшибка", Ложь);
	МассивЗамен = НастройкиАвтозаполнения.МассивЗамен;
	ЗаполнятьMSWordНаСервере = НастройкиАвтозаполнения.ВыполнятьЗаполнениеMSWordНаСервере; 
	РасширениеФайла = НастройкиАвтозаполнения.РасширениеФайла;
	ДвоичныеДанныеФайла = НастройкиАвтозаполнения.ДвоичныеДанныеФайла;
	ШаблонОснованиеДляСоздания = НастройкиАвтозаполнения.ОснованиеСозданияФайла;
	
	Если (НЕ ШаблонОснованиеДляСоздания.Пустая() 
		ИЛИ ДокументВладелецФайла <> Неопределено) 
		И МассивЗамен <> Неопределено 
		И МассивЗамен.Количество() > 0 Тогда
		
		Если ВызовСКлиента Тогда
			Если ЗаполнятьMSWordНаСервере Тогда 
				ДвоичныеДанныеЗаполненногоФайла = АвтозаполнениеШаблоновФайловВызовСервера.ВыполнитьАвтоЗаполнениеШаблона(
					ФайлСсылка, МассивЗамен, НастройкиАвтозаполнения);
				ДанныеВозврата.Вставить("Результат", Истина);
			Иначе
				Если ФорматMSWord(РасширениеФайла) Тогда
					ДвоичныеДанныеЗаполненногоФайла = ЗаполнитьФайлMSWordПоДвоичнымДанным(РасширениеФайла, МассивЗамен,
						ДвоичныеДанныеФайла);
					ДанныеВозврата.Вставить("Результат", Истина);
				ИначеЕсли РасширениеФайла = "odt" Тогда
					ДвоичныеДанныеЗаполненногоФайла = ЗаполнитьФайлOpenOfficeWriter(ДвоичныеДанныеФайла, РасширениеФайла, МассивЗамен);
					ДанныеВозврата.Вставить("Результат", Истина);
				ИначеЕсли ТекстовыйФормат(РасширениеФайла) Тогда
					ДвоичныеДанныеЗаполненногоФайла = ЗаполнитьТекстовыйФайл(ДвоичныеДанныеФайла, РасширениеФайла, МассивЗамен);
					ДанныеВозврата.Вставить("Результат", Истина);
				КонецЕсли;
			КонецЕсли;
		Иначе
			ДвоичныеДанныеЗаполненногоФайла = АвтозаполнениеШаблоновФайловВызовСервера.ВыполнитьАвтоЗаполнениеШаблона(
				ФайлСсылка, МассивЗамен, НастройкиАвтозаполнения);
		КонецЕсли;
		
		Если ОбновлятьВерсиюПослеЗаполнения Тогда
			Если ТипЗнч(ДвоичныеДанныеЗаполненногоФайла) <> Тип("Строка")
				И ДвоичныеДанныеЗаполненногоФайла <> Неопределено Тогда
				АвтозаполнениеШаблоновФайловВызовСервера.ОбновитьВерсиюИзДвоичныхДанных(ДвоичныеДанныеЗаполненногоФайла,
					ФайлСсылка, 
					"Заполнение полей файла",
					УникальныйИдентификатор);
				ДанныеВозврата.Вставить("Результат", Истина);
				ДанныеВозврата.Вставить("ДвоичныеДанныеЗаполненногоФайла", ДвоичныеДанныеЗаполненногоФайла);
			Иначе
				ДанныеВозврата.Вставить("Результат", Ложь);
				Если ДвоичныеДанныеЗаполненногоФайла = "Linux" Тогда
					ОписаниеОшибки = 
						НСтр("ru = 'Автозаполнение файлов Microsoft Word возможно только в Windows. Обратитесь к администратору.'");
					ДанныеВозврата.Вставить("Описание", ОписаниеОшибки);
					ДанныеВозврата.Вставить("ЕстьОшибка", Истина);
				Иначе
					ОписаниеОшибки = 
						НСтр("ru = 'Необходимо проверить правильность установки Microsoft Word. Обратитесь к администратору.'");
					ДанныеВозврата.Вставить("Описание", ОписаниеОшибки);
					ДанныеВозврата.Вставить("ЕстьОшибка", Истина);
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ДвоичныеДанныеЗаполненногоФайла <> Неопределено Тогда
			ДанныеВозврата.Вставить("Результат", Истина);
			ДанныеВозврата.Вставить("ДвоичныеДанныеЗаполненногоФайла", ДвоичныеДанныеЗаполненногоФайла);
		Иначе
			ДанныеВозврата.Вставить("Результат", Ложь);
		КонецЕсли;
	Иначе
		ДанныеВозврата.Вставить("Результат", Ложь);
		Если МассивЗамен = Неопределено Или МассивЗамен.Количество() = 0 Тогда
			ОписаниеОшибки = НСтр("ru = 'Невозможно выполнить заполнение. Не настроены правила заполнения.'");
		КонецЕсли;
		Если ШаблонОснованиеДляСоздания.Пустая() Тогда
			ОписаниеОшибки = НСтр("ru = 'Невозможно выполнить заполнение. Данный файл создан не из шаблона.'");
		КонецЕсли;
		ДанныеВозврата.Вставить("Описание", ОписаниеОшибки); 
	КонецЕсли;
	
	Если ДанныеВозврата.Результат = Истина Тогда
		АвтозаполнениеШаблоновФайловВызовСервера.ОповеститьАвтораОбАвтоматическомПерезаполненииФайла(ФайлСсылка);
	КонецЕсли;
	
	Возврат ДанныеВозврата;
	
КонецФункции

//Выполняет поиск всех таблиц в файле
Функция ПолучитьВсеТаблицыВФайле(СсылкаНаФайл) Экспорт
	
	Результат = Новый Массив;
	ДанныеФайла = РаботаСФайламиВызовСервера.ДанныеФайлаИДвоичныеДанные(СсылкаНаФайл);
	ДвоичныеДанныеФайла = ДанныеФайла.ДвоичныеДанные;
	РасширениеФайла = ДанныеФайла.ДанныеФайла.Расширение;
	Если РасширениеФайла = "docx" ИЛИ РасширениеФайла = "odt" Тогда
		//поиск таблиц на сервере через OpenXML
		Результат = АвтозаполнениеШаблоновФайловВызовСервера.ПолучитьВсеТаблицыФайлаOpenXML(
			ДвоичныеДанныеФайла, РасширениеФайла);
	ИначеЕсли РасширениеФайла = "doc" Тогда
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецЕсли

// Возвращает признак того, что файлы указанного расширения являются обычными текстовыми и
//	не поддерживают заполнение полей.
//
// Параметры:
//  Расширение - Строка - Проверяемое расширение файла.
//
// Возвращаемое значение:
//  Булево - признак того, что файлы указанного расширения являются обычными текстовыми и
//			 поддерживают заполнение полей.
Функция ТекстовыйФормат(Расширение) Экспорт
	Возврат Расширение = "txt" ИЛИ
		Расширение = "html" ИЛИ
		Расширение = "htm";
КонецФункции

#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

// Устанавливает пометку удаления для правил автозаполнения коллекции переданных файлов.
// 
// Параметры:
//  МассивФайлов - Массив Из СправочникСсылка.Файлы
//  ПометкаУдаления - Булево
// 
Процедура ПометитьПравилаАвтозаполненияНаУдаление(МассивФайлов, ПометкаУдаления) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	ПравилаАвтозаполненияФайлов.Ссылка КАК ПравилоАвтозаполнения
		|ИЗ
		|	Справочник.ПравилаАвтозаполненияФайлов КАК ПравилаАвтозаполненияФайлов
		|ГДЕ
		|	ПравилаАвтозаполненияФайлов.ШаблонФайла В (&МассивФайлов)";
	Запрос.УстановитьПараметр("МассивФайлов", МассивФайлов);
	
	МассивПравил = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("ПравилоАвтозаполнения");
	ОбщегоНазначенияДокументооборотВызовСервера.УстановитьПометкуУдаления(МассивПравил, ПометкаУдаления);
	
КонецПроцедуры

#КонецЕсли
